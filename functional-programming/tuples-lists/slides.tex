% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Tuples and Lists}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Tuples}

\section{Lists}

\subsection{Model}

\begin{frame}
  \frametitle{Model}

  \begin{itemize}
    \item a list of consists of an element (\alert{head})\\
      followed by the sublist of the remaining elements (\alert{tail})
  \end{itemize}

  \pause
  \medskip
  \begin{block}{Haskell list operations}
    \begin{itemize}
      \item check if empty: \pygment{haskell}{null}
      \item get the head: \pygment{haskell}{head}
      \item get the tail: \pygment{haskell}{tail}
      \item construct a list: \pygment{haskell}{item : sublist}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Operation Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
Prelude> head [1,2,3,4]
1
Prelude> tail [1,2,3,4]
[2,3,4]
Prelude> null [1,2,3,4]
False
Prelude> 1 : [2,3]
[1,2,3]
Prelude> 1 : (2 : (3 : []))
[1,2,3]
Prelude> 1 : 2 : 3 : []
[1,2,3]
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{List Operations}

  \begin{block}{Scala list operations}
    \begin{itemize}
      \item check if empty: \pygment{scala}{.isEmpty}
      \item get the head: \pygment{haskell}{.head}
      \item get the tail: \pygment{haskell}{.tail}
      \item construct a list: \pygment{haskell}{item :: sublist}
    \end{itemize}
  \end{block}
\end{frame}

\subsection{List Recursion}

\begin{frame}[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[length of a list]
    \begin{pygments}{haskell}
length' xs =
    if null xs
    then 0
    else 1 + length' (tail xs)
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write a tail recursive version
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[length of a list]
    \begin{pygments}{haskell}
length' xs =
    let
        lengthIter acc items =
            if null items
            then acc
            else lengthIter (acc + 1) (tail items)
    in
        lengthIter 0 xs
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Recursion Example}
  \begin{example}[sum of a list]
    \pause
    \begin{pygments}{haskell}
sum' xs =
    if null xs
    then 0
    else head xs + sum' (tail xs)
    \end{pygments}
  \end{example}

  \pause
  \begin{example}[Scala]
    \begin{pygments}{scala}
def sum(xs: List[Int]): Int =
    if (xs.isEmpty) 0
    else xs.head + sum(xs.tail)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[append two lists]
    \pause
    \begin{pygments}{haskell}
append xs ys =
    if null xs
    then ys
    else head xs : append (tail xs) ys
    \end{pygments}
  \end{example}

  \pause
  \begin{itemize}
    \item Haskell list append operator: \pygment{haskell}{++}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[generate list from lower to upper limit]
    \pause
    \begin{pygments}{haskell}
countUp lower upper =
    if lower > upper
    then []
    else lower : countUp (lower + 1) upper
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write a tail recursive version that generates the list\\
        from an upper limit down to a lower limit
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[generate list from upper to lower limit]
    \begin{pygments}{haskell}
countDown upper lower =
    let
        countDownIter acc u =
            if u < lower
            then acc
            else countDownIter (acc ++ [u]) (u - 1)
    in
        countDownIter [] upper
    \end{pygments}

% TODO: note the use of lower
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[maximum of a list]
    \pause
    \begin{pygments}{haskell}
max' xs =
    if null xs
    then error "empty list"
    else if null (tail xs)
         then head xs
         else if head xs > max' (tail xs)
              then head xs
              else max' (tail xs)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Recursion Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what happens if called as:\\
        \pygment{haskell}{max' (countDown 30 1)}\\
        \pygment{haskell}{max' (countUp 1 30)}
      \item fix the problem
   \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[maximum of a list]
    \begin{pygments}{haskell}
max' xs =
    if null xs
    then error "empty list"
    else if null (tail xs)
         then head xs
         else
             let
                 maxRest = max' (tail xs)
             in
                 if head xs > maxRest
                 then head xs
                 else maxRest
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{List Recursion Exercises}

  \begin{block}{Exercises}
    \begin{itemize}
      \item write a function that will reverse a list
      \item write a tail recursive function that will reverse a list
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[reverse a list]
    \begin{pygments}{haskell}
reverse' xs =
    if null xs
    then []
    else reverse' (tail xs) ++ [head xs]
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Recursion Example}

  \begin{example}[reverse a list]
    \begin{pygments}{haskell}
reverse' xs =
    let
        reverseIter acc items =
            if null items
            then acc
            else reverseIter (head items : acc) (tail items)
    in
        reverseIter [] xs
    \end{pygments}
  \end{example}
\end{frame}

\end{document}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 1: Introducing functional programming
      \item Chapter 3: Basic types and definitions
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
