% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage[scaled=0.95]{cabin}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,
        keywordstyle=\color{blue},
        showstringspaces=false}
\lstdefinestyle{syntax}{frame=single}
\lstset{language=Haskell}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Higher-Order Functions}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}

    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{footnotesize}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Higher-Order Functions}

\subsection{Function Order}

\begin{frame}
  \frametitle{First Class Values}

  \begin{itemize}
    \item \alert{first class values} can be:

    \smallskip
    \item assigned
    \item composed with other values
    \item passed as parameters
    \item returned as function results

    \pause
    \bigskip
    \item in functional programming, functions are first class values
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Order}

  \begin{itemize}
    \item \alert{first order functions}
    \smallskip
    \item only accept data as parameter, and
    \item only return data as result

    \pause
    \bigskip
    \item \alert{higher-order functions}
    \smallskip
    \item take functions as parameters, or
    \item return functions as result
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{First Order Function Examples}

  \begin{exampleblock}{sum up the squares in a range}
    \begin{lstlisting}
-- sqr :: Integer -> Integer
sumSqr :: Integer -> Integer -> Integer
sumSqr a b
  | a > b     = 0
  | otherwise = sqr a + sumSqr (a + 1) b
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{sum up the factorials in a range}
    \begin{lstlisting}
-- fac :: Integer -> Integer
sumFac :: Integer -> Integer -> Integer
sumFac a b
  | a > b     = 0
  | otherwise = fac a + sumFac (a + 1) b
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{}
    \begin{itemize}
      \item note the pattern

      \smallskip
      \begin{lstlisting}
sumFun a b
  | a > b     = 0
  | otherwise = fun a + sumFun (a + 1) b
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{}
    \begin{itemize}
      \item send the function as parameter

      \smallskip
      \begin{lstlisting}
sumF f a b
  | a > b     = 0
  | otherwise = f a + sumF f (a + 1) b

sumSqr a b = sumF sqr a b
sumFac a b = sumF fac a b
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{}
    \begin{itemize}
      \item what is the type of \lstinline|sumF|?

      \smallskip
      \begin{lstlisting}
sumF :: (Integer -> Integer) -> Integer -> Integer
        -> Integer
      \end{lstlisting}
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{Python}
    \begin{lstlisting}[language=Python]
def sum_f(f, a, b):
    total = 0
    while a <= b:
        total += f(a)
        a += 1
    return total

def sqr(x):
    return x * x

def sum_sqr(a, b):
    return sum_f(sqr, a, b)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{C}
    \begin{lstlisting}[language=C]
int sum_f(int (*f)(int), int a, int b)
{
    int total = 0;
    while (a <= b)
    {
        total += f(a);
        a += 1;
    }
    return total;
}
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{C}
    \begin{lstlisting}[language=C]
int sqr(int x)
{
    return x * x;
}

int sum_sqr(int a, int b)
{
    return sum_f(sqr, a, b);
}
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher-Order Function Example}

  \begin{exampleblock}{Rock - Paper - Scissors}
    \begin{itemize}
      \item parameterize \lstinline|generateMatch| regarding both strategies
    \end{itemize}

    \begin{lstlisting}
type Strategy = [Move] -> Move

generateMatch :: Strategy -> Strategy -> Integer
                 -> Match
generateMatch _  _  0 = ([], [])
generateMatch sA sB n =
    step (generateMatch sA sB (n - 1))
      where
        step :: Match -> Match
        step (movesA, movesB) = (sA movesB : movesA,
                                 sB movesA : movesB)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Example: Sorting}

\begin{frame}[fragile]
  \frametitle{Sorting}


  \begin{exampleblock}{}
    \begin{itemize}
      \item in C, \lstinline[language=C]{qsort} takes comparison function
        as parameter
    \end{itemize}

    \begin{lstlisting}[language=C]
typedef struct {
    int num, denom;
} rational;

rational items[] = {{3, 2}, {1, 3}, {2, 1}};
qsort(items, 3, sizeof(rational), compare_rationals);
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{}
    \begin{lstlisting}[language=C]
int compare_rationals(const void *r1, const void *r2)
{
    int num1 = ((rational *) r1)->num;
    int denom1 = ((rational *) r1)->denom;
    int num2 = ((rational *) r2)->num;
    int denom2 = ((rational *) r2)->denom;

    if (num1*denom2 > num2*denom1)
        return 1;
    else if (num1*denom2 < num2*denom1)
        return -1;
    else
        return 0;
}
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{}
    \begin{itemize}
      \item in Python, \lstinline[language=Python]{sorted} takes key function
        as parameter
    \end{itemize}

    \begin{lstlisting}[language=Python]
def second(p):
    return p[1]

def value(p):
    return p[0] / p[1]

pairs = [(3, 2), (1, 3), (2, 1)]

# sorted(pairs)             ~> [(1, 3), (2, 1), (3, 2)]
# sorted(pairs, key=second) ~> [(2, 1), (3, 2), (1, 3)]
# sorted(pairs, key=value)  ~> [(1, 3), (3, 2), (2, 1)]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{parameterize \lstinline|qSort| regarding comparison
      function}
    \begin{lstlisting}
qSort :: (a -> a -> Bool) -> [a] -> [a]
qSort precedes []     = []
qSort precedes (x:xs) =
    qSort precedes before ++ [x] ++ qSort precedes after
      where
        before = [a | a <- xs, a `precedes` x]
        after  = [b | b <- xs, not (b `precedes` x)]

-- qSort (<=) [4, 5, 3]       ~> [3, 4, 5]
-- qSort (>)  [4, 5, 3]       ~> [5, 4, 3]
-- qSort (<=) ["b", "a", "c"] ~> ["a", "b", "c"]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Anonymous Functions}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{itemize}
    \item no need to name small functions that are not used anywhere else\\
      $\rightarrow$ \alert{anonymous} functions
    \begin{lstlisting}[style=syntax]
\x1 x2 ... -> e
    \end{lstlisting}
  \end{itemize}

  \pause
  \medskip
  \begin{exampleblock}{example}
    \begin{lstlisting}
sumSqr :: Integer -> Integer -> Integer
sumSqr a b = sumF (\x -> x * x) a b
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{itemize}
    \item \lstinline|f x = e| is the same as \lstinline|f = \x -> e|
    \item except that anonymous functions can't be recursive
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{block}{Python}
    \begin{lstlisting}[language=Python, style=syntax]
lambda x1, x2, ...: e
    \end{lstlisting}
  \end{block}

  \medskip
  \begin{exampleblock}{examples}
    \begin{lstlisting}[language=Python]
def sum_sqr(a, b):
    sum_func(lambda x: x * x, a, b)
    \end{lstlisting}

    \pause
    \bigskip
    \begin{lstlisting}[language=Python]
sorted(pairs, key=lambda p: p[0] / p[1])
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Example: Fixed Points}

\begin{frame}
  \frametitle{Fixed Points}

  \begin{itemize}
    \item $x$ is a \emph{fixed point} of $f$:\\
      $f(x)=x$

    \medskip
    \item repeatedly apply $f$ until value doesn't change:\\
      $x \rightarrow f(x) \rightarrow f(f(x)) \rightarrow f(f(f(x)))
      \rightarrow \ldots$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fixed Points}

  \begin{exampleblock}{find fixed point}
    \begin{lstlisting}[deletekeywords={next}]
fixedPoint :: (Float -> Float) -> Float -> Float
fixedPoint f firstGuess = fpIter firstGuess
  where
    fpIter :: Float -> Float
    fpIter guess
      | isCloseEnough guess next = next
      | otherwise                = fpIter next
      where
        next = f guess

    isCloseEnough :: Float -> Float -> Bool
    isCloseEnough x y = (abs (x-y) / x) < 0.001
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Square Roots}

  \begin{exampleblock}{use fixed points to compute square roots}
    \begin{itemize}
      \item $y = \sqrt{x} \Rightarrow y * y = x \Rightarrow y = x / y$
      \item fixed point of the function $f(y) = x / y$
    \end{itemize}

    \smallskip
    \begin{lstlisting}[deletekeywords={sqrt}]
sqrt :: Float -> Float
sqrt x = fixedPoint (\y -> x / y) 1.0
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \vspace{-6pt}
  \begin{itemize}
    \item doesn't converge (try with $y=2$)
    \item average successive values (average damping)
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={sqrt}]
sqrt x = fixedPoint (\y -> (y + x/y) / 2.0) 1.0
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{List Functions}

\subsection{Map}

\begin{frame}[fragile]
  \frametitle{Map}

  \begin{itemize}
    \item transform all elements of a list
  \end{itemize}

  \begin{exampleblock}{example: floors of all elements of a list}
    \begin{lstlisting}
-- floorAll [5.7, 9.0, 2.3] ~> [5, 9, 2]
floorAll :: [Float] -> [Integer]

-- primitive recursive
floorAll []     = []
floorAll (x:xs) = floor x : floorAll xs

-- list comprehension
floorAll xs = [floor x | x <- xs]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map}

  \begin{itemize}
    \item \lstinline|map|: apply a function to all elements of a list
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={map}]
-- primitive recursive
map f []     = []
map f (x:xs) = f x : map f xs

-- list comprehension
map f xs = [f x | x <- xs]
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type?\\
      \lstinline|map :: (a -> b) -> [a] -> [b]|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map Example}

  \begin{exampleblock}{floors of all elements of a list}
    \begin{lstlisting}
floorAll :: [Float] -> [Integer]
    \end{lstlisting}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{lstlisting}[language=Python]
import math

map(math.floor, [5.7, 9.0, 2.3])
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map Examples}

  \begin{exampleblock}{make a list of n copies of an item}
    \begin{lstlisting}[deletekeywords={replicate}]
replicate :: Int -> a -> [a]
replicate n i = map (\_ -> i) [1 .. n]
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{zip two lists over a function}
    \begin{lstlisting}[frame=none]
zipWith (+)       [1, 2] [10, 12]   ~> [11, 14]
zipWith replicate [3, 2] ['a', 'b'] ~> ["aaa", "bb"]
    \end{lstlisting}

    \begin{lstlisting}[deletekeywords={zipWith}]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f xs ys = map (\(x, y) -> f x y) (zip xs ys)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Filter}

\begin{frame}[fragile]
  \frametitle{Filter}

  \begin{itemize}
    \item select all elements with a given property
  \end{itemize}

  \begin{exampleblock}{all odd elements of a list}
    \begin{lstlisting}
-- allOdds [4, 1, 3, 2] ~> [1, 3]
allOdds :: [Integer] -> [Integer]

-- primitive recursive
allOdds []     = []
allOdds (x:xs)
  | odd x      = x : allOdds xs
  | otherwise  = allOdds xs

-- list comprehension
allOdds xs = [x | x <- xs, odd x]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Filter}

  \begin{itemize}
    \item \lstinline|filter|: select elements that satisfy a predicate
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={filter}]
-- primitive recursive
filter f []     = []
filter f (x:xs)
  | f x       = x : filter f xs
  | otherwise = filter f xs

-- list comprehension
filter f xs = [x | x <- xs, f x]
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \lstinline|filter|?\\
      \lstinline|filter :: (a -> Bool) -> [a] -> [a]|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Filter Example}

  \begin{exampleblock}{all odd elements of a list}
    \begin{lstlisting}
allOdds :: [Integer] -> [Integer]
allOdds xs = filter odd xs
    \end{lstlisting}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{lstlisting}[language=Python]
def odd(n):
    return n%2 == 1

filter(odd, [4, 1, 3, 2])
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Filter Example}

  \begin{exampleblock}{how many elements in a list are above a threshold?}
    \begin{lstlisting}
howManyAbove :: Float -> [Float] -> Int
howManyAbove t xs = length (filter (\x -> x > t) xs)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Splitting Lists}

  \begin{itemize}
    \item take elements from the front of a list while a predicate is true\\
      \lstinline|takeWhile even [8, 2, 4, 5, 6] ~> [8, 2, 4]|
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={takeWhile}]
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile f []     = []
takeWhile f (x:xs)
  | f x            = x : takeWhile f xs
  | otherwise      = []
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: drop elements from the front of a list\\
      while a predicate is true\\
      \lstinline|dropWhile even [8, 2, 4, 5, 6] ~> [5, 6]|
  \end{itemize}
\end{frame}

\subsection{Fold}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{itemize}
    \item reduce the elements of a list to a single value
  \end{itemize}

  \begin{exampleblock}{sum all elements of a non-empty list}
    \begin{lstlisting}[deletekeywords={sum}]
-- sum [2, 8, 5] ~> 15
sum :: [Integer] -> Integer
sum [x]    = x
sum (x:xs) = x + sum xs
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{itemize}
    \item \lstinline|foldr1|: reduce a non-empty list to a value over a function
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={foldr1}]
foldr1 f [x]    = x
foldr1 f (x:xs) = x `f` (foldr1 f xs)

-- OR:
foldr1 f [x]    = x
foldr1 f (x:xs) = f x (foldr1 f xs)
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \lstinline|foldr1|?\\
      \lstinline|foldr1 :: (a -> a -> a) -> [a] -> a|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Expansion}

  \begin{block}{}
    \begin{lstlisting}
foldr1 f [e1, e2, ..., ej, ek]
    = e1 `f` (e2 `f` (... (ej `f` ek)...)
    = e1 `f` (foldr1 f [e2, ..., ej, ek])
    = f e1 (foldr1 f [e2, ..., ej, ek])
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{exampleblock}{sum all elements of a list}
    \begin{lstlisting}[deletekeywords={sum}]
sum :: [Integer] -> Integer
sum xs = foldr1 (+) xs
    \end{lstlisting}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{lstlisting}[language=Python, deletekeywords={reduce, sum}]
import functools
import operator

def sum(xs):
  return functools.reduce(operator.add, xs)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{itemize}
    \item \lstinline|foldr1| doesn't work on empty lists
    \item add a parameter as initial value for empty list:
      \lstinline|foldr|
  \end{itemize}

  \begin{block}{}
    \begin{lstlisting}
foldr f s [e1, e2, ..., ej, ek]
    = e1 `f` (e2 `f` (... (ej `f` (ek `f` s))...)
    = e1 `f` (foldr f s [e2, ..., ej, ek])
    = f e1 (foldr f s [e2, ..., ej, ek])
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={foldr}]
foldr f s []     = s
foldr f s (x:xs) = f x (foldr f s xs)
    \end{lstlisting}

    \pause
    \medskip
    \begin{itemize}
      \item what is the type of \lstinline|foldr|?\\
        \lstinline|foldr :: (a -> b -> b) -> b -> [a] -> b|
    \end{itemize}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{exampleblock}{sum all elements of a list}
    \begin{lstlisting}[deletekeywords={sum}]
sum :: [Integer] -> Integer
sum xs = foldr (+) 0 xs
    \end{lstlisting}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{lstlisting}[language=Python, deletekeywords={reduce, sum}]
import functools
import operator

def sum(xs):
  return functools.reduce(operator.add, xs, 0)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Examples}

  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={and, concat, product}]
product :: [Integer] -> Integer
product xs = foldr (*) 1 xs

fac :: [Integer] -> Integer
fac n = foldr (*) 1 [1 .. n]

and :: [Bool] -> Bool
and xs = foldr (&&) True xs

concat :: [[a]] -> [a]
concat xs = foldr (++) [] xs

maxList :: [Integer] -> Integer
maxList xs = foldr1 max xs
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Example}

  \begin{exampleblock}{how many elements in a list are above a threshold?}
    \begin{lstlisting}
howManyAbove :: Float -> [Float] -> Integer
howManyAbove t xs =
    foldr (\x n -> if x > t then n + 1 else n) 0 xs
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Example}

  \begin{exampleblock}{insertion sort}
    \begin{lstlisting}
ins :: Integer -> [Integer] -> [Integer]
ins i []      = [i]
ins i (x:xs)
  | i <= x    = i : x : xs
  | otherwise = x : ins i xs

iSort :: [Integer] -> [Integer]
iSort []     = []
iSort (x:xs) = ins x (iSort xs)

-- equivalent to:
iSort :: [Integer] -> [Integer]
iSort (x:xs) = foldr ins [] xs
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Left}

  \begin{block}{}
    \begin{lstlisting}
foldl f s [e1, e2, ..., ej, ek]
    = (...((s `f` e1) `f` e2) `f` ... ej) `f` ek
    = foldl f (s `f` e1) [e2, ..., ej, ek]
    = foldl f (f s e1) [e2, ..., ej, ek]
    \end{lstlisting}
  \end{block}

  \pause
  \begin{exampleblock}{}
    \begin{lstlisting}[deletekeywords={foldl}]
foldl f s []     = s
foldl f s (x:xs) = foldl f (f s x) xs
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \lstinline|foldl|?\\
      \lstinline|foldl :: (a -> b -> a) -> a -> [b] -> a|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Right - Fold Left}

  \begin{itemize}
    \item results not the same if function is not commutative
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
foldr (*) 1   [1 .. 7]        ~> 5040
foldl (*) 1   [1 .. 7]        ~> 5040

foldr (/) 1.0 [1.0, 2.0, 3.0] ~> 1.5
foldl (/) 1.0 [1.0, 2.0, 3.0] ~> 0.1666666
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Example: Edit Distance}

\begin{frame}[fragile]
  \frametitle{Edit Distance}

  \begin{exampleblock}{transform a source string into a destination string}
    \begin{itemize}
      \item operations: copy, insert, delete, change
      \item use the minimum number of operations
    \end{itemize}

    \begin{lstlisting}
data Edit = Copy
          | Insert Char
          | Delete
          | Change Char
            deriving (Eq, Show)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Edit Distance}

  \begin{exampleblock}{}
    \begin{lstlisting}
transform :: String -> String -> [Edit]
transform []          [] = []
transform xs          [] = map (\_ -> Delete) xs
transform []          ys = map Insert ys
transform xs@(x':xs') ys@(y':ys')
  | x' == y'  = Copy : transform xs' ys'
  | otherwise = best [Insert y' : transform xs  ys',
                      Delete    : transform xs' ys,
                      Change y' : transform xs' ys']
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Edit Distance}

  \begin{exampleblock}{find best path}
    \begin{lstlisting}
best :: [[Edit]] -> [Edit]
best [x]    = x
best (x:xs)
  | cost x <= cost b = x
  | otherwise        = b
  where
    b = best xs

cost :: [Edit] -> Int
cost xs = length (filter (\x -> x /= Copy) xs)
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: implement \lstinline|best| using \lstinline|fold|
  \end{itemize}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 10: \alert{Generalization: patterns of computation}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
