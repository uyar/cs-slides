% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Higher Order Functions}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Introduction}

\subsection{First Class Values}

\begin{frame}
  \frametitle{First Class Values}

  \begin{itemize}
    \item \alert{first class values} can be:
    \begin{itemize}
      \item assigned
      \item composed with other values
      \item passed as arguments
      \item returned as function results
    \end{itemize}

    \pause
    \bigskip
    \item \emph{type completeness principle}:\\
      No operation should be arbitrarily restricted in the types\\
      of its operands.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{C}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive & structure &  array  & function\\\hline\hline
        assign  &  $\surd$  &  $\surd$  &   $?$   &    $?$  \\\hline
        compose &  $\surd$  &  $\surd$  & $\surd$ &    $?$  \\\hline
        pass    &  $\surd$  &  $\surd$  &   $?$   &    $?$  \\\hline
        return  &  $\surd$  &  $\surd$  &   $?$   &    $?$
      \end{tabular}
    \end{table}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{Pascal}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive & record  &  array  & function \\\hline\hline
        assign  &  $\surd$  & $\surd$ & $\surd$ & $\times$ \\\hline
        compose &  $\surd$  & $\surd$ & $\surd$ & $\times$ \\\hline
        pass    &  $\surd$  & $\surd$ & $\surd$ & $\surd$  \\\hline
        return  &  $\surd$  &   $?$   &   $?$   & $\times$
      \end{tabular}
    \end{table}
  \end{block}

  \begin{itemize}
    \item type definition needed for arrays and records to be returned
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{Haskell, Scala, Python}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive &  tuple  &  list   & function\\\hline\hline
        assign  &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        compose &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        pass    &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        return  &  $\surd$  & $\surd$ & $\surd$ & $\surd$
      \end{tabular}
    \end{table}
  \end{block}
\end{frame}

\subsection{Function Order}

\begin{frame}[fragile]
  \frametitle{Function Order}

  \begin{definition}
    \alert{first order functions}: functions that\\
    \begin{itemize}
      \item only accept data as parameter, and
      \item only return data as result
    \end{itemize}

    \bigskip
    \alert{higher order functions}: functions that
    \begin{itemize}
      \item take other functions as parameter, or
      \item return functions as result
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{First Order Function Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
sumIntegers a b =
    if a > b then 0 else a + sumIntegers (a + 1) b
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{haskell}
cube x = x * x * x

sumCubes a b =
    if a > b then 0 else cube a + sumCubes (a + 1) b
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{haskell}
sumFactorials a b =
    if a > b then 0 else fact a + sumFactorials (a + 1) b
    \end{pygments}
  \end{example}
\end{frame}

\section{Functions as Parameters}

\subsection{Sending Functions}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{example}[Haskell]
    \pause
    \begin{pygments}{haskell}
sumFunc f a b =
    if a > b then 0 else f a + sumFunc f (a + 1) b
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{haskell}
sumCubes a b = sumFunc cube a b

sumFactorials a b = sumFunc fact a b
    \end{pygments}

    \pause
    \smallskip
    \begin{pygments}{haskell}
sumIntegers a b = sumFunc id a b
    \end{pygments}

    \pause
    \smallskip
    \begin{pygments}{haskell}
-- what is the type of sumFunc?
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions as Parameters}

  \begin{block}{Scala}
    \begin{pygments}{scala}
      fp: (t1, t2, ..., tn) => tr
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Scala]
    \pause
    \begin{pygments}{scala}
def sumFunc(f: Int => Int, a: Int, b: Int): Int =
    if (a > b) 0
    else f(a) + sumFunc(f, a + 1, b)

def cube(x: Int): Int = x * x * x

def sumCubes(a: Int, b: Int): Int = sumFunc(cube, a, b)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{example}[Python]
    \begin{pygments}{python}
def sum_func(f, a, b):
    total = 0
    while a <= b:
        total += f(a)
        a += 1
    return total

def cube(x):
    return x * x * x

def sum_cubes(a, b):
    return sum_func(cube, a, b)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions as Parameters}

  \begin{block}{C}
    \begin{pygments}{c}
      tr (*fp)(t1, t2, ..., tn)
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[C]
    \begin{pygments}{c}
int sum_func(int (*f)(int), int a, int b)
{
    int total = 0;
    while (a <= b)
    {
        total += f(a);
        a += 1;
    }
    return total;
}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{example}[C]
    \begin{pygments}{c}
int cube(int x)
{
    return x * x * x;
}

int sum_cubes(int a, int b)
{
    return sum_func(cube, a, b);
}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{itemize}
    \item typical use: sorting functions take key function as parameter
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
def pair_key(p):
    return p[1]

pairs = [(3, 2), (1, 3), (2, 1)]
sorted(pairs)                   # [(1, 3), (2, 1), (3, 2)]
sorted(pairs, key=pair_key)     # [(2, 1), (3, 2), (1, 3)]
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Anonymous Functions}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{itemize}
    \item no need to name small functions that are not used anywhere else\\
      $\rightarrow$ \alert{anonymous functions}
    \item anonymous functions can't be recursive
  \end{itemize}

  \pause
  \begin{block}{Haskell}
    \begin{pygments}{haskell}
      \fp1 fp2 ... -> e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}
    \begin{pygments}{haskell}
sumCubes a b = sumFunc (\x -> x * x * x) a b
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{block}{Scala}
    \begin{pygments}{scala}
      (fp1: t1, fp2: t2, ...) => block
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}
    \begin{pygments}{scala}
def sumCubes(a: Int, b: Int): Int =
    sumFunc((x: Int) => x * x * x, a, b)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{block}{Python}
    \begin{pygments}{python}
      lambda fp1, fp2, ...: e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}
    \begin{pygments}{python}
def sum_cubes(a, b):
    sum_func(lambda x: x * x * x, a, b)
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{python}
sorted(pairs, key=lambda p: p[1])
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Higher Order List Functions}

\begin{frame}[fragile]
  \frametitle{filter}

  \begin{itemize}
    \item \pygment{haskell}{filter}: select elements that satisfy a predicate
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
filter odd [4,1,3,2]                    -- [1,3]
filter (\n -> n % 2 == 0) [4,1,3,2]     -- [4,2]

-- what is the type of filter?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own version of filter
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{filter}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
filter' f xs =
    case xs of
      [] -> []
      x:xs' -> if f x
               then x : filter' f xs'
               else filter' f xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{filter}

  \begin{example}[Python]
    \begin{pygments}{python}
def odd(n):
    return n % 2 == 1

filter(odd, [4, 1, 3, 2])
filter(lambda n: n % 2 == 0, [4, 1, 3, 2])
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{map}

  \begin{itemize}
    \item \pygment{haskell}{map}: apply a function to each element
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
map sqrt [16.0,9.0,121.0]     -- [4.0,3.0,11.0]

-- what is the type of map?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
map :: (a -> b) -> [a] -> [b]
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own version of map
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{map}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
map' f xs =
    case xs of
      [] -> []
      x:xs' -> f x : map' f xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{map}

  \begin{example}[Python]
    \begin{pygments}{python}
import math
map(math.sqrt, [16.0, 9.0, 121.0])
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold}

  \begin{itemize}
    \item fold: reduce a list to a value over a function
    \begin{itemize}
      \item left and right variants
    \end{itemize}

    \medskip
    \item \pygment{haskell}{foldl f acc [x1,x2,x3,x4]}:\\
      \pygment{haskell}{f(f(f(f(acc,x1),x2),x3),x4)}
    \item \pygment{haskell}{foldr f acc [x1,x2,x3,x4]}:\\
      \pygment{haskell}{f(x1,f(x2,f(x3,f(x4,acc))))}
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
foldl (\x y -> x + y) 0 [1,2,3,4]   -- 10
foldl (*) 1 [1..7]                  -- 5040
foldl (/) 1.0 [1.0,2.0,3.0]         -- 0.1666666
foldr (/) 1.0 [1.0,2.0,3.0]         -- 1.5
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
-- what are the types of foldl and foldr?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
foldl :: (a -> b -> a) -> a -> [b] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own versions of foldl and foldr
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{fold}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
foldl' f acc xs =
    case xs of
      [] -> acc
      x:xs' -> foldl' f (f acc x) xs'

foldr' f acc xs =
    case xs of
      [] -> acc
      x:xs' -> foldr' f (f x acc) xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that finds the maximum of a list using fold
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{fold Example}

  \begin{example}[maximum of a list]
    \begin{pygments}{haskell}
max' xs =
    case xs of
      [] -> error "empty list"
      x:xs' -> foldl' (\m n -> if m > n then m else n) x xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold}

  \begin{example}[Python]
    \begin{pygments}{python}
reduce(lambda x, y: x / y,
       [1.0, 2.0, 3.0], 1)      # 0.1666666
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension}

  \begin{itemize}
    \item construct a list over generators and predicates
  \end{itemize}

  \pause
  \begin{block}{Haskell}
    \begin{itemize}
      \item \pygment{haskell}{[e | v1 <- g1, v2 <- g2, ..., p]}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
[x | x <- [1..8], odd x]
-- [1,3,5,7]

[(x, y) | x <- [1..3], y <- [2,3], x < y]
-- [(1,2),(1,3),(2,3)]

[x + y | x <- [1..3], y <- [2,3], x < y]
-- [3,4,5]
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension Example}

  \begin{example}[quick sort]
    \begin{pygments}{haskell}
quickSort [] = []
quickSort (pivot:xs) =
    quickSort [y | y <- xs, y <= pivot]
    ++ [pivot]
    ++ quickSort [y | y <- xs, y > pivot]
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension}

  \begin{block}{Python}
    \begin{itemize}
      \item \pygment{python}{[e for v1 in g1 for v2 in g2 ... if p]}
    \end{itemize}
  \end{block}

  \begin{example}
    \begin{pygments}{python}
[x for x in range(1, 9) if x % 2 == 1]

[(x, y) for x in range(1, 4) for y in range(2, 4) if x < y]

[x + y for x in range(1, 4) for y in range(2, 4) if x < y]
    \end{pygments}
  \end{example}
\end{frame}

\section{Functions as Result}

\subsection{Returning Functions}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
maxOrMin p = if p then max else min

(maxOrMin True) 1 2   -- 2
(maxOrMin False) 1 2  -- 1
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- what is the type of maxOrMin?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- maxOrMin :: Bool -> (Integer -> Integer -> Integer)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def max(x: Int, y: Int): Int = if (x > y) x else y

def min(x: Int, y: Int): Int = if (x < y) x else y

def maxOrMin(p: Boolean): (Int, Int) => Int =
    if (p) max else min

maxOrMin(true)(1, 2)          // 2
maxOrMin(false)(1, 2)         // 1
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Python]
    \begin{pygments}{python}
def max_or_min(p):
    return max if p else min

max_or_min(True)([1, 2])        # 2
max_or_min(False)([1, 2])       # 1
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Function Closures}

\begin{frame}[fragile]
  \frametitle{Function Closure}

  \begin{itemize}
    \item a function value has two parts:
    \begin{itemize}
      \item the code
      \item the environment that was current when the function was defined
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
sumFunc f =
    let
        sumF a b =
            if a > b
            then 0
            else f a + sumF (a + 1) b
    in
        sumF

sumCubes = sumFunc (\x -> x * x * x)

sumFactorials = sumFunc factorial
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def sum(f: Int => Int): (Int, Int) => Int = {
    def sumF(a: Int, b: Int): Int =
        if (a > b) 0
        else f(a) + sumF(a + 1, b)
    sumF
}

def sumCubes = sum(x => x * x * x)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Result Example}

  \begin{example}[Python]
    \begin{pygments}{python}
def sum_func(f):
    def sum_f(a, b):
        total = 0.0
        while a <= b:
            total += f(a)
            a += 1
        return total
    return sum_f

def sum_cubes():
    return sum_func(lambda x: x * x * x)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decorators}

  \begin{block}{Python}
    \begin{itemize}
      \item a decorator returns a transformed version of its function parameter
    \end{itemize}
  \end{block}

  \begin{example}[Python]
    \begin{pygments}{python}
def entry_exit(f):
    def wrapped(x):
        print("Entering function with parameter: %s" % x)
        result = f(x)
        print("Exiting function with result: %s" % result)
        return result
    return wrapped
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decorator Example}

  \begin{example}[Python]
    \begin{pygments}{python}
def fact(n):
    return 1 if n == 0 else n * fact(n - 1)

entry_exit(fact)(5)
    \end{pygments}

    \pause
    \medskip
    \begin{pygments}{python}
@entry_exit
def fact(n):
    return 1 if n == 0 else n * fact(n - 1)

fact(5)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decorator Example}

  \begin{example}[Fibonacci series]
    \begin{pygments}{python}
def fibonacci(n):
    if n == 1 or n == 2:
        return 1
    else:
        return fibonacci(n - 2) + fibonacci(n - 1)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Decorator Example}

  \begin{example}[memoization]
    \begin{pygments}{python}
def memoize(f):
    cache = {}
    def wrapped(x):
        if x not in cache:
            cache[x] = f(x)
        return cache[x]
    return wrapped

@memoize
def fibonacci(n):
    ...
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Currying}

\begin{frame}
  \frametitle{Currying}

  \begin{itemize}
    \item a function which takes two parameters can be thought of as\\
      a function which takes one parameter\\
      and returns a function which takes one parameter
    \item generalize for n parameters: \alert{currying}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Currying Example}

  \begin{example}
    \begin{pygments}{haskell}
add x y = x + y
-- add :: Integer -> Integer -> Integer
    \end{pygments}

    \pause
    \medskip
    \begin{pygments}{haskell}
increment = add 1
-- increment :: Integer -> Integer
    \end{pygments}

    \pause
    \medskip
    \begin{pygments}{haskell}
increment 7
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Currying Example}

  \begin{example}
    \begin{pygments}{haskell}
productFunc f a b =
    if a > b then 1 else f a * productFunc f (a + 1) b
    \end{pygments}

    \pause
    \medskip
    \begin{pygments}{haskell}
productAbs = productFunc abs

productIntegers = productFunc id

factorial = productFunc id 1
-- or: factorial = productIntegers 1
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Currying Example}

  \begin{example}
    \begin{pygments}{scala}
def sum(f: Int => Int)(a: Int, b: Int) =
    if (a > b) 0
    else f(a) + sum(f)(a + 1, b)

sum(cube)(1, 8)
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Function Composition}

\begin{frame}[fragile]
  \frametitle{Function Composition}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
f . g
    \end{pygments}
  \end{block}

  \pause
  \begin{example}
    \begin{pygments}{haskell}
even' = not . odd
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- what is the type of (.)?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
(.) : (b -> c) -> (a -> b) -> a -> c
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Composition Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item \pygment{haskell}{second'}: second element of a list
      \item \pygment{haskell}{last'}: last element of a list
      \item \pygment{haskell}{length'}: length of a list
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Function Composition Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
second' = head . tail
last' = head . reverse
length' = sum . map (\_ -> 1)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{example}[finding fixed points]
    \begin{itemize}
      \item $x$ is a \emph{fixed point} of $f$: $f(x)=x$
      \item find fixed point by repeatedly applying $f$ until value doesn't change:\\
        $x,f(x),f(f(x)),f(f(f(x))),\ldots$

      \medskip
      \item $y = \sqrt{x} \Rightarrow y * y = x \Rightarrow y = x / y$
      \item fixed point of the function $f(y) = x / y$
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Higher Order Function Example}

  \begin{example}[fixed point]
    \begin{pygments}{haskell}
fixedPoint f firstGuess =
    let
        isCloseEnough x y = (abs (x - y) / x) < 0.001

        fpIter guess =
            let
                next = f guess
            in
                if isCloseEnough guess next
                then next
                else fpIter next
    in
        fpIter firstGuess
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Higher Order Function Example}

  \begin{example}[fixed point]
    \begin{pygments}{haskell}
newton x = fixedPoint (\y -> x / y) 1.0
    \end{pygments}

    \pause
    \begin{itemize}
      \item this doesn't converge (try with $y = 2$)
      \item average successive values (average damping)
    \end{itemize}
    \begin{pygments}{haskell}
newton x = fixedPoint (\y -> (y + x / y) / 2.0) 1.0
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Higher Order Function Example}

  \begin{example}[fixed point]
    \begin{itemize}
      \item a general function for average damping
    \end{itemize}
    \begin{pygments}{haskell}
averageDamp f x = (x + f x) / 2.0

newton x = fixedPoint (averageDamp (\y -> x / y)) 1.0
    \end{pygments}
  \end{example}
\end{frame}
%
% \section*{References}
%
% \begin{frame}
%   \frametitle{References}
%
%   \begin{block}{Required Reading: Abelson, Sussman}
%     \begin{itemize}
%       \item Chapter 1: Building Abstractions with Procedures
%       \begin{itemize}
%         \item 1.1. \alert{The Elements of Programming}
%       \end{itemize}
%     \end{itemize}
%   \end{block}
% \end{frame}

\end{document}
