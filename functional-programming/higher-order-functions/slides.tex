% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Higher Order Functions}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Introduction}

\subsection{First Class Values}

\begin{frame}
  \frametitle{First Class Values}

  \begin{itemize}
    \item \alert{first class values} can be:
    \begin{itemize}
      \item assigned
      \item composed with other values
      \item passed as parameters
      \item returned as function results
    \end{itemize}

    \pause
    \bigskip
    \item \emph{type completeness principle}:\\
      No operation should be arbitrarily restricted\\
      in the types of its operands.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{C}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive & structure &  array  & function\\\hline\hline
        assign  &  $\surd$  &  $\surd$  &   $?$   &    $?$  \\\hline
        compose &  $\surd$  &  $\surd$  & $\surd$ &    $?$  \\\hline
        pass    &  $\surd$  &  $\surd$  &   $?$   &    $?$  \\\hline
        return  &  $\surd$  &  $\surd$  &   $?$   &    $?$
      \end{tabular}
    \end{table}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{Pascal}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive & record  &  array  & function \\\hline\hline
        assign  &  $\surd$  & $\surd$ & $\surd$ & $\times$ \\\hline
        compose &  $\surd$  & $\surd$ & $\surd$ & $\times$ \\\hline
        pass    &  $\surd$  & $\surd$ & $\surd$ & $\surd$  \\\hline
        return  &  $\surd$  &   $?$   &   $?$   & $\times$
      \end{tabular}
    \end{table}
  \end{block}

  \begin{itemize}
    \item type definition needed for arrays and records to be returned
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{First Class Values}

  \begin{block}{Haskell, Python}
    \begin{table}
      \begin{tabular}{l||c|c|c|c}
                & primitive &  tuple  &  list   & function\\\hline\hline
        assign  &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        compose &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        pass    &  $\surd$  & $\surd$ & $\surd$ & $\surd$ \\\hline
        return  &  $\surd$  & $\surd$ & $\surd$ & $\surd$
      \end{tabular}
    \end{table}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Order}

  \begin{definition}
    \alert{first order functions}
    \begin{itemize}
      \item only accept data as parameter, and
      \item only return data as result
    \end{itemize}

    \bigskip
    \alert{higher order functions}
    \begin{itemize}
      \item take functions as parameters, or
      \item return functions as result
    \end{itemize}
  \end{definition}
\end{frame}

\subsection{Functions as Parameters}

\begin{frame}[fragile]
  \frametitle{First Order Function Examples}

  \begin{itemize}
    \item consider functions that sum up the values of a function in a range
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- cube :: Integer -> Integer
sumCubes :: Integer -> Integer -> Integer
sumCubes a b
  | a > b     = 0
  | otherwise = cube a + sumCubes (a + 1) b
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- fact :: Integer -> Integer
sumFacts :: Integer -> Integer -> Integer
sumFacts a b
  | a > b     = 0
  | otherwise = fact a + sumFacts (a + 1) b
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{itemize}
    \item note the pattern
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumF a b
  | a > b     = 0
  | otherwise = f a + sumF (a + 1) b
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item how about sending the function as parameter?
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumFunc func a b
  | a > b     = 0
  | otherwise = func a + sumFunc func (a + 1) b

sumCubes a b = sumFunc cube a b
sumFacts a b = sumFunc fact a b
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{itemize}
    \item what is the type of \pygment{haskell}{sumFunc}?
  \end{itemize}

  \pause
  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumFunc :: (Integer -> Integer)
              -> Integer -> Integer -> Integer
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{exampleblock}{Python}
    \begin{pygments}{python}
def sum_func(func, a, b):
    total = 0
    while a <= b:
        total += func(a)
        a += 1
    return total

def cube(x):
    return x * x * x

def sum_cubes(a, b):
    return sum_func(cube, a, b)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{exampleblock}{C}
    \begin{pygments}{c}
int sum_func(int (*func)(int), int a, int b)
{
    int total = 0;
    while (a <= b) {
        total += func(a);
        a += 1;
    }
    return total;
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function as Parameter Example}

  \begin{exampleblock}{C}
    \begin{pygments}{c}
int cube(int x)
{
    return x * x * x;
}

int sum_cubes(int a, int b)
{
    return sum_func(cube, a, b);
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item in C, the \pygment{c}{qsort} function takes comparison function as parameter
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{c}
typedef struct {
    int num, denom;
} rational;

rational items[] = {{3, 2}, {1, 3}, {2, 1}};
qsort(items, 3, sizeof(rational), compare_rationals);
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{}
    \begin{pygments}{c}
int compare_rationals(const void *r1, const void *r2)
{
    int num1 = ((rational *) r1)->num;
    int denom1 = ((rational *) r1)->denom;
    int num2 = ((rational *) r2)->num;
    int denom2 = ((rational *) r2)->denom;

    if (num1 * denom2 > num2 * denom1)
        return 1;
    else if (num1 * denom2 < num2 * denom1)
        return -1;
    else
        return 0;
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item in Python, the \pygment{python}{sorted} function takes key function
      as parameter
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{python}
def second(p):
    return p[1]

def value(p):
    return p[0] / p[1]

pairs = [(3, 2), (1, 3), (2, 1)]
sorted(pairs)              # [(1, 3), (2, 1), (3, 2)]
sorted(pairs, key=second)  # [(2, 1), (3, 2), (1, 3)]
sorted(pairs, key=value)   # [(1, 3), (3, 2), (2, 1)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item parameterize the \pygment{haskell}{quickSort} function\\
      regarding the comparison function
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
quickSort :: (Integer -> Integer -> Bool)
                 -> [Integer] -> [Integer]
quickSort before [] = []
quickSort before (pivot:xs) =
    quickSort before [x | x <- xs, x `before` pivot]
    ++ [pivot]
    ++ quickSort before [x | x <- xs,
                             not (x `before` pivot)]
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: generalize the function regarding types
    \item how to use it with rational numbers?
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{Quicksort}
    \begin{pygments}{haskell}
quickSort :: (a -> a -> Bool) -> [a] -> [a]
quickSort before [] = []
quickSort before (pivot:xs) =
    quickSort before [x | x <- xs, x `before` pivot]
    ++ [pivot]
    ++ quickSort before [x | x <- xs,
                             not (x `before` pivot)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Higher Order Function Examples}

  \begin{itemize}

    \medskip
    \item exercise: parameterize the \pygment{haskell}{generateMatch} function\\
      in Rock - Paper - Scissors regarding both strategies
    \item exercise: parameterize the \pygment{haskell}{playInteractive} function\\
      in Rock - Paper - Scissors regarding the computer player strategy
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Rock - Paper - Scissors}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Strategy = [Move] -> Move

generateMatch :: Strategy -> Strategy
                     -> Integer -> Match
generateMatch _ _ 0 = ([], [])
generateMatch strategyA strategyB n =
    step (generateMatch strategyA strategyB (n - 1))
      where
        step :: Match -> Match
        step (movesA, movesB) =
            (strategyA movesB : movesA,
             strategyB movesA : movesB)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Anonymous Functions}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{itemize}
    \item no need to name small functions that are not used anywhere else\\
      $\rightarrow$ \alert{anonymous functions}
    \item anonymous functions can't be recursive
  \end{itemize}

  \pause
  \begin{block}{Haskell}
    \begin{pygments}{haskell}
      \fp1 fp2 ... -> e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}{}
    \begin{pygments}{haskell}
sumCubes :: Integer -> Integer -> Integer
sumCubes a b = sumFunc (\x -> x * x * x) a b
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{block}{Python}
    \begin{pygments}{python}
      lambda fp1, fp2, ...: e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}{}
    \begin{pygments}{python}
def sum_cubes(a, b):
    sum_func(lambda x: x * x * x, a, b)
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{python}
sorted(pairs, key=lambda p: p[1])
    \end{pygments}
  \end{example}
\end{frame}

\section{Higher Order List Functions}

\subsection{Mapping}

\begin{frame}[fragile]
  \frametitle{map}

  \begin{itemize}
    \item \pygment{haskell}{map}: apply a function to each element
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
map sqrt [16.0,9.0,121.0]     -- [4.0,3.0,11.0]

-- what is the type of map?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
map :: (a -> b) -> [a] -> [b]
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own version of map
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{map}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
map' f xs =
    case xs of
      [] -> []
      x:xs' -> f x : map' f xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{map}

  \begin{example}[Python]
    \begin{pygments}{python}
import math
map(math.sqrt, [16.0, 9.0, 121.0])
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Filtering}

\begin{frame}[fragile]
  \frametitle{filter}

  \begin{itemize}
    \item \pygment{haskell}{filter}: select elements that satisfy a predicate
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
filter odd [4,1,3,2]                    -- [1,3]
filter (\n -> n % 2 == 0) [4,1,3,2]     -- [4,2]

-- what is the type of filter?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own version of filter
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{filter}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
filter' f xs =
    case xs of
      [] -> []
      x:xs' -> if f x
               then x : filter' f xs'
               else filter' f xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{filter}

  \begin{example}[Python]
    \begin{pygments}{python}
def odd(n):
    return n % 2 == 1

filter(odd, [4, 1, 3, 2])
filter(lambda n: n % 2 == 0, [4, 1, 3, 2])
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Folding}

\begin{frame}[fragile]
  \frametitle{fold}

  \begin{itemize}
    \item fold: reduce a list to a value over a function
    \begin{itemize}
      \item left and right variants
    \end{itemize}

    \medskip
    \item \pygment{haskell}{foldl f acc [x1,x2,x3,x4]}:\\
      \pygment{haskell}{f(f(f(f(acc,x1),x2),x3),x4)}
    \item \pygment{haskell}{foldr f acc [x1,x2,x3,x4]}:\\
      \pygment{haskell}{f(x1,f(x2,f(x3,f(x4,acc))))}
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
foldl (\x y -> x + y) 0 [1,2,3,4]   -- 10
foldl (*) 1 [1..7]                  -- 5040
foldl (/) 1.0 [1.0,2.0,3.0]         -- 0.1666666
foldr (/) 1.0 [1.0,2.0,3.0]         -- 1.5
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
-- what are the types of foldl and foldr?
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
foldl :: (a -> b -> a) -> a -> [b] -> a
foldr :: (a -> b -> b) -> b -> [a] -> b
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write your own versions of foldl and foldr
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{fold}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
foldl' f acc xs =
    case xs of
      [] -> acc
      x:xs' -> foldl' f (f acc x) xs'

foldr' f acc xs =
    case xs of
      [] -> acc
      x:xs' -> foldr' f (f x acc) xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{fold Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that finds the maximum of a list using fold
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{fold Example}

  \begin{example}[maximum of a list]
    \begin{pygments}{haskell}
max' xs =
    case xs of
      [] -> error "empty list"
      x:xs' -> foldl' (\m n -> if m > n then m else n) x xs'
    \end{pygments}
  \end{example}
\end{frame}

\end{document}
