% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Higher Order Functions}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Higher Order Functions}

\subsection{Function Order}

\begin{frame}
  \frametitle{First Class Values}

  \begin{itemize}
    \item \alert{first class values} can be:
    \begin{itemize}
      \item assigned
      \item composed with other values
      \item passed as parameters
      \item returned as function results
    \end{itemize}

    \medskip
    \item in functional programming, functions are first class values
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Order}

  \begin{definition}
    \alert{first order functions}
    \begin{itemize}
      \item only accept data as parameter, and
      \item only return data as result
    \end{itemize}

    \bigskip
    \alert{higher order functions}
    \begin{itemize}
      \item take functions as parameters, or
      \item return functions as result
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}[fragile]
  \frametitle{First Order Function Examples}

  \begin{itemize}
    \item sum up the values of a function in a range
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- sqr :: Integer -> Integer
sumSqr :: Integer -> Integer -> Integer
sumSqr a b
  | a > b     = 0
  | otherwise = sqr a + sumSqr (a+1) b
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- fac :: Integer -> Integer
sumFac :: Integer -> Integer -> Integer
sumFac a b
  | a > b     = 0
  | otherwise = fac a + sumFac (a+1) b
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{itemize}
    \item note the pattern
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumFun a b
  | a > b     = 0
  | otherwise = fun a + sumFun (a+1) b
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item how about sending the function as parameter?
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumF f a b
  | a > b     = 0
  | otherwise = f a + sumF f (a+1) b

sumSqr a b = sumF sqr a b
sumFac a b = sumF fac a b
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{itemize}
    \item what is the type of \pygment{haskell}{sumF}?
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sumF :: (Integer -> Integer) -> Integer -> Integer
        -> Integer
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{exampleblock}{Python}
    \begin{pygments}{python}
def sum_f(f, a, b):
    total = 0
    while a <= b:
        total += f(a)
        a += 1
    return total

def sqr(x):
    return x * x

def sum_sqr(a, b):
    return sum_f(sqr, a, b)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{exampleblock}{C}
    \begin{pygments}{c}
int sum_f(int (*f)(int), int a, int b)
{
    int total = 0;
    while (a <= b) {
        total += f(a);
        a += 1;
    }
    return total;
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{exampleblock}{C}
    \begin{pygments}{c}
int sqr(int x)
{
    return x * x;
}

int sum_sqr(int a, int b)
{
    return sum_f(sqr, a, b);
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher Order Function Example}

  \begin{itemize}
    \item parameterize \pygment{haskell}{generateMatch} in Rock-Paper-Scissors\\
      regarding both strategies
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Strategy = [Move] -> Move

generateMatch :: Strategy -> Strategy -> Integer
                 -> Match
generateMatch _  _  0 = ([],[])
generateMatch sA sB n =
    step (generateMatch sA sB (n-1))
      where
        step :: Match -> Match
        step (movesA,movesB) = (sA movesB : movesA,
                                sB movesA : movesB)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Example: Sorting}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item in C, \pygment{c}{qsort} takes comparison function as parameter
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{c}
typedef struct {
    int num, denom;
} rational;

rational items[] = {{3, 2}, {1, 3}, {2, 1}};
qsort(items, 3, sizeof(rational), compare_rationals);
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{exampleblock}{}
    \begin{pygments}{c}
int compare_rationals(const void *r1, const void *r2)
{
    int num1 = ((rational *) r1)->num;
    int denom1 = ((rational *) r1)->denom;
    int num2 = ((rational *) r2)->num;
    int denom2 = ((rational *) r2)->denom;

    if (num1 * denom2 > num2 * denom1)
        return 1;
    else if (num1 * denom2 < num2 * denom1)
        return -1;
    else
        return 0;
}
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item in Python, \pygment{python}{sorted} takes key function as parameter
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{python}
def second(p):
    return p[1]

def value(p):
    return p[0] / p[1]

pairs = [(3, 2), (1, 3), (2, 1)]
sorted(pairs)              # [(1, 3), (2, 1), (3, 2)]
sorted(pairs, key=second)  # [(2, 1), (3, 2), (1, 3)]
sorted(pairs, key=value)   # [(1, 3), (3, 2), (2, 1)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorting}

  \begin{itemize}
    \item parameterize \pygment{haskell}{quickSort} regarding comparison
      function
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
quickSort :: (a -> a -> Bool) -> [a] -> [a]
quickSort before []         = []
quickSort before (pivot:xs) =
    quickSort before [x | x <- xs, x `before` pivot]
    ++ [pivot]
    ++ quickSort before [x | x <- xs,
                             not (x `before` pivot)]

quickSort (<=) [4,5,3]       -- [3,4,5]
quickSort (>)  [4,5,3]       -- [5,4,3]
quickSort (<=) ["b","a","c"] -- ["a","b","c"]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Anonymous Functions}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{itemize}
    \item no need to name small functions that are not used anywhere else\\
      $\rightarrow$ \alert{anonymous functions}
    \item anonymous functions can't be recursive
  \end{itemize}

  \pause
  \begin{block}{Haskell}
    \begin{pygments}{haskell}
      \fp1 fp2 ... -> e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}{}
    \begin{pygments}{haskell}
sumSqr :: Integer -> Integer -> Integer
sumSqr a b = sumF (\x -> x * x) a b
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Anonymous Functions}

  \begin{block}{Python}
    \begin{pygments}{python}
      lambda fp1, fp2, ...: e
    \end{pygments}
  \end{block}

  \medskip
  \begin{example}{}
    \begin{pygments}{python}
def sum_sqr(a, b):
    sum_func(lambda x: x * x, a, b)
    \end{pygments}

    \pause
    \bigskip
    \begin{pygments}{python}
sorted(pairs, key=lambda p: p[0] / p[1])
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Example: Fixed Points}

\begin{frame}
  \frametitle{Finding Fixed Points}

  \begin{itemize}
    \item $x$ is a \emph{fixed point} of $f$: $f(x)=x$
    \item repeatedly apply $f$ until value doesn't change:\\
      $x \rightarrow f(x) \rightarrow f(f(x)) \rightarrow f(f(f(x)))
      \rightarrow \ldots$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Finding Fixed Points}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fixedPoint :: (Float -> Float) -> Float -> Float
fixedPoint f firstGuess = fixedPointIter firstGuess
  where
    isCloseEnough :: Float -> Float -> Bool
    isCloseEnough x y = (abs (x - y) / x) < 0.001

    fixedPointIter :: Float -> Float
    fixedPointIter guess
      | isCloseEnough guess next = next
      | otherwise                = fixedPointIter next
      where next = f guess
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Square Roots}

  \begin{itemize}
    \item use the fixed point algorithm for computing square roots
    \item $y = \sqrt{x} \Rightarrow y * y = x \Rightarrow y = x / y$
    \item fixed point of the function $f(y) = x / y$
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sqrt :: Float -> Float
sqrt x = fixedPoint (\y -> x / y) 1.0
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item this doesn't converge (try with $y = 2$)
    \item average successive values (average damping)
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
sqrt x = fixedPoint (\y -> (y + x / y) / 2.0) 1.0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section{List Operations}

\subsection{Map}

\begin{frame}[fragile]
  \frametitle{Map}

  \begin{itemize}
    \item transform all elements of a list
  \end{itemize}

  \begin{exampleblock}{floors of all elements of a list}
    \begin{pygments}{haskell}
-- [5.7,9.0,2.3] -> [5,9,2]
floorAll :: [Float] -> [Integer]

-- primitive recursive
floorAll []     = []
floorAll (x:xs) = floor x : floorAll xs

-- list comprehension
floorAll xs = [floor x | x <- xs]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map}

  \begin{itemize}
    \item \pygment{haskell}{map}: apply a function to all elements of a list
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- primitive recursive
map f []     = []
map f (x:xs) = f x : map f xs

-- list comprehension
map f xs = [f x | x <- xs]
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \pygment{haskell}{map}?
  \end{itemize}

  \begin{pygments}{haskell}
map :: (a -> b) -> [a] -> [b]
  \end{pygments}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map}

  \begin{exampleblock}{floors of all elements of a list}
    \begin{pygments}{haskell}
floorAll :: [Float] -> [Integer]
floorAll xs = map floor xs
    \end{pygments}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{pygments}{python}
import math

map(math.floor, [5.7, 9.0, 2.3])
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Map Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
replicate :: Integer -> a -> [a]
replicate n i = map (\_ -> i) [1..n]
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item zip two lists over a function\\
      \pygment{haskell}{zipWith (+) [1,2] [10,12]} $\rightsquigarrow$
      \pygment{haskell}{[11,14]}\\
      \pygment{haskell}{zipWith replicate [3,2] ['a','b']} $\rightsquigarrow$
      \pygment{haskell}{["aaa", "bb"]}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f xs ys = map (\\(x,y) -> f x y) (zip xs ys)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Filter}

\begin{frame}[fragile]
  \frametitle{Filter}

  \begin{itemize}
    \item select all the elements of a list with a given property
  \end{itemize}

  \begin{exampleblock}{all odd elements of a list}
    \begin{pygments}{haskell}
-- [4,1,3,2] -> [1,3]
allOdds :: [Integer] -> [Integer]

-- primitive recursive
allOdds []     = []
allOdds (x:xs)
  | odd x      = x : allOdds xs
  | otherwise  = allOdds xs

-- list comprehension
allOdds xs = [x | x <- xs, odd x]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Filter}

  \begin{itemize}
    \item \pygment{haskell}{filter}: select elements that satisfy a predicate
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- primitive recursive
filter f []     = []
filter f (x:xs)
  | f x       = x : filter f xs
  | otherwise = filter f xs

-- list comprehension
filter f xs = [x | x <- xs, f x]
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \pygment{haskell}{filter}?
  \end{itemize}

  \begin{pygments}{haskell}
filter :: (a -> Bool) -> [a] -> [a]
  \end{pygments}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Filter}

  \begin{exampleblock}{all odd elements of a list}
    \begin{pygments}{haskell}
allOdds :: [Integer] -> [Integer]
allOdds xs = filter odd xs
    \end{pygments}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{pygments}{python}
def odd(n):
    return n % 2 == 1

filter(odd, [4, 1, 3, 2])
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Splitting Lists}

  \begin{itemize}
    \item take elements from the front of a list while a predicate is true\\
      \pygment{haskell}{takeWhile even [8,2,4,5,6]} $\rightsquigarrow$
      \pygment{haskell}{[8,2,4]}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile p []     = []
takeWhile p (x:xs)
  | p x       = x : takeWhile p xs
  | otherwise = []
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: drop elements from the front of a list\\
      while a predicate is true\\
      \pygment{haskell}{dropWhile even [8,2,4,5,6]} $\rightsquigarrow$
      \pygment{haskell}{[5,6]}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Example}

  \begin{exampleblock}{how many elements in a list are above a threshold?}
    \begin{pygments}{haskell}
howManyAbove :: Float -> [Float] -> Integer
howManyAbove t xs = length (filter (\x -> x > t) xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Fold}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{itemize}
    \item reduce the elements of a list to a single value
  \end{itemize}

  \begin{exampleblock}{sum all elements of a list}
    \begin{pygments}{haskell}
-- [2,8,5] -> 15
sum :: [Integer] -> Integer
sum [x]    = x
sum (x:xs) = x + sum xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{itemize}
    \item \pygment{haskell}{foldr1}: reduce a list to a value over a function
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
foldr1 f [x]    = x
foldr1 f (x:xs) = x `f` (foldr1 f xs)

-- OR:
foldr1 f [x]    = x
foldr1 f (x:xs) = f x (foldr1 f xs)
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \pygment{haskell}{foldr1}?
  \end{itemize}

  \begin{pygments}{haskell}
foldr1 :: (a -> a -> a) -> [a] -> a
  \end{pygments}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Expansion}

  \begin{block}{}
    \begin{pygments}{haskell}
foldr1 f [e1, e2, ..., ej, ek]
    = e1 `f` (e2 `f` (... (ej `f` ek)...)
    = e1 `f` (foldr1 f [e2, ..., ej, ek])
    = f e1 (foldr1 f [e2, ..., ej, ek])
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold}

  \begin{exampleblock}{sum all elements of a list}
    \begin{pygments}{haskell}
sum :: [Integer] -> Integer
sum xs = foldr1 (+) xs
    \end{pygments}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{pygments}{python}
import functools

def sum(xs):
  return functools.reduce(lambda x, y: x + y, xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{itemize}
    \item \pygment{haskell}{foldr1} doesn't work on empty lists
    \item add a parameter as initial value for empty list:
      \pygment{haskell}{foldr}
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
foldr f s [e1, e2, ..., ej, ek]
    = e1 `f` (e2 `f` (... (ej `f` (ek `f` s))...)
    = e1 `f` (foldr f s [e2, ..., ej, ek])
    = f e1 (foldr f s [e2, ..., ej, ek])
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
foldr f s []     = s
foldr f s (x:xs) = f x (foldr f s xs)
    \end{pygments}

    \pause
    \begin{itemize}
      \item what is the type of \pygment{haskell}{foldr}?
    \end{itemize}

    \begin{pygments}{haskell}
foldr :: (a -> b -> b) -> b -> [a] -> b
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold with Initial Value}

  \begin{exampleblock}{sum all elements of a list}
    \begin{pygments}{haskell}
sum :: [Integer] -> Integer
sum xs = foldr (+) 0 xs
    \end{pygments}
  \end{exampleblock}

  \bigskip
  \begin{exampleblock}{Python}
    \begin{pygments}{python}
import functools

def sum(xs):
  return functools.reduce(lambda x, y: x + y, xs, 0)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
product :: [Integer] -> Integer
product xs = foldr (*) 1 xs

fac :: [Integer] -> Integer
fac n = foldr (*) 1 [1..n]

and :: [Bool] -> Bool
and xs = foldr (&&) True xs

concat :: [[a]] -> [a]
concat xs = foldr (++) [] xs

maxList :: [Integer] -> Integer
maxList xs = foldr1 max xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Example}

  \begin{exampleblock}{how many elements in a list are above a threshold?}
    \begin{pygments}{haskell}
howManyAbove :: Float -> [Float] -> Integer
howManyAbove t xs =
    foldr (\x n -> if x > t then n+1 else n) 0 xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Example}

  \begin{exampleblock}{insertion sort}
    \begin{pygments}{haskell}
ins :: Integer -> [Integer] -> [Integer]
ins i []      = [i]
ins i (x:xs)
  | i <= x    = i : x : xs
  | otherwise = x : ins i xs

iSort :: [Integer] -> [Integer]
iSort []     = []
iSort (x:xs) = ins x (iSort xs)

-- equivalent to:
iSort :: [Integer] -> [Integer]
iSort (x:xs) = foldr ins [] xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Left}

  \begin{block}{}
    \begin{pygments}{haskell}
foldl f s [e1, e2, ..., ej, ek]
    = (...((s `f` e1) `f` e2) `f` ... ej) `f` ek
    = foldl f (s `f` e1) [e2, ..., ej, ek]
    = foldl f (f s e1) [e2, ..., ej, ek]
    \end{pygments}
  \end{block}

  \pause
  \begin{exampleblock}{}
    \begin{pygments}{haskell}
foldl f s []     = s
foldl f s (x:xs) = foldl f (f s x) xs
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what is the type of \pygment{haskell}{foldl}?
  \end{itemize}

  \begin{pygments}{haskell}
foldl :: (a -> b -> a) -> a -> [b] -> a
  \end{pygments}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fold Left}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
foldl (*) 1 [1..7]           -- 5040
foldl (/) 1.0 [1.0,2.0,3.0]  -- 0.1666666
foldr (/) 1.0 [1.0,2.0,3.0]  -- 1.5
    \end{pygments}
  \end{exampleblock}
\end{frame}

% TODO: edit distance

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 10: \alert{Generalization: patterns of computation}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
