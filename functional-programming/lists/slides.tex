% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Lists}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{List Expressions}

\subsection{Strings}

\begin{frame}[fragile]
  \frametitle{Strings}

  \begin{itemize}
    \item a string is a list of characters
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type String = [Char]

head "abc"    -- 'a'
tail "abc"    -- "bc"
null "abc"    -- False
null ""       -- True
length "abc"  -- 3
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{List Operators}

\begin{frame}[fragile]
  \frametitle{List Indexing}

  \begin{itemize}
    \item Haskell operator: \pygment{haskell}{!!}
  \end{itemize}

  \begin{exampleblock}{get the nth element of a list}
    \begin{pygments}{haskell}
getNth :: [a] -> Int -> a
getNth xs n
  | null xs   = error "empty list"
  | n == 0    = head xs
  | otherwise = getNth (tail xs) (n - 1)

-- OR:
getNth []     _ = error "empty list"
getNth (x:xs) 0 = x
getNth (x:xs) n = getNth xs (n - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Appending Lists}

  \begin{itemize}
    \item Haskell operator: \pygment{haskell}{++}
  \end{itemize}

  \begin{exampleblock}{append two lists}
    \begin{pygments}{haskell}
append :: [a] -> [a] -> [a]
append xs ys =
    case xs of
      []    -> ys
      x:xs' -> x : append xs' ys

-- OR:
append []     ys = ys
append (x:xs) ys = x : append xs ys
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Range Expressions}

  \begin{itemize}
    \item \pygment{haskell}{[n .. m]}: range with increment 1
    \item \pygment{haskell}{[n, p .. m]}: range with increment \texttt{p - n}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
[2 .. 7]           -- [2,3,4,5,6,7]
[3.1 .. 7.0]       -- [3.1,4.1,5.1,6.1,7.1]
['a' .. 'm']       -- "abcdefghijklm"

[7,6 .. 3]         -- [7,6,5,4,3]
[0.0, 0.3 .. 1.0]  -- [0.0,0.3,0.6,0.8999999999999999]
['a', 'c' .. 'n']  -- "acegikm"
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constructing Ranges}

  \begin{exampleblock}{construct a list from a lower limit to an upper limit}
    \begin{pygments}{haskell}
countUp :: Integer -> Integer -> [Integer]
countUp lower upper
  | lower > upper = []
  | otherwise     = lower : countUp (lower + 1) upper
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item write a tail recursive \pygment{haskell}{countDown}
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Range Construction Example}

  \begin{footnotesize}
  \begin{exampleblock}{construct a list from an upper limit to a lower limit}
    \begin{pygments}{haskell}
countDown :: Integer -> Integer -> [Integer]
countDown upper lower = countDownIter [] upper lower
  where
    countDownIter :: [Integer] -> Integer -> Integer -> [Integer]
    countDownIter acc upper' lower'
      | upper' < lower' = acc
      | otherwise       = countDownIter (acc ++ [upper'])
                                        (upper' - 1) lower'
    \end{pygments}
  \end{exampleblock}
  \end{footnotesize}

  \pause
  \begin{itemize}
    \item can any of the parameters be removed?
  \end{itemize}
\end{frame}

\subsection{List Comprehension}

\begin{frame}[fragile]
  \frametitle{List Comprehension}

  \begin{itemize}
    \item describe a list in terms of the elements of another list
    \item generate, test, transform
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
[2 * n | n <- [2, 4, 7]]  -- [4, 8, 14]
[even n | n <- [2, 4, 7]] -- [True, True, False]
[2 * n | n <- [2, 4, 7], even n, n > 3]  -- [8]

[m + n | (m, n) <- [(2, 3), (2, 1), (7, 8)]]
-- [5, 3, 15]

[(x, y, z) | x <- [1 .. 5],
             y <- [1 .. 5],
             z <- [1 .. 5],
             x * x + y * y == z * z]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension}

  \begin{exampleblock}{Python}
    \begin{pygments}{python}
[2 * n for n in [2, 4, 7]]
[even(n) for n in [2, 4, 7]]
[2 * n for n in [2, 4, 7] if even(n) and (n > 3)]
[m + n for (m, n) in [(2, 3), (2, 1), (7, 8)]]
[(x, y, z) for x in range(1, 6)
           for y in range(1, 6)
           for z in range(1, 6)
           if x * x + y * y == z * z]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Comprehension Example}

  \begin{exampleblock}{Quicksort}
    \begin{pygments}{haskell}
quickSort :: [Integer] -> [Integer]
quickSort []         = []
quickSort (pivot:xs) =
    quickSort [x | x <- xs, x <= pivot]
    ++ [pivot]
    ++ quickSort [x | x <- xs, x > pivot]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section{List Functions}

\subsection{Prelude Functions}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item check whether an element is in a list\\
      \pygment{haskell}{elem 'r' "word"} $\rightsquigarrow$
      \pygment{haskell}{True}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
elem' :: Char -> [Char] -> Bool
elem' _ [] = False
elem' x (c:cs) = if x == c then True else elem' x cs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item last element of a list\\
      \pygment{haskell}{last "word"} $\rightsquigarrow$
      \pygment{haskell}{'d'}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
last' :: [a] -> a
last' []     = error "empty list"
last' [x]    = x
last' (x:xs) = last' xs
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: write a function that will give all elements\\
      but the last of a list\\
      \pygment{haskell}{init "word"} $\rightsquigarrow$
      \pygment{haskell}{"wor"}
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Prelude Functions}

  \begin{exampleblock}{all elements but the last of a list}
    \begin{pygments}{haskell}
init' :: [a] -> [a]
init' []     = error "empty list"
init' [x]    = []
init' (x:xs) = x : init' xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item exercise: make a list of n copies of an item\\
      \pygment{haskell}{replicate 3 'c'} $\rightsquigarrow$
      \pygment{haskell}{"ccc"}
    \item exercise: take n elements from the front of a list\\
      \pygment{haskell}{take 3 "Peccary"} $\rightsquigarrow$
      \pygment{haskell}{"Pec"}
    \item exercise: drop n elements from the front of a list\\
      \pygment{haskell}{drop 3 "Peccary"} $\rightsquigarrow$
      \pygment{haskell}{"cary"}
    \item exercise: split a list at a given position\\
      \pygment{haskell}{splitAt 3 "Peccary"} $\rightsquigarrow$
      \pygment{haskell}{("Pec", "cary")}
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Prelude Functions}

  \begin{exampleblock}{make a list of n copies of an item}
    \begin{pygments}{haskell}
replicate' :: Int -> a -> [a]
replicate' 0 _ = []
replicate' n x = x : replicate' (n - 1) x
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Prelude Functions}

  \begin{exampleblock}{split a list at a given position}
    \begin{pygments}{haskell}
splitAt' :: Int -> [a] -> ([a], [a])
splitAt' n xs = (take' n xs, drop' n xs)
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: write a tail recursive version that works in one pass
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item reverse a list\\
      \pygment{haskell}{reverse "word"} $\rightsquigarrow$
      \pygment{haskell}{"drow"}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
reverse' :: [a] -> [a]
reverse' []     = []
reverse' (x:xs) = (reverse' xs) ++ [x]
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: write a tail recursive function that will reverse a list
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Prelude Functions}

  \begin{exampleblock}{reverse a list (tail recursive)}
    \begin{pygments}{haskell}
reverse'' :: [a] -> [a]
reverse'' xs = reverseIter [] xs
  where
    reverseIter :: [a] -> [a] -> [a]
    reverseIter acc []      = acc
    reverseIter acc (x:xs') = reverseIter (x : acc) xs'
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item convert a list of lists into a list\\
      \pygment{haskell}{concat [[2, 3], [], [4]} $\rightsquigarrow$
      \pygment{haskell}{[2, 3, 4]}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
concat' :: [[a]] -> [a]
concat' []     = []
concat' (x:xs) = x ++ concat' xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item convert two lists into a list of pairs\\
      \pygment{haskell}{zip [1, 2] ['a', 'b']} $\rightsquigarrow$
      \pygment{haskell}{[(1, 'a'), (2, 'b')]}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
zip' :: [a] -> [b] -> [(a, b)]
zip' []     []     = []
zip' (x:xs) (y:ys) = (x, y) : zip' xs ys
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what if called as given below?\\
      \pygment{haskell}{zip' [1, 2] ['a', 'b', 'c']}
    \item result should be: \pygment{haskell}{[(1, 'a'), (2, 'b')]}
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Prelude Functions}

  \begin{exampleblock}{convert two lists into a list of pairs}
    \begin{pygments}{haskell}
zip'' :: [a] -> [b] -> [(a, b)]
zip'' (x:xs) (y:ys) = (x, y) : zip'' xs ys
zip'' _      _      = []
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prelude Functions}

  \begin{itemize}
    \item convert a list of pairs into a pair of lists\\
      \pygment{haskell}{unzip [(1, 3), (2, 4)]} $\rightsquigarrow$
      \pygment{haskell}{([1, 2], [3, 4])}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
unzip' :: [(a, b)] -> ([a], [b])
unzip' []           = ([], [])
unzip' ((x, y):xys) = (x : xs, y : ys)
  where
    (xs, ys) = unzip' xys
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Examples}

\begin{frame}[fragile]
  \frametitle{List Maximum}

  \begin{exampleblock}{maximum of a list}
    \begin{pygments}{haskell}
maxList :: [Integer] -> Integer
maxList []     = error "empty list"
maxList [x]    = x
maxList (x:xs)
  | x > maxList xs = x
  | otherwise      = maxList xs
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item what if called as given below?\\
      \pygment{haskell}{maxList [30, 29 .. 1]}\\
      \pygment{haskell}{maxList [1 .. 30]}
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Maximum}

  \begin{exampleblock}{maximum of a list}
    \begin{pygments}{haskell}
maxList' :: [Integer] -> Integer
maxList' []     = error "empty list"
maxList' [x]    = x
maxList' (x:xs)
  | x > maxTail = x
  | otherwise   = maxTail
  where
    maxTail :: Integer
    maxTail = maxList' xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Order}

  \begin{exampleblock}{check whether a list is nondecreasing}
    \begin{pygments}{haskell}
nondecreasing :: [Integer] -> Bool
nondecreasing []         = True
nondecreasing [_]        = True
nondecreasing (x1:x2:xs) =
    x1 <= x2 && nondecreasing (x2 : xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Merging Lists}

  \begin{exampleblock}{merge two ordered lists}
    \begin{pygments}{haskell}
merge :: [Integer] -> [Integer] -> [Integer]
merge xs     []     = xs
merge []     ys     = ys
merge (x:xs) (y:ys)
  | x <= y    = x : merge xs (y : ys)
  | otherwise = y : merge (x : xs) ys
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Merging Lists}

  \begin{exampleblock}{merge two ordered lists}
    \begin{pygments}{haskell}
merge' :: [Integer] -> [Integer] -> [Integer]
merge' xs ys =
    case (xs, ys) of
      (_,     [])    -> xs
      ([],    _)     -> ys
      (x:xs', y:ys') -> if x <= y
                            then x : merge' xs' ys
                            else y : merge' xs ys'
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 6: \alert{Programming with lists}
      \item Chapter 7: \alert{Defining functions over lists}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
