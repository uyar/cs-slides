% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Functions and Recursion}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Functions}

\subsection{Infix and Prefix}

\begin{frame}[fragile]
  \frametitle{Infix Functions}

  \begin{itemize}
    \item function calls can be written in infix notation within backquotes
  \end{itemize}

  \begin{exampleblock}{example: the \pygment{haskell}{mod} function}
    \begin{pygments}{haskell}
even1a :: Integer -> Bool
even1a n = mod n 2 == 0

even1b :: Integer -> Bool
even1b n = n `mod` 2 == 0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prefix Operators}

  \begin{itemize}
    \item operator calls can be written in prefix notation within parentheses
  \end{itemize}

  \begin{exampleblock}{example: the \pygment{haskell}{/} operator}
    \begin{pygments}{haskell}
even2a :: Integer -> Bool
even2a n = (floor ((fromInteger n) / 2)) * 2 == n

even2b :: Integer -> Bool
even2b n = (floor ((/) (fromInteger n) 2)) * 2 == n

-- also prefix the * and == operators
even2c :: Integer -> Bool
even2c n =
    (==) ((*) (floor ((/) (fromInteger n) 2)) 2) n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Guards}

\begin{frame}[fragile]
  \frametitle{Guards}

  \begin{itemize}
    \item writing conditional expressions can become complicated
    \item \alert{guards}: Boolean expressions to check cases
      in function definitions
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
name x1 x2 ... xk
  | g1        = e1
  | g2        = e2
    ...
  | otherwise = e
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guard Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
maxThree :: Integer -> Integer -> Integer -> Integer
maxThree x y z
  | x >= y && x >= z = x
  | y >= z           = y
  | otherwise        = z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Errors}

\begin{frame}[fragile]
  \frametitle{Errors}

  \begin{itemize}
    \item an exception can be raised using \pygment{haskell}{error}
  \end{itemize}

  \begin{example}[factorial]
    \begin{pygments}{haskell}
fact n =
    if n < 0
    then error "negative parameter"
    else if n == 0
         then 1
         else n * fact (n - 1)
    \end{pygments}
  \end{example}
\end{frame}

\section{Recursion}

\subsection{Primitive Recursion}

\begin{frame}[fragile]
  \frametitle{Recursion Examples}

  \begin{itemize}
    \item consider two classic examples
  \end{itemize}

  \begin{exampleblock}{greatest common divisor}
    \begin{pygments}{haskell}
gcd' :: Integer -> Integer -> Integer
gcd' x y = if y == 0 then x else gcd' y (x `mod` y)
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{factorial}
    \begin{pygments}{haskell}
fact :: Integer -> Integer
fact n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fact (n - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd' :: Integer -> Integer -> Integer
gcd' x y = if y == 0 then x else gcd' y (x `mod` y)
    \end{pygments}

    \pause
    \begin{verbatim}
gcd' 9702 945
|- gcd' 945 252
   |- gcd' 252 189
      |- gcd' 189 63
         |- gcd' 63 0
            63
         63
      63
   63
63
    \end{verbatim}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fact :: Integer -> Integer
fact n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fact (n - 1)
    \end{pygments}

    \begin{verbatim}
fact 4
|- 4 * fact 3
       |- 3 * fact 2
              |- 2 * fact 1
                     |- 1 * fact 0
                            1
                     1
              2
       6
24
    \end{verbatim}
  \end{exampleblock}
\end{frame}

\subsection{Tail Recursion}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item if the result of the recursive call is also the result of the caller,\\
      then the function is said to be \alert{tail recursive}
    \item the recursive function call is the last action:\\
      nothing left for the caller to do

    \pause
    \medskip
    \item no need to keep the stack frame around\\
      $\rightarrow$ reuse the frame of the caller
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd' :: Integer -> Integer -> Integer
gcd' x y = if y == 0 then x else gcd' y (x `mod` y)
    \end{pygments}

    \begin{verbatim}
gcd' 9702 945
gcd' 945 252
gcd' 252 189
gcd' 189 63
gcd' 63 0
63
    \end{verbatim}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item to rearrange a function to be tail recursive:

    \medskip
    \item define a helper function that takes an \alert{accumulator}
    \item base case: return accumulator
    \item recursive case: make recursive call with new accumulator value
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
factIter :: Integer -> Integer -> Integer
factIter acc x =
    if x == 0
        then acc
        else factIter (acc * x) (x - 1)

fact' :: Integer -> Integer
fact' n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = factIter 1 n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
factIter :: Integer -> Integer -> Integer
factIter acc x =
    if x == 0
        then acc
        else factIter (acc * x) (x - 1)
    \end{pygments}

    \begin{verbatim}
fact 4
|- factIter 1 4
|- factIter 4 3
|- factIter 12 2
|- factIter 24 1
|- factIter 24 0
   24
24
    \end{verbatim}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fact' :: Integer -> Integer
fact' n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = factIter 1 n
      where
        factIter :: Integer -> Integer -> Integer
        factIter acc x =
            if x == 0
                then acc
                else factIter (acc * x) (x - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Tree Recursion}

\begin{frame}[fragile]
  \frametitle{Tree Recursion}

  \begin{itemize}
    \item another classic example: the Fibonacci sequence
    \begin{equation*}
      f_n = \left\{
        \begin{array}{ll}
          1                 & n = 1 \vee n = 2\\
          f_{n-2} + f_{n-1} & n > 2
        \end{array}\right.
    \end{equation*}
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fib :: Integer -> Integer
fib n
  | (n == 1) || (n == 2) = 1
  | otherwise            = fib (n - 2) + fib (n - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{verbatim}
               fib 5
                 |
         ------------------
         |                |
       fib 3            fib 4
         |                |
  -------------      -------------
  |           |      |           |
fib 1       fib 2  fib 2       fib 3
                                 |
                           -------------
                           |           |
                         fib 1       fib 2
  \end{verbatim}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 3: \alert{Basic types and definitions}
      \item Chapter 4: \alert{Designing and writing programs}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
