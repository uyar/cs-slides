% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Functions and Recursion}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{tiny}
    You are free to:
    \begin{itemize}
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.\\
        You may do so in any reasonable manner, but not in any way
        that suggests the licensor endorses you or your use.

      \item Noncommercial -- You may not use the material for commercial
        purposes.

      \item Share Alike -- If you remix, transform, or build upon the material,
        you must distribute your contributions\\
        under the same license as the original.
    \end{itemize}
  \end{tiny}

  \vfill
  \begin{small}
    Legal code (the full license):\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Functions}

\subsection{Function Definition}

\begin{frame}[fragile]
  \frametitle{Function Definitions}

  \begin{itemize}
    \item functions can be called in infix form within backquotes
    \item operators can be called in prefix form within parentheses
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
even1a :: Integer -> Bool
even1a n = n `mod` 2 == 0

even1b :: Integer -> Bool
even1b n = mod n 2 == 0

even2a :: Integer -> Bool
even2a n = (floor ((fromInteger n) / 2)) * 2 == n

even2b :: Integer -> Bool
even2b n = (floor ((/) (fromInteger n) 2)) * 2 == n

even2c :: Integer -> Bool
even2c n =
    (==) ((*) (floor ((/) (fromInteger n) 2)) 2) n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Guards}

\begin{frame}[fragile]
  \frametitle{Guards}

  \begin{itemize}
    \item \alert{guards}: Boolean expressions to check cases
      in function definitions
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
name x1 x2 ... xk
  | g1        = e1
  | g2        = e2
    ...
  | otherwise = e
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guard Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
maxThree :: Integer -> Integer -> Integer -> Integer
maxThree x y z
  | x >= y && x >= z    = x
  | y >= z              = y
  | otherwise           = z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Errors}

\begin{frame}[fragile]
  \frametitle{Errors}

  \begin{block}{Haskell}
    \begin{itemize}
      \item an exception can be raised using \pygment{haskell}{error}
    \end{itemize}
  \end{block}

  \begin{example}[factorial]
    \begin{pygments}{haskell}
fact n =
    if n < 0
    then error "negative parameter"
    else if n == 0
         then 1
         else n * fact (n - 1)
    \end{pygments}
  \end{example}
\end{frame}

\section{Recursion}

\subsection{Primitive Recursion}

\begin{frame}[fragile]
  \frametitle{Recursion Examples}

  \begin{itemize}
    \item consider two classic examples
  \end{itemize}

  \begin{example}[factorial]
    \begin{pygments}{haskell}
fact n =
    if n == 0
    then 1
    else n * fact (n - 1)
    \end{pygments}
  \end{example}

  \begin{example}[greatest common divisor]
    \begin{pygments}{haskell}
gcd' x y =
    if y == 0
    then x
    else gcd' y (x `mod` y)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{example}[fact]
    \begin{pygments}{haskell}
fact n =
    if n == 0 then 1
    else n * fact (n - 1)
    \end{pygments}

    \pause
    \begin{verbatim}
fact 4
|- 4 * fact 3
       |- 3 * fact 2
              |- 2 * fact 1
                     |- 1 * fact 0
                            1
                     1
              2
       6
24
    \end{verbatim}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{example}[gcd']
    \begin{pygments}{haskell}
gcd' x y =
    if y == 0 then x
    else gcd' y (x `mod` y)
    \end{pygments}

    \pause
    \begin{verbatim}
gcd_ 9702 945
|- gcd_ 945 252
   |- gcd_ 252 189
      |- gcd_ 189 63
         |- gcd_ 63 0
         63
      63
   63
63
    \end{verbatim}
  \end{example}
\end{frame}

\subsection{Tail Recursion}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item if the result of the recursive call is also the result of the caller\\
      the function is said to be \alert{tail recursive}
    \item the recursive function call is the last action:\\
      nothing left for the caller to do

    \pause
    \medskip
    \item no need to keep the stack frame around\\
      $\rightarrow$ reuse the frame of the caller

    \pause
    \medskip
    \item to rearrange a function to be tail recursive
    \begin{itemize}
      \item define a helper function that takes an \alert{accumulator}
      \item base case: return accumulator
      \item recursive case: make recursive call with new accumulator value
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{example}[factorial]
    \begin{pygments}{haskell}
factIter acc x =
    if x == 0
    then acc
    else factIter (acc * x) (x - 1)

fact n = factIter 1 n
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{example}[fact - tail recursive]
    \begin{pygments}{haskell}
factIter acc x =
    if x == 0 then acc
    else factIter (acc * x) (x - 1)
    \end{pygments}

    \pause
    \begin{verbatim}
fact 4
|- factIter 1 4
|- factIter 4 3
|- factIter 12 2
|- factIter 24 1
|- factIter 24 0
24
    \end{verbatim}
  \end{example}
\end{frame}

\subsection{Nested Functions}

\begin{frame}
  \frametitle{Nested Functions}

  \begin{itemize}
    \item functions can be defined locally within other functions
    \item they can use bindings from the environment\\
      in which they are defined
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nested Function Example}

  \begin{example}[factorial]
    \begin{itemize}
      \item no need for \pygment{haskell}{factIter} to be visible
        outside of \pygment{haskell}{fact}
    \end{itemize}

    \begin{pygments}{haskell}
fact n =
    let
        factIter acc x =
            if x == 0
            then acc
            else factIter (acc * x) (x - 1)
    in
        factIter 1 n
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what is the type of \pygment{haskell}{fact}?
      \item what happens if called as \pygment{haskell}{fact 2.4}?
      \item what if \pygment{haskell}{factIter :: Integer -> Integer -> Integer}?
    \end{itemize}
  \end{block}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 3: Basic types and definitions
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
