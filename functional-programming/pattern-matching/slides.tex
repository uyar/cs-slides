% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Pattern Matching}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Pattern Matching}

\subsection{Guards}

\begin{frame}[fragile]
  \frametitle{Guards}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
f fp1 fp2 ...
  | g1 = e1
  | g2 = e2
  | ...
  | gn = en
  | otherwise = eo
    \end{pygments}
  \end{block}

  \begin{itemize}
    \item \alert{guard}: check before evaluating expression
    \item function result is the expression for the first valid guard
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guards Example}

  \begin{example}[factorial]
    \begin{pygments}{haskell}
fact n
  | n < 0 = error "negative parameter"
  | n == 0 = 1
  | otherwise = n * fact (n - 1)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guards Example}

  \begin{example}[maximum of a list]
    \pause
    \begin{pygments}{haskell}
max' xs
  | null xs = error "empty list"
  | null (tail xs) = head xs
  | head xs > max' (tail xs) = head xs
  | otherwise = max' (tail xs)
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Patterns}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
case e of
  p1 -> e1
  p2 -> e2
  ...
  pn -> en
  _ -> eo
    \end{pygments}
  \end{block}

  \begin{itemize}
    \item \alert{pattern}: check the shape of an expression
    \item expression result is the expression for the first valid pattern
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern Example}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
fact n =
    case n of
      0 -> 1
      _ -> n * fact (n - 1)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{block}{Scala}
    \begin{pygments}{scala}
e match {
    case p1 => e1
    case p2 => e2
    ...
    case pn => en
    _ => eo
}
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern Example}

  \begin{example}[Scala]
    \begin{pygments}{haskell}
def fact(n: Int): Int =
    n match {
        case 0 => 1
        case _ => n * fact(n - 1)
    }
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern Bindings}

  \begin{itemize}
    \item a matched pattern generates bindings
    \item if binding not needed, use wildcard: \pygment{haskell}{_}
  \end{itemize}

  \pause
  \begin{example}[third component of a triple]
    \begin{pygments}{haskell}
third t =
    case t of
      (x,y,z) -> z
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
-- BETTER:
third t =
    case t of
      (_,_,z) -> z
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Patterns in Haskell}

  \begin{itemize}
    \item empty list: \pygment{haskell}{[]}
    \item nonempty list: \pygment{haskell}{x:xs}
    \item list with exactly one element: \pygment{haskell}{[x]} or
      \pygment{haskell}{x:[]}
    \item list with exactly two elements: \pygment{haskell}{[x1,x2]} or
      \pygment{haskell}{x1:x2:[]}
    \item list with at least two elements: \pygment{haskell}{x1:x2:xs}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples in Haskell}

  \begin{example}[sum of a list]
    \begin{pygments}{haskell}
sum' xs =
    case xs of
      [] -> 0
      x:xs' -> x + sum' xs'
    \end{pygments}
  \end{example}

  \pause
  \begin{example}[maximum of a list]
    \begin{pygments}{haskell}
max' xs =
    case xs of
      [] -> error "empty list"
      [i] -> i
      x:xs' -> if x > max' xs' then x else max' xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples in Haskell}

  \begin{example}[add the first and third elements of a list]
    \pause
    \begin{pygments}{haskell}
firstPlusThird xs =
    case xs of
      [] -> 0
      [x1] -> x1
      [x1,_] -> x1
      x1:_:x3:_ -> x1 + x3
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Patterns in Scala}

  \begin{itemize}
    \item empty list: \pygment{scala}{List()}
    \item nonempty list: \pygment{scala}{x::xs}
    \item list with exactly one element: \pygment{scala}{List(x)}
    \item list with exactly two elements: \pygment{scala}{List(x1, x2)}
    \item list with at least two elements: \pygment{scala}{x1::x2::xs}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples in Scala}

  \begin{example}[sum of a list]
    \begin{pygments}{scala}
def sum(xs: List[Int]): Int =
    xs match {
        case List() => 0
        case y::ys => y + sum(ys)
    }
    \end{pygments}
  \end{example}

  \pause
  \begin{example}[maximum of a list]
    \begin{pygments}{scala}
def max(xs: List[Int]): Int =
    xs match {
        case List() => throw ...
        case List(i) => i
        case y::ys => if (y > max(ys)) y else max(ys)
    }
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples in Scala}

  \begin{example}[add the first and third elements of a list]
    \begin{pygments}{haskell}
def firstPlusThird(xs: List[Int]): Int =
    xs match {
        case List() => 0
        case List(x1) => x1
        case List(x1, _) => x1
        case x1::_::x3::_ => x1 + x3
    }
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Multiple Patterns}

\begin{frame}[fragile]
  \frametitle{Multiple Patterns}

  \begin{itemize}
    \item expressions can be matched over multiple patterns
  \end{itemize}

  \begin{example}[convert three lists into a list of triples]
    \pause
    \begin{pygments}{haskell}
zip3' xs ys zs =
    case (xs,ys,zs) of
      ([],[],[]) -> []
      (x:xs',y:ys',z:zs') -> (x,y,z) : zip3' xs' ys' zs'
      _ -> error "list sizes don't match"
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that converts a list of triples into a triple of
        lists
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Nested Pattern Example}

  \begin{example}[convert a list of triples into a triple of lists]
    \begin{pygments}{haskell}
unzip3' xs =
    case xs of
      [] -> ([],[],[])
      (x1,x2,x3):xs' -> (x1:xs1,x2:xs2,x3:xs3)
                        where (xs1,xs2,xs3) = unzip3' xs'
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Pattern Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that checks whether a list is nondecreasing
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Pattern Example}

  \begin{example}[check whether a list is nondecreasing]
    \begin{pygments}{haskell}
nondecreasing xs =
    case xs of
      [] -> True
      _:[] -> True
      x1:x2:xs' -> x1 <= x2 && nondecreasing (x2:xs')
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Patterns}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
f p1 = e1
f p2 = e2
    \end{pygments}
  \end{block}

  \pause
  \begin{example}
    \begin{pygments}{haskell}
fact 0 = 1
fact n = n * fact (n - 1)

sum' [] = 0
sum' (x:xs) = x + sum' xs

third (_,_,z) = z
    \end{pygments}
  \end{example}
\end{frame}

\section{Algebraic Types}

\subsection{Type Definitions}

\begin{frame}[fragile]
  \frametitle{Type Definitions}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
data TypeConstructor = ValueConstructor1 components1
                     | ValueConstructor2 components2
                     | ...
    \end{pygments}
  \end{block}

  \pause
  \begin{itemize}
    \item can be used to define enumerations, unions (discriminated records)
    \begin{itemize}
      \item type constructor $\rightarrow$ type name
      \item value constructor $\rightarrow$ tag
      \item getting value (variant) $\rightarrow$ projection
    \end{itemize}
    \item different value constructors can contain different components
    \item use pattern matching for tag test and projection
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Examples}

  \begin{example}[type constructors]
    \begin{pygments}{haskell}
data Month = Jan | Feb | Mar | Apr | May | Jun
           | Jul | Aug | Sep | Oct | Nov | Dec
           deriving Show

data TaggedNumber = Exact Integer | Inexact Float
                    deriving Show

data PersonName = OnlyLast String
                | FirstLast String String
                | FirstMiddleLast String Char String
                deriving Show
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Examples}

  \begin{example}[value constructors]
    \begin{pygments}{haskell}
Jan
Mar

Exact 42
Inexact 3.14159

OnlyLast "Turing"
FirstLast "Alonzo" "Church"
FirstMiddleLast "Johnny" 'B' "Goode"
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Examples}

  \begin{example}[pattern matching]
    \begin{pygments}{haskell}
daysInMonth m y =
    case m of
      Apr -> 30
      Jun -> 30
      Sep -> 30
      Nov -> 30
      Feb -> if y `mod` 4 == 0 then 29 else 28
      _ -> 31

-- daysInMonth Jan 2013 -> 31
-- daysInMonth Feb 2013 -> 28
-- daysInMonth Feb 2012 -> 29
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Examples}

  \begin{example}[pattern matching]
    \begin{pygments}{haskell}
rounded num =
    case num of
      Exact i -> i
      Inexact r -> round r

-- rounded (Exact 42) -> 42
-- rounded (Inexact 3.14159) -> 3
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Examples}

  \begin{example}[pattern matching]
    \begin{pygments}{haskell}
fullName n =
    case n of
      OnlyLast l -> l
      FirstLast f l -> f ++ " " ++ l
      FirstMiddleLast f m l -> f ++ " " ++ [m] ++ ". " ++ l

-- fullName (OnlyLast "Turing") -> "Turing"
-- fullName (FirstLast "Alonzo" "Church") -> "Alonzo Church"
-- fullName (FirstMiddleLast "Johnny" 'B' "Goode")
--     -> "Johnny B. Goode"
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unions in C}

  \begin{itemize}
    \item no tag: \emph{free union}
  \end{itemize}

  \begin{example}
    \begin{pygments}{c}
union untagged_number {
    int ival;
    float rval;
};
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Unions in C}

  \begin{itemize}
    \item projection is unsafe $\rightarrow$ use in conjunction with structs
  \end{itemize}

  \begin{example}
    \begin{pygments}{c}
enum accuracy {EXACT, INEXACT};

struct tagged_number {
    enum accuracy acc;
    union {
        int ival;
        float rval;
    } val;
};
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Union Example}

  \begin{example}
    \begin{pygments}{c}
int rounded(struct tagged_number n)
{
    if (n.acc == EXACT)
        return (int) n.val.ival;
    else if (n.acc == INEXACT)
        return (int) round(n.val.rval);
}
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Type Aliasing}

\begin{frame}[fragile]
  \frametitle{Type Aliasing}

  \begin{itemize}
    \item \alert{type aliasing}: giving an existing type a new name
  \end{itemize}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
type NewName = OldName
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Aliasing Example}

  \begin{example}[playing cards]
    \begin{pygments}{haskell}
data Suit = Club | Diamond | Heart | Spade
            deriving Show

data Rank = Jack | Queen | King | Ace | Number Integer
            deriving Show

type Card = (Suit, Rank)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Example}

  \begin{example}[color of a card]
    \pause
    \begin{pygments}{haskell}
data Color = Red | Black
             deriving Show

cardColor :: Card -> Color
cardColor card =
    case card of
      (Club,_) -> Black
      (Diamond,_) -> Red
      (Heart,_) -> Red
      (Spade,_) -> Black
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that will return the value of a card
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Algebraic Type Example}

  \begin{example}[value of a card]
    \begin{pygments}{haskell}
cardValue card =
    case card of
      (_,Ace) -> 11
      (_,King) -> 10
      (_,Queen) -> 10
      (_,Jack) -> 10
      (_,Number n) -> n
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Parameterized Types}

\begin{frame}[fragile]
  \frametitle{Parameterized Types}

  \begin{itemize}
    \item type constructors can be parameterized

    \pause
    \bigskip
    \item already defined in Haskell standard library:
    \item some type or nothing: \pygment{haskell}{Maybe}
    \item one of two types: \pygment{haskell}{Either}
  \end{itemize}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
data Maybe a = Nothing | Just a

data Either a b = Left a | Right b
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Maybe Type Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that returns the maximum element of a list
      \item if empty: \pygment{haskell}{Nothing}
      \item if not empty: \pygment{haskell}{Just x}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Maybe Type Example}

  \begin{example}[maximum of a list]
    \begin{pygments}{haskell}
maybeMax xs =
    let
       maxIter acc items =
           case items of
             [] -> acc
             item:items' -> if item > acc
                            then maxIter item items'
                            else maxIter acc items'
    in
        case xs of
          [] -> Nothing
          x:xs' -> Just (maxIter x xs')
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Recursive Types}

\begin{frame}[fragile]
  \frametitle{Recursive Types}

  \begin{itemize}
    \item type constructors can refer to themselves
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
data List' a = EmptyList | NonEmptyList a (List' a)
               deriving Show
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
null' xs =
    case xs of
      EmptyList -> True
      _ -> False
    \end{pygments}

    \pause
    \smallskip
    \begin{pygments}{haskell}
head' xs =
    case xs of
      EmptyList -> Nothing
      NonEmptyList x _ -> Just x
    \end{pygments}

    \pause
    \smallskip
    \begin{pygments}{haskell}
append' xs ys =
    case xs of
      EmptyList -> ys
      NonEmptyList x xs' -> NonEmptyList x (append' xs' ys)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[binary tree]
    \begin{pygments}{haskell}
data Tree' a = EmptyTree
             | NonEmptyTree a (Tree' a) (Tree' a)
             deriving Show
    \end{pygments}

    \pause
    \begin{pygments}{haskell}
depth' t =
    case t of
      EmptyTree -> 0
      NonEmptyTree _ t1 t2 -> 1 + max (depth' t1) (depth' t2)
    \end{pygments}
  \end{example}

  \pause
  \begin{block}{Exercise}
    \begin{itemize}
      \item write a function that returns the number of leaves in a tree
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[number of leaves in a tree]
    \pause
    \begin{pygments}{haskell}
leaves t =
    case t of
      EmptyTree -> 0
      NonEmptyTree _ EmptyTree EmptyTree -> 1
      NonEmptyTree _ t1 t2 -> leaves t1 + leaves t2
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[binary tree with different types at nodes and leaves]
    \begin{pygments}{haskell}
data LeafNodeTree a b =
    Node a (LeafNodeTree a b) (LeafNodeTree a b)
  | Leaf b
  deriving Show
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[expression tree]
    \begin{pygments}{haskell}
data Expression = Constant Integer
                | Negate Expression
                | Add Expression Expression
                | Multiply Expression Expression
                deriving Show
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Type Example}

  \begin{example}[evaluate an expression]
    \pause
    \begin{pygments}{haskell}
eval e =
    case e of
      Constant c -> c
      Negate e -> -(eval e)
      Add e1 e2 -> (eval e1) + (eval e2)
      Multiply e1 e2 -> (eval e1) * (eval e2)

-- eval (Constant 4) -> 4
-- eval (Add (Constant 4) (Constant 5)) -> 9
-- eval (Negate (Add (Constant 4) (Constant 5))) -> -9
-- eval (Multiply (Constant 2)
--         (Negate (Add (Constant 4) (Constant 5)))) -> -18
    \end{pygments}
  \end{example}
\end{frame}
% 
% \section*{References}
% 
% \begin{frame}
%   \frametitle{References}
% 
%   \begin{block}{Required Reading: Abelson, Sussman}
%     \begin{itemize}
%       \item Chapter 1: Building Abstractions with Procedures
%       \begin{itemize}
%         \item 1.1. \alert{The Elements of Programming}
%       \end{itemize}
%     \end{itemize}
%   \end{block}
% \end{frame}

\end{document}
