% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Pattern Matching}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Data Types}

\subsection{Tuples}

\begin{frame}[fragile]
  \frametitle{Tuples}

  \begin{itemize}
    \item \alert{tuple}: a combination of a fixed number of values
      of fixed types
    \begin{block}{}
      \begin{pygments}{haskell}
name :: (t1,t2,...,tn)
name = (v1,v2,...,vn)
      \end{pygments}
    \end{block}

    \medskip
    \item selector functions on pairs:\\
      \pygment{haskell}{fst}, \pygment{haskell}{snd}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Examples}

  \begin{exampleblock}{representing a term in a polynomial: $2.4x^2$}
    \begin{pygments}{haskell}
term1 :: (Float,Integer)
term1 = (2.4,2)

fst term1  -- 2.4
snd term1  -- 2
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Parameters}

  \begin{itemize}
    \item tuple parameters are different from multiple parameters
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd :: Integer -> Integer -> Integer
gcd x y
  | y == 0    = x
  | otherwise = gcd y (x `mod` y)
-- call as: gcd 9702 945

gcd' :: (Integer,Integer) -> Integer
gcd' a
  | snd a == 0 = fst a
  | otherwise  = gcd' (snd a, (fst a) `mod` (snd a))
-- call as: gcd' (9702, 945)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Results}

  \begin{itemize}
    \item functions can return tuples
  \end{itemize}

  \begin{exampleblock}{example: greatest common divisor
                            and least common multiple}
    \begin{pygments}{haskell}
gcd_lcm :: Integer -> Integer -> (Integer,Integer)
gcd_lcm x y = (d,m)
  where d = gcd x y
        m = (x*y) `div` d
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Lists}

\begin{frame}[fragile]
  \frametitle{Lists}

  \begin{itemize}
    \item \alert{list}: a combination of an arbitrary number of values,\\
      all of the same type
    \begin{block}{}
      \begin{pygments}{haskell}
name :: [t]
name = [v1,v2,...,vn]
      \end{pygments}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{representing polynomials: $2.4x^2 + 1.8x - 4.6$}
    \begin{pygments}{haskell}
-- second degree polynomial
p1 :: (Float,Float,Float)
p1 = (2.4,1.8,-4.6)

-- any degree polynomial, coefficients ordered
p2 :: [Float]
p2 = [2.4,1.8,-4.6]

-- any degree polynomial, coefficients unordered
p3 :: [(Float,Integer)]
p3 = [(1.8,1), (-4.6,0), (2.4,2)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Synonyms}

  \begin{block}{type synonyms}
    \begin{pygments}{haskell}
type newName = oldName
    \end{pygments}
  \end{block}

  \begin{exampleblock}{example: representing polynomials}
    \begin{pygments}{haskell}
type Term = (Float,Integer)
type Polynomial = [Term]

p4 :: Polynomial
p4 = [(1.8,1), (-4.6,0), (2.4,2)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Lists}

  \begin{itemize}
    \item a list consists of a first item (\alert{head})\\
      followed by a list of the remaining items (\alert{tail})

  \medskip
    \item basic list operations:
      \begin{itemize}
        \item check if empty: \pygment{haskell}{null}
        \item get the head: \pygment{haskell}{head}
        \item get the tail: \pygment{haskell}{tail}
        \item construct a list: \pygment{haskell}{item : sublist}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Operation Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- null :: [a] -> Bool
null []         -- True
null [1,2,3,4]  -- False

-- head :: [a] -> a
head [1,2,3,4]  -- 1
head []         -- error
head [1]        -- 1

-- tail :: [a] -> [a]
tail [1,2,3,4]  -- [2,3,4]
tail []         -- error
tail [1]        -- []

-- (:) :: a -> [a] -> [a]
1 : [2,3]       -- [1,2,3]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{number of elements}
    \begin{pygments}{haskell}
length :: [a] -> Integer
length xs
  | null xs   = 0
  | otherwise = 1 + length (tail xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{number of elements (tail recursive)}
    \begin{pygments}{haskell}
length :: [a] -> Integer
length xs = lengthIter 0 xs
  where
    lengthIter :: Integer -> [a] -> Integer
    lengthIter acc xs'
      | null xs'  = acc
      | otherwise = lengthIter (acc+1) (tail xs')
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{sum of elements}
    \begin{pygments}{haskell}
sum :: [Integer] -> Integer
sum xs
  | null xs   = 0
  | otherwise = head xs + sum (tail xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{sum of first two elements}
    \begin{pygments}{haskell}
firstPlusSecond :: [Integer] -> Integer
firstPlusSecond xs
  | null xs        = 0
  | null (tail xs) = head xs
  | otherwise      = head xs + head (tail xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Algebraic Types}

\begin{frame}[fragile]
  \frametitle{Algebraic Types}

  \begin{itemize}
    \item algebraic types can be used to define:
    \begin{itemize}
      \item enumerated types
      \item product types
      \item alternatives
    \end{itemize}
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
data TypeName = Constructor_1 t_1_1 t_1_2 ... t_1_k1 |
                Constructor_2 t_2_1 t_2_2 ... t_2_k2 |
                ...
                Constructor_n t_n_1 t_n_2 ... t_n_kn
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Constructors}

  \begin{itemize}
    \item value construction:\\
      \pygment{haskell}{Constructor_i v_i_1 v_i_2 ... v_i_n}

    \medskip
    \item constructors are functions
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
Constructor_i :: t_i_1 -> ... -> t_i_kn -> TypeName
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enumerated Types}

  \begin{itemize}
    \item enumerated type: no components in constructors
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Month = Jan | Feb | Mar | Apr | May | Jun |
             Jul | Aug | Sep | Oct | Nov | Dec
             deriving Show

currentMonth :: Month
currentMonth = Feb
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Product Types}

  \begin{itemize}
    \item product type: one constructor with multiple components
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Name = String
type Year = Integer

data Human = Person Name Year
             deriving Show

church :: Human
church = Person "Alonzo Church" 1903
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alternative Types}

  \begin{itemize}
    \item alternative type: multiple constructors
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Coords = (Float,Float)
type Length = Float

data Shape = Point Coords |
             Circle Coords Length |
             Rectangle Coords Length Length
             deriving Show

Point (0.0,0.0)
Circle (0.0,0.0) 1.0
Rectangle (45.9,87.6) 5.75 2.3
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section{Pattern Matching}

\subsection{Patterns}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{itemize}
    \item expressions can be checked against patterns
    \item the result is the expression for the first matched pattern
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
case expr of
  p1 -> e1
  p2 -> e2
  ...
  pn -> en
  _  -> e
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{itemize}
    \item simplest pattern: literal value
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd :: Integer -> Integer -> Integer
gcd x y =
    case y of
      0 -> x
      _ -> gcd y (x `mod` y)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern Bindings}

  \begin{itemize}
    \item a matched pattern can generate bindings
    \item for tuples, pattern matching is better than selector functions
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd' :: (Integer,Integer) -> Integer
gcd' a =
    case a of
      (x,0) -> x
      (x,y) -> gcd' (y, x `mod` y)

gcd' (9702,945)
-- second pattern, bindings: x <-> 9702, y <-> 945

gcd' (63,0)
-- first pattern, bindings: x <-> 63
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nested Patterns}

  \begin{itemize}
    \item patterns can be nested
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
shift :: ((a,b), c) -> (a, (b,c))
shift s =
    case s of
      ((x,y), z) -> (x, (y,z))
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Wildcards}

  \begin{itemize}
    \item if binding is not needed, use wildcard: \pygment{haskell}{_}
  \end{itemize}

  \begin{exampleblock}{third component of a triple}
    \begin{pygments}{haskell}
third :: (a,b,c) -> c
third t =
    case t of
      (x,y,z) -> z

-- BETTER:
third t =
    case t of
      (_,_,z) -> z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{List Patterns}

\begin{frame}[fragile]
  \frametitle{List Patterns}

  \begin{itemize}
    \item empty list:\\
      \pygment{haskell}{[]}
    \item nonempty list:\\
      \pygment{haskell}{x:xs}
    \item list with exactly one element:\\
      \pygment{haskell}{[x]}\\
      \pygment{haskell}{x:[]}
    \item list with exactly two elements:\\
      \pygment{haskell}{[x1,x2]}\\
      \pygment{haskell}{x1:x2:[]}
    \item list with at least two elements:\\
      \pygment{haskell}{x1:x2:xs}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{exampleblock}{number of elements}
    \begin{pygments}{haskell}
length :: [a] -> Integer
length xs =
    case xs of
      []    -> 0
      x:xs' -> 1 + length xs'
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{exampleblock}{sum of the first and third elements of a list}
    \begin{pygments}{haskell}
firstPlusThird :: [Integer] -> Integer
firstPlusThird xs =
    case xs of
      []        -> 0
      [x1]      -> x1
      [x1,_]    -> x1
      x1:_:x3:_ -> x1+x3
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Algebraic Type Patterns}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Patterns}

  \begin{itemize}
    \item use patterns to match algebraic types
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
daysInMonth :: Month -> Integer -> Integer
daysInMonth m y =
    case m of
      Apr -> 30
      Jun -> 30
      Sep -> 30
      Nov -> 30
      Feb -> if y `mod` 4 == 0 then 29 else 28
      _   -> 31

daysInMonth Jan 2014 -- 31
daysInMonth Feb 2014 -- 28
daysInMonth Feb 2016 -- 29
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Patterns}

  \begin{itemize}
    \item use pattern matching to get values out of algebraic types
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
birthYear :: Human -> Year
birthYear p =
    case p of
      Person _ y -> y

birthYear (Person "Alonzo Church" 1903)  -- 1903
-- binding: y <-> 1903
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
area :: Shape -> Float
area s =
    case s of
      Point     _     -> 0.0
      Circle    _ r   -> 3.14159 * r * r
      Rectangle _ h w -> h * w

area (Circle (0.0,0.0) 3.0) -- 28.274311
-- second pattern, binding: r <-> 3.0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Function Patterns}

\begin{frame}[fragile]
  \frametitle{Pattern Matching}

  \begin{itemize}
    \item formal parameters are patterns
    \item components of the pattern will be matched\\
      with the components of the actual parameters
    \item in case of multiple patterns, the first match will be selected
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
name p1 = e1
name p2 = e2
...
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd :: Integer -> Integer -> Integer
gcd x y =
    case y of
      0 -> x
      _ -> gcd y (x `mod` y)

-- BETTER:
gcd :: Integer -> Integer -> Integer
gcd x 0 = x
gcd x y = gcd y (x `mod` y)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd' :: (Integer,Integer) -> Integer
gcd' a =
    case a of
      (x,0) -> x
      (x,y) -> gcd' (y, x `mod` y)

-- BETTER:
gcd' :: (Integer,Integer) -> Integer
gcd' (x,0) = x
gcd' (x,y) = gcd' (y, x `mod` y)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
shift :: ((a,b), c) -> (a, (b,c))
shift s =
    case s of
      ((x,y), z) -> (x, (y,z))

-- BETTER:
shift :: ((a,b), c) -> (a, (b,c))
shift ((x,y), z) = (x, (y,z))
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
third :: (a,b,c) -> c
third t =
    case t of
      (_,_,z) -> z

-- BETTER:
third :: (a,b,c) -> c
third (_,_,z) = z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
length :: [a] -> Integer
length xs =
    case xs of
      []    -> 0
      x:xs' -> 1 + length xs'

-- BETTER:
length :: [a] -> Integer
length []     = 0
length (x:xs) = 1 + length xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
birthYear :: Human -> Year
birthYear p =
    case p of
      Person _ y -> y

-- BETTER:
birthYear :: Human -> Year
birthYear (Person _ y) = y
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}

  \begin{exampleblock}{efficient Fibonacci calculation}
    \begin{pygments}{haskell}
fibStep :: (Integer,Integer) -> (Integer,Integer)
fibStep (u,v) = (v,u+v)

-- fibPair n = (fib n, fib (n+1))
fibPair :: Integer -> (Integer,Integer)
fibPair 1 = (1,1)
fibPair n = fibStep (fibPair (n-1))

fastFib n = fst (fibPair n)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Rational = (Integer,Integer)

simplify :: Rational -> Rational
simplify (n,d) = (n `div` g, d `div` g)
  where g = gcd n d

type DayInYear = (Integer,Integer)

mar12 :: DayInYear
mar12 = (12,3)
simplify mar12 -- (4,1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{itemize}
    \item algebraic types give you better type checking
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Rational' = Fraction Integer Integer
                 deriving Show

simplify' :: Rational' -> Rational'
simplify' (Fraction n d) =
  Fraction (n `div` g) (d `div` g)
    where g = gcd n d
    \end{pygments}
  \end{exampleblock}
\end{frame}

% TODO: add example for using case expression over function pattern

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 5: \alert{Data types, tuples and lists}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
