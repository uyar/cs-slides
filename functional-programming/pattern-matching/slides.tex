% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\usepackage{listings}
\lstset{basicstyle=\ttfamily, keywordstyle=\color{blue},
        showstringspaces=false, frame=ltrb}
\lstset{language=haskell, deletekeywords={gcd,length,Rational,sum}}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Pattern Matching}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Data Types}

\subsection{Tuples}

\begin{frame}[fragile]
  \frametitle{Tuples}

  \begin{itemize}
    \item \alert{tuple}: a combination of a fixed number of values
      of fixed types
      \smallskip
      \begin{lstlisting}
n :: (t1,t2,...,tn)
n = (e1,e2,...,en)
      \end{lstlisting}

    \medskip
    \item selector functions on pairs:\\
      \lstinline{fst}, \lstinline{snd}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Example}

  \begin{itemize}
    \item representing a term in a polynomial: $2.4x^2$
  \end{itemize}

  \medskip
  \begin{lstlisting}
t :: (Float,Integer)
t = (2.4,2)

fst t  -- 2.4
snd t  -- 2
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Parameters}

  \begin{itemize}
    \item tuple parameters are different from multiple parameters
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
gcd :: Integer -> Integer -> Integer
gcd x y
  | y == 0    = x
  | otherwise = gcd y (x `mod` y)
-- call as: gcd 9702 945

gcd' :: (Integer,Integer) -> Integer
gcd' a
  | snd a == 0 = fst a
  | otherwise  = gcd' (snd a, (fst a) `mod` (snd a))
-- call as: gcd' (9702,945)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Results}

  \begin{itemize}
    \item functions can return tuples
  \end{itemize}

  \begin{exampleblock}{example: greatest common divisor
                            and least common multiple}
    \begin{lstlisting}
gcd_lcm :: Integer -> Integer -> (Integer,Integer)
gcd_lcm x y = (d,m)
  where d = gcd x y
        m = (x*y) `div` d
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Lists}

\begin{frame}[fragile]
  \frametitle{Lists}

  \begin{itemize}
    \item \alert{list}: a combination of an arbitrary number of values,\\
      all of the same type
    \smallskip
    \begin{lstlisting}
name :: [t]
name = [e1,e2,...,en]
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{itemize}
    \item representing a polynomial: $2.4x^2 + 1.8x - 4.6$
  \end{itemize}

  \begin{lstlisting}
-- second degree polynomial
p1 :: (Float,Float,Float)
p1 = (2.4,1.8,-4.6)

-- any degree polynomial, coefficients ordered
p2 :: [Float]
p2 = [2.4,1.8,-4.6]

-- any degree polynomial, coefficients unordered
p3 :: [(Float,Integer)]
p3 = [(1.8,1), (-4.6,0), (2.4,2)]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Synonyms}

  \begin{itemize}
    \item type synonym: giving an existing type a new name
    \smallskip
    \begin{lstlisting}
type newName = oldName
    \end{lstlisting}
  \end{itemize}

  \pause
  \begin{exampleblock}{example: representing a polynomial}
    \begin{lstlisting}
type Term = (Float,Integer)
type Polynomial = [Term]

p4 :: Polynomial
p4 = [(1.8,1), (-4.6,0), (2.4,2)]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Lists}

  \begin{itemize}
    \item a list consists of a first item (\alert{head})\\
      followed by a list of the remaining items (\alert{tail})

    \medskip
    \item check if empty: \lstinline{null}
    \item get the head: \lstinline{head}
    \item get the tail: \lstinline{tail}
    \item construct a list: \lstinline{item : sublist}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Operation Examples}

  \begin{lstlisting}
-- null :: [a] -> Bool
null []         -- True
null [1,2,3,4]  -- False

-- head :: [a] -> a
head [1,2,3,4]  -- 1
head []         -- error
head [1]        -- 1

-- tail :: [a] -> [a]
tail [1,2,3,4]  -- [2,3,4]
tail []         -- error
tail [1]        -- []

-- (:) :: a -> [a] -> [a]
1 : [2,3]       -- [1,2,3]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{itemize}
    \item number of elements
  \end{itemize}

  \begin{lstlisting}
length :: [a] -> Integer
length xs
  | null xs   = 0
  | otherwise = 1 + length (tail xs)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{itemize}
    \item number of elements (tail recursive)
  \end{itemize}

  \begin{lstlisting}
length :: [a] -> Integer
length xs = lengthIter 0 xs
  where
    lengthIter :: Integer -> [a] -> Integer
    lengthIter acc xs'
      | null xs'  = acc
      | otherwise = lengthIter (acc+1) (tail xs')
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{itemize}
    \item sum of elements
  \end{itemize}

  \begin{lstlisting}
sum :: [Integer] -> Integer
sum xs
  | null xs   = 0
  | otherwise = head xs + sum (tail xs)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{itemize}
    \item sum of first two elements
  \end{itemize}

  \begin{lstlisting}
firstPlusSecond :: [Integer] -> Integer
firstPlusSecond xs
  | null xs        = 0
  | null (tail xs) = head xs
  | otherwise      = head xs + head (tail xs)
  \end{lstlisting}
\end{frame}

\subsection{Algebraic Types}

\begin{frame}[fragile]
  \frametitle{Algebraic Types}

  \begin{itemize}
    \item algebraic types: constructors and components

    \medskip
    \item product types
    \item enumerations
    \item alternatives
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Product Types}

  \begin{itemize}
    \item product type: one constructor
    \smallskip
    \begin{lstlisting}
data T = C t1 t2 ... tn
    \end{lstlisting}
    \item value construction: \lstinline{C e1 e2 ... en}
    \item constructors are functions
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
type Name = String
type Year = Integer

data Human = Person Name Year
             deriving Show

church :: Human
church = Person "Alonzo Church" 1903
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enumerations}

  \begin{itemize}
    \item enumeration: only constructors, no components
    \smallskip
    \begin{lstlisting}
data T = C1 | C2 | ... | Cn
    \end{lstlisting}
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
data Month = Jan | Feb | Mar | Apr | May | Jun |
             Jul | Aug | Sep | Oct | Nov | Dec
             deriving Show

m :: Month
m = Feb
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alternative Types}

  \begin{itemize}
    \item alternative type: multiple constructors
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
type Coords = (Float,Float)
type Length = Float

data Shape = Point Coords |
             Circle Coords Length |
             Rectangle Coords Length Length
             deriving Show

p, c, r :: Shape
p = Point (0.0,0.0)
c = Circle (0.0,0.0) 1.0
r = Rectangle (45.9,87.6) 5.75 2.3
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{Pattern Matching}

\subsection{Patterns}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{itemize}
    \item expressions can be checked against patterns
    \item result is the expression for the first matched pattern
  \end{itemize}

  \begin{lstlisting}
case expr of
  p1 -> e1
  p2 -> e2
  ...
  pn -> en
  _  -> e
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Patterns}

  \begin{itemize}
    \item simplest pattern: literal value
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
gcd :: Integer -> Integer -> Integer
gcd x y =
    case y of
      0 -> x
      _ -> gcd y (x `mod` y)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern Bindings}

  \begin{itemize}
    \item matched patterns generate bindings
    \item for tuples, pattern matching is better than selector functions
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
gcd' :: (Integer,Integer) -> Integer
gcd' a =
    case a of
      (x,0) -> x
      (x,y) -> gcd' (y, x `mod` y)

gcd' (9702,945)
-- second pattern, bindings: x <-> 9702, y <-> 945

gcd' (63,0)
-- first pattern, bindings: x <-> 63
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nested Patterns}

  \begin{itemize}
    \item patterns can be nested
  \end{itemize}

  \begin{exampleblock}{example}
    \begin{lstlisting}
shift :: ((a,b), c) -> (a, (b,c))
shift s =
    case s of
      ((x,y), z) -> (x, (y,z))
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Wildcards}

  \begin{itemize}
    \item if binding not needed, use wildcard: \lstinline{_}
  \end{itemize}

  \begin{exampleblock}{example: third component of a triple}
    \begin{lstlisting}
third :: (a,b,c) -> c
third t =
    case t of
      (x,y,z) -> z

-- BETTER:
third t =
    case t of
      (_,_,z) -> z
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{List Patterns}

\begin{frame}[fragile]
  \frametitle{List Patterns}

  \begin{itemize}
    \item empty list:\\
      \lstinline{[]}
    \item nonempty list:\\
      \lstinline{x:xs}
    \item list with exactly one element:\\
      \lstinline{[x]}\\
      \lstinline{x:[]}
    \item list with exactly two elements:\\
      \lstinline{[x1,x2]}\\
      \lstinline{x1:x2:[]}
    \item list with at least two elements:\\
      \lstinline{x1:x2:xs}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{itemize}
    \item number of elements
  \end{itemize}

  \begin{lstlisting}
length :: [a] -> Integer
length xs =
    case xs of
      []    -> 0
      x:xs' -> 1 + length xs'
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{itemize}
    \item sum of the first and third elements
  \end{itemize}

  \begin{lstlisting}
firstPlusThird :: [Integer] -> Integer
firstPlusThird xs =
    case xs of
      []        -> 0
      [x1]      -> x1
      [x1,_]    -> x1
      x1:_:x3:_ -> x1+x3
  \end{lstlisting}
\end{frame}

\subsection{Algebraic Type Patterns}

\begin{frame}
  \frametitle{Algebraic Type Patterns}

  \begin{itemize}
    \item patterns can match algebraic types
    \item use pattern matching to get values out of product types
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Product Type Example}

  \begin{lstlisting}
birthYear :: Human -> Year
birthYear p =
    case p of
      Person _ y -> y

birthYear (Person "Alonzo Church" 1903)  -- 1903
-- binding: y <-> 1903
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enumeration Pattern Example}

  \begin{lstlisting}
daysInMonth :: Month -> Integer -> Integer
daysInMonth m y =
    case m of
      Apr -> 30
      Jun -> 30
      Sep -> 30
      Nov -> 30
      Feb -> if y `mod` 4 == 0 then 29 else 28
      _   -> 31

daysInMonth Jan 2014 -- 31
daysInMonth Feb 2014 -- 28
daysInMonth Feb 2016 -- 29
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Example}

  \begin{lstlisting}
area :: Shape -> Float
area s =
    case s of
      Point     _     -> 0.0
      Circle    _ r   -> 3.14159 * r * r
      Rectangle _ h w -> h * w

area (Circle (0.0,0.0) 3.0) -- 28.274311
-- second pattern, binding: r <-> 3.0
  \end{lstlisting}
\end{frame}

\subsection{Function Patterns}

\begin{frame}[fragile]
  \frametitle{Function Patterns}

  \begin{itemize}
    \item formal parameters are patterns
    \item components of the pattern will be matched\\
      with the components of the actual parameters

    \medskip
    \item in case of multiple patterns, the first match will be selected
    \smallskip
    \begin{lstlisting}
name p1 = e1
name p2 = e2
...
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
gcd :: Integer -> Integer -> Integer
gcd x y =
    case y of
      0 -> x
      _ -> gcd y (x `mod` y)

-- BETTER:
gcd :: Integer -> Integer -> Integer
gcd x 0 = x
gcd x y = gcd y (x `mod` y)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
gcd' :: (Integer,Integer) -> Integer
gcd' a =
    case a of
      (x,0) -> x
      (x,y) -> gcd' (y, x `mod` y)

-- BETTER:
gcd' :: (Integer,Integer) -> Integer
gcd' (x,0) = x
gcd' (x,y) = gcd' (y, x `mod` y)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
shift :: ((a,b), c) -> (a, (b,c))
shift s =
    case s of
      ((x,y), z) -> (x, (y,z))

-- BETTER:
shift :: ((a,b), c) -> (a, (b,c))
shift ((x,y), z) = (x, (y,z))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
third :: (a,b,c) -> c
third t =
    case t of
      (_,_,z) -> z

-- BETTER:
third :: (a,b,c) -> c
third (_,_,z) = z
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
length :: [a] -> Integer
length xs =
    case xs of
      []    -> 0
      x:xs' -> 1 + length xs'

-- BETTER:
length :: [a] -> Integer
length []     = 0
length (x:xs) = 1 + length xs
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Pattern Example}

  \begin{lstlisting}
birthYear :: Human -> Year
birthYear p =
    case p of
      Person _ y -> y

-- BETTER:
birthYear :: Human -> Year
birthYear (Person _ y) = y
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Example}

  \begin{itemize}
    \item efficient Fibonacci calculation
  \end{itemize}

  \begin{lstlisting}
fibStep :: (Integer,Integer) -> (Integer,Integer)
fibStep (u,v) = (v,u+v)

-- fibPair n = (fib n, fib (n+1))
fibPair :: Integer -> (Integer,Integer)
fibPair 1 = (1,1)
fibPair n = fibStep (fibPair (n-1))

fastFib n = fst (fibPair n)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{lstlisting}
type Rational = (Integer,Integer)

simplify :: Rational -> Rational
simplify (n,d) = (n `div` g, d `div` g)
  where g = gcd n d

type DayInYear = (Integer,Integer)

mar12 :: DayInYear
mar12 = (12,3)
simplify mar12 -- (4,1)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{itemize}
    \item algebraic types give you better type checking
  \end{itemize}

  \begin{lstlisting}
data Rational' = Fraction Integer Integer
                 deriving Show

simplify' :: Rational' -> Rational'
simplify' (Fraction n d) =
  Fraction (n `div` g) (d `div` g)
    where g = gcd n d
  \end{lstlisting}
\end{frame}

% TODO: add example for using case expression over function pattern

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 5: \alert{Data types, tuples and lists}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
