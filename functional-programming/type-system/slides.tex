% Copyright (c) 2013-2015 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage[scaled=0.95]{cabin}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,
        keywordstyle=\color{blue},
        showstringspaces=false}
\lstdefinestyle{syntax}{frame=single}
\lstset{language=Haskell}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Type Classes}

\author{H. Turgut Uyar}
\date{2013-2015}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2015 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}

    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{footnotesize}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Type Classes}

\subsection{Introduction}

\begin{frame}[fragile]
  \frametitle{Overloading}

  \begin{itemize}
    \item check whether an item is an element of a list
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
elem :: Char -> [Char] -> Bool
elem _ []     = False
elem x (c:cs) = if x == c then True else elem x cs
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item a different function for every type?
    \item better to write it as:\\
      \lstinline|a -> [a] -> Bool|
    \item the type has to support equality checking
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Classes}

  \begin{itemize}
    \item \alert{type class}: a collection of types\\
      over which some functions are defined
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
class Eq a where
  (==) :: a -> a -> Bool
    \end{lstlisting}
  \end{exampleblock}

  \begin{itemize}
    \item every type belonging to the class must implement its functions
    \item members of a type class are called its \alert{instances}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Classes}

  \begin{itemize}
    \item scalar types like \lstinline|Bool|, \lstinline|Char|,
      \lstinline|Integer|, \lstinline|Float| are instances\\
      of the type class \lstinline|Eq|
    \item tuples and lists are also instances of \lstinline|Eq|
  \end{itemize}

  \pause
  % TODO: context
  \begin{exampleblock}{}
    \begin{lstlisting}
elem :: Eq a => a -> [a] -> Bool
elem _ []     = False
elem x (c:cs) = if x == c then True else elem x cs
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Instance Example}

  \begin{lstlisting}
data Move = Rock | Paper | Scissors

instance Eq Move where
  (==) Rock     Rock     = True
  (==) Paper    Paper    = True
  (==) Scissors Scissors = True
  (==) _        _        = False

elem Paper [Rock, Paper, Rock]    -- True
elem Scissors [Rock, Paper, Rock] -- False
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Instance Example}

  \begin{lstlisting}
instance Eq Move where
  Rock     == Rock     = True
  Paper    == Paper    = True
  Scissors == Scissors = True
  _        == _        = False
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Default Definitions}

  \begin{itemize}
    \item classes can contain default definitions for functions
    \item they can be overridden by instances
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
class Eq a where
  (==), (/=) :: a -> a -> Bool
  x /= y = not (x == y)
  x == y = not (x /= y)
    \end{lstlisting}
  \end{exampleblock}

  \begin{itemize}
    \item define one of \lstinline|==| and \lstinline|/=|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Derived Instances}

  \begin{itemize}
    \item default equality checker: derive from \lstinline|Eq|
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Move = Rock | Paper | Scissors
            deriving Eq
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item default string conversion: derive from \lstinline|Show|
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
class Show a where
  show :: a -> String

data Move = Rock | Paper | Scissors
            deriving (Eq, Show)
   \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Class Example}

  \begin{exampleblock}{rational numbers}
    \begin{lstlisting}
data Rational = Fraction Integer Integer

instance Eq Rational where
  Fraction n1 d1 == Fraction n2 d2 = n1 * d2 == n2 * d1

instance Show Rational where
  show (Fraction n d) = show n ++ "/" ++ show d
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Derived Classes}

\begin{frame}[fragile]
  \frametitle{Derived Classes}

  \begin{itemize}
    \item type classes can depend on other type classes
  \end{itemize}

  \begin{exampleblock}{example: ordering}
    \begin{lstlisting}
class Eq a => Ord a where
  (<), (<=), (>), (>=) :: a -> a -> Bool

  x <= y = (x < y || x == y)
  x >  y = y < x
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Class Example}

  \begin{lstlisting}
instance Ord Rational where
  Fraction n1 d1 < Fraction n2 d2 = n1 * d2 < n2 * d1

qSort :: Ord a => [a] -> [a]
qSort []     = []
qSort (x:xs) =
    qSort before ++ [x] ++ qSort after
      where
        before = [a | a <- xs, a <= x]
        after  = [b | b <- xs, a >  x]
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ordering}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Ordering = LT | EQ | GT

class Eq a => Ord a where
  (<), (<=), (>), (>=) :: a -> a -> Bool
  max, min             :: a -> a -> a
  compare              :: a -> a -> Ordering

  compare x y
    | x == y    = EQ
    | x <= y    = LT
    | otherwise = GT
    \end{lstlisting}
  \end{exampleblock}

  \begin{itemize}
    \item define either \lstinline|compare| or \lstinline|<=|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Ordering Default Definitions}

  \begin{exampleblock}{}
    \begin{lstlisting}
class Eq a => Ord a where

  x <= y = compare x y /= GT
  x < y  = compare x y == LT
  x >= y = compare x y /= LT
  x > y  = compare x y == GT

  max x y
    | x <= y    = y
    | otherwise = x

  min x y
    | x < y     = x
    | otherwise = y
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Numeric Type Class}

  \begin{exampleblock}{}
    \begin{lstlisting}
class (Eq a, Show a) => Num a where
  (+), (-), (*) :: a -> a -> a
  negate        :: a -> a
  abs, signum   :: a -> a
  fromInteger   :: Integer -> a

  x - y = x + negate y
    \end{lstlisting}
  \end{exampleblock}

  \begin{itemize}
    \item exercise: make \lstinline|Rational| an instance of
      \lstinline|Num|
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Numeric Type Class}

  \begin{exampleblock}{}
    \begin{lstlisting}
instance Num Rational where
  Fraction n1 d1 + Fraction n2 d2 =
      Fraction (n1 * d2 + n2 * d1) (d1 * d2)
  Fraction n1 d1 * Fraction n2 d2 =
      Fraction (n1 * n2) (d1 * d2)

  negate (Fraction n d) = Fraction (-n) d
  abs (Fraction n d)    = Fraction (abs n) (abs d)
  signum (Fraction n d)
    | n < 0     = Fraction (-1) 1
    | otherwise = Fraction   1  1

  fromInteger n = Fraction n 1
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Type Inference}

\begin{frame}
  \frametitle{Type Inference}

  \begin{itemize}
    \item type of entity not explicitly written
    \item inferred by the language processor

    \pause
    \medskip
    \item assign every binding a type such that type checking succeeds
    \item fail if no such assignment can be found
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Examples}

  \begin{lstlisting}
even n = n `mod` 2 == 0
-- even :: Integral a => a -> Bool

evenMessage n = if even n then "even" else "odd"
-- evenMessage :: Integral a => a -> [Char]

shrink x y z = if x then y `div` z else y
-- shrink :: Integral a => Bool -> a -> a -> a

foo1 x y = if x then y else x + 1
-- type inference fails

foo2 f g x = (f x, g x)
-- (t2 -> t) -> (t2 -> t1) -> t2 -> (t, t1)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Examples}

  \begin{exampleblock}{}
    \begin{lstlisting}
f (x, y) = (x, ['a' .. y])
-- (t, Char) -> (t, [Char])

g (m, zs) = m + length zs
-- g :: (Int, [a]) -> Int

h = g . f
-- h :: (Int, Char) -> Int
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{Algebraic Types}

\subsection{Recursive Algebraic Types}

\begin{frame}[fragile]
  \frametitle{Recursive Algebraic Types}

  \begin{itemize}
    \item types can be described in terms of themselves
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Expr = Lit Integer |
            Add Expr Expr |
            Mul Expr Expr
            deriving Show
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Algebraic Types}

  \begin{exampleblock}{evaluation}
    \begin{lstlisting}
eval :: Expr -> Integer
eval e =
  case e of
     Lit n     -> n
     Add e1 e2 -> (eval e1) + (eval e2)
     Mul e1 e2 -> (eval e1) * (eval e2)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Algebraic Types}

  \begin{exampleblock}{string conversion}
    \begin{lstlisting}
instance Show Expr where
  show e =
    case e of
      Lit n     -> show n
      Add e1 e2 -> show e1 ++ "+" ++ show e2
      Mul e1 e2 -> show e1 ++ "*" ++ show e2
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item incorrect:\\
      \lstinline|Mul (Add (Lit 2) (Lit 3)) (Lit 5)|
    \item exercise: write a correct implementation\\
      using the least number of parentheses
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursive Algebraic Types}

  \begin{exampleblock}{binary integer tree}
    \begin{lstlisting}
data IntTree = NilT | NodeT Integer IntTree IntTree

sumTree :: IntTree -> Integer
sumTree NilT            = 0
sumTree (NodeT n t1 t2) = n + sumTree t1 + sumTree t2

depth :: IntTree -> Integer
depth NilT            = 0
depth (NodeT _ t1 t2) = 1 + max (depth t1) (depth t2)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Polymorphic Algebraic Types}

\begin{frame}[fragile]
  \frametitle{Polymorphic Algebraic Types}

  \begin{itemize}
    \item generalize the tree type
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Tree a = NilT | NodeT a (Tree a) (Tree a)

sumTree :: Integral a => Tree a -> a
sumTree NilT            = 0
sumTree (NodeT n t1 t2) = n + sumTree t1 + sumTree t2

depth :: Tree a -> Integer
depth NilT            = 0
depth (NodeT _ t1 t2) = 1 + max (depth t1) (depth t2)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Error Types}

\begin{frame}[fragile]
  \frametitle{The Maybe Type}

  \begin{itemize}
    \item returning an error value
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Maybe a = Nothing | Just a
               deriving (Eq, Ord, Read, Show)


errDiv :: Integer -> Integer -> Maybe Integer
errDiv n m
  | m /= 0    = Just (n `div` m)
  | otherwise = Nothing
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Maybe Type}

  \begin{exampleblock}{maximum of a list}
    \begin{lstlisting}
maxListMaybe :: Ord a => [a] -> Maybe a
maxListMaybe []     = Nothing
maxListMaybe (x:xs) = Just (foldl max x xs)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Maybe Type}

  \begin{itemize}
    \item transmitting an error through a function
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
mapMaybe :: (a -> b) -> Maybe a -> Maybe b
mapMaybe g Nothing  = Nothing
mapMaybe g (Just x) = Just (g x)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Maybe Type}

  \begin{itemize}
    \item trapping an error
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
maybe :: b -> (a -> b) -> Maybe a -> b
maybe n f Nothing  = n
maybe n f (Just x) = f x
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The Either Type}

  \begin{exampleblock}{}
    \begin{lstlisting}
data Either a b = Left a | Right b
                  deriving (Eq, Ord, Read, Show)

either :: (a -> c) -> (b -> c) -> Either a b -> c
either f g (Left x)  = f x
either f g (Right y) = g y
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

% TODO: join exercise (14.20 p. 336) from the book

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 13: \alert{Overloading, type classes and type checking}
      \item Chapter 14: \alert{Algebraic types}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
