% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Expressions and Types}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[width=9.5cm]{shallow1}{shallow1}
\pgfdeclareimage[width=9.5cm]{shallow2}{shallow2}
\pgfdeclareimage[width=9.5cm]{shallow3}{shallow3}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Expressions and Functions}

\subsection{Expressions}

\begin{frame}[fragile]
  \frametitle{Local Bindings}

  \begin{itemize}
    \item local bindings can be created for use in an expression
    \item inner bindings can use outer bindings but not vice versa
  \end{itemize}

  \begin{columns}[t]
    \column{.45\textwidth}
    \begin{block}{Haskell: \pygment{haskell}{let}}
      \begin{pygments}{haskell}
let v1 = e1
    v2 = e2
    ...
in
    e
      \end{pygments}
    \end{block}

    \column{.45\textwidth}
    \begin{block}{Haskell: \pygment{haskell}{where}}
      \begin{pygments}{haskell}
e
where v1 = e1
      v2 = e2
      ...
      \end{pygments}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Local Binding Example}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
diameter = 4.8
area = let r = diameter / 2.0
       in 3.14159 * r * r

-- OR:

diameter = 4.8
area = 3.14159 * r * r
       where r = diameter / 2.0
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Expression Evaluation}

  \begin{itemize}
    \item take the operator with the highest precedence
    \item evaluate its operands (note the recursion)
    \item apply the operator to the operands

    \pause
    \medskip
    \item a name is evaluated by replacing it with its definition
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Evaluation Example}

  \begin{example}
    \pygment{python}{(3.14159 * r) * r}

    \pause
    \medskip
    \pygment{python}{(3.14159 * 2.4) * r}

    \pause
    \medskip
    \pygment{python}{7.539815999999999 * 2.4}

    \pause
    \medskip
    \pygment{python}{18.095558399999998}
  \end{example}
\end{frame}

\subsection{Functions}

\begin{frame}
  \frametitle{Function Evaluation}

  \begin{itemize}
    \item evaluate all function arguments (left to right)
    \item replace the function application\\
      with the right-hand side of its definition
    \item replace the formal parameters of the function\\
      with the actual parameters

    \pause
    \bigskip
    \item \alert{substitution model}
    \begin{itemize}
      \item reduces an expression to a value
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Function Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{sum_of_squares(3, 4)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(4)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item \alert{eager evaluation}: first evaluate arguments\\
      and then apply the function to the resulting values\\
      (a.k.a. ``call by value'')

    \pause
    \medskip
    \item \alert{normal order evaluation}: do not evaluate arguments\\
      until their values are needed\\
      (a.k.a. ``call by name'')
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Normal Order Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + (2 + 2) * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Church-Rosser Property}

  \begin{itemize}
    \item eager and normal order evaluations yield the same result\\
      as long as:

    \bigskip
    \item there are no side effects
    \item all evaluations terminate
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lazy Evaluation}

  \begin{itemize}
    \item eager evaluation evaluates arguments only once
    \item but it might evaluate arguments which are not needed

    \medskip
    \item normal order does not evaluate arguments which are not needed
    \item but it might evaluate others more than once

    \pause
    \medskip
    \item \alert{lazy evaluation}: evaluate an argument once\\
      when its value is \emph{first} needed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item most languages use eager evaluation
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
def first(x, y):
    return x

# first(1, 1 // 0) -> division by zero
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Haskell uses lazy evaluation by default
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
first :: Integer -> Integer -> Integer
first x y = x

-- first 1 (1 `div` 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Conditional Expressions}

\begin{frame}
  \frametitle{Short-Circuit Evaluation}

  \begin{definition}
    \alert{short-circuit evaluation}: evaluation stops
      as soon as result is determined
  \end{definition}

  \pause
  \begin{example}
    \pygment{c}{(a >= 0) && (b < 10)}\\
    -- 2nd clause not evaluated if a < 0

    \bigskip
    \pygment{c}{(a >= 0) || (b < 10)}\\
    -- 2nd clause not evaluated if a >= 0

    \pause
    \bigskip
    \pygment{c}{(a >= 0) || (b++ < 10)}\\
    -- dangerous if side effects are allowed
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Short-Circuit Evaluation}

  \begin{itemize}
    \item code might depend on short-circuit evaluation
  \end{itemize}

  \begin{example}[Java]
    \begin{pygments}{java}
// find the index of a key item in a list
index = 0;
while ((index < items.length) && (items[index] != key))
    index++;
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation Exercise}

  \begin{block}{Exercise (Haskell)}
    \begin{itemize}
      \item express short-circuited Boolean operators in terms of conditionals
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Short-Circuit Evaluation Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
and' :: Bool -> Bool -> Bool
and' x y = if x then y else False

or' :: Bool -> Bool -> Bool
or' x y = if x then True else y

not' :: Bool -> Bool
not' x = if x then False else True
    \end{pygments}
  \end{example}
\end{frame}

\section{Type Systems}

\subsection{Types}

\begin{frame}
  \frametitle{Types}

  \begin{definition}
    \alert{type}: set of values and operations on these values
  \end{definition}

  \pause
  \medskip
  \begin{itemize}
    \item scalar types: integer, floating-point, boolean, character, \ldots
    \item composite types: record, tuple, array, list, map, \ldots
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Haskell, list elements have to be of the same type
    \item tuple elements can be of different types
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
-- lists
[1,2,3,4]
["Monday","Tuesday","Wednesday","Thursday","Friday"]
[1,2,3,4,"Monday"]      -- invalid

-- tuples
(19,2,2013)
(19,"Feb",2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Parameters}

  \begin{itemize}
    \item tuple parameters are not the same as multiple parameters
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
roots :: (Double,Double,Double) -> (Double,Double)
roots (a,b,c) =
    let
        disc = b * b - 4 * a * c
        x1 = (-b + sqrt disc) / (2 * a)
        x2 = (-b - sqrt disc) / (2 * a)
    in
        (x1,x2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Scala, list elements have to be of the same type
    \begin{itemize}
      \item type is automatically reduced if necessary
    \end{itemize}
    \item tuple elements can be of different types
  \end{itemize}

  \begin{example}[Scala]
    \begin{pygments}{scala}
// lists
List(1, 2, 3, 4)
List("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
List(1, 2, 3, 4, "Monday")  // List[Any]

// tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Python, list and tuple elements can be of different types
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
# lists
[1, 2, 3, 4]
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
[1, 2, 3, 4, "Monday"]

# tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sets and Dictionaries}

  \begin{itemize}
    \item in Python, sets and dictionaries are built-in data types
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
# sets
{2, 5, 7, 5, 3}         # {2, 3, 5, 7}

# dictionaries
{"day": 19, "month": "Feb", "year": 2013}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutability}

  \begin{itemize}
    \item in Python, lists, sets and dictionaries are mutable
    \item tuples and strings are immutable
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymut]
a = [1, 2, 3]
a.append(4)
a
a[0] = 0
a
b = (1, 2, 3)
b[0] = 0
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item programmers have to be careful about references and copies
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymutref]
a = [1, 2, 3]
b = a
b[0] = 4
b
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable Reference Example}

  \begin{example}[Python]
    \begin{pyconsole}[pycopy]
import copy
a = [1, 2, [3, 4]]
b = copy.copy(a)
b[0] = 7
b[2][0] = 5
a
c = copy.deepcopy(a)
c[2][0] = 3
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b = copy.copy(a)|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow1}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b[0] = 7|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow2}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b[2][0] = 5|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow3}
  \end{center}
\end{frame}

\subsection{Type Checking}

\begin{frame}
  \frametitle{Type Checking}

  \begin{itemize}
    \item type checking aims to prevent operations that don't make sense
    \begin{itemize}
      \item example: does \pygment{python}{True + 41} make sense?
    \end{itemize}
    \item check type of operands before operation

    \pause
    \medskip
    \item \alert{strongly typed}:\\
      prohibit the application of any operation to any object\\
      that is not intended to support the operation
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static and Dynamic Typing}

  \begin{itemize}
    \item \alert{statically-typed}: check at compile-time
    \begin{itemize}
      \item variables and expressions have fixed types
    \end{itemize}

    \pause
    \bigskip
    \item \alert{dynamically-typed}: check at run-time
    \begin{itemize}
      \item variables and expressions do not have fixed types
      \item values have fixed types
    \end{itemize}
    \pause
    \item \emph{duck typing principle}:\\
      ``If it walks like a duck and it quacks like a duck,\\
      then it must be a duck.''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static vs Dynamic Typing}

  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{itemize}
      \item static typing:
      \begin{itemize}
        \item more efficient
        \item safer
        \item less flexible
      \end{itemize}
    \end{itemize}

    \pause
    \column{.5\textwidth}
    \begin{itemize}
      \item dynamic typing:
      \begin{itemize}
        \item uses more memory
        \item slower
        \item potentially unsafe
        \item greater flexibility
      \end{itemize}
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dynamic Typing Safety Example}

  \begin{example}[Python]
    \begin{pygments}{python}
birthYear = 1970
age = year - birthYear
if age > 40:
    birth_year = year - 40
print("I was born in %s." % birthYear)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Polymorphism}

  \begin{definition}
    \alert{polymorphism}:\\
      single body of code working with objects of multiple types
  \end{definition}

  \begin{itemize}
    \item dynamic typing supports \emph{implicit parametric polymorphism}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Java]
    \begin{pygments}{java}
List lst = new LinkedList();
lst.add(5);
lst.add(8.7);
lst.add("abc");

for (Object o : lst) {
    System.out.println(o);        // this works
    System.out.println(o + o);    // this is an error
}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Python]
    \begin{pygments}{python}
lst = []
lst.append(5)
lst.append(8.7)
lst.append("abc")

for o in lst:
    print(o + o)
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Type Inference}

\begin{frame}
  \frametitle{Type Inference}

  \begin{itemize}
    \item type of entity not explicitly stated
    \item inferred by the language processor

    \pause
    \medskip
    \item assign every binding a type such that type checking succeeds
    \item fail if no such assignment can be found
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
even' n = n `mod` 2 == 0
-- even' :: Integer -> Bool

evenMessage n = if even' n then "even" else "odd"
-- evenMessage :: Integer -> [Char]

evenMixed n = if even' n then "even" else False
-- type inference fails
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what are the types of the following functions?
    \end{itemize}

    \medskip
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y

piOrSecond x y = if x then 3.14159 else y

foo x y = if x then y else x + 1

second x y = y

choose x y z = if x then y else z
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y
-- shrink :: Bool -> Integer -> Integer -> Integer

piOrSecond x y = if x then 3.14159 else y
-- piOrSecond :: Bool -> Double -> Double

foo x y = if x then y else x + 1
-- type inference fails

second x y = y
-- second :: a -> b -> b

choose x y z = if x then y else z
-- choose :: Bool -> a -> a -> a
    \end{pygments}
  \end{example}
\end{frame}
%
% \section*{References}
%
% \begin{frame}
%   \frametitle{References}
%
%   \begin{block}{Required Reading: Abelson, Sussman}
%     \begin{itemize}
%       \item Chapter 1: Building Abstractions with Procedures
%       \begin{itemize}
%         \item 1.1. \alert{The Elements of Programming}
%       \end{itemize}
%     \end{itemize}
%   \end{block}
% \end{frame}

\end{document}
