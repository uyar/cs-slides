% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Expressions and Types}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[width=9.5cm]{shallow1}{shallow1}
\pgfdeclareimage[width=9.5cm]{shallow2}{shallow2}
\pgfdeclareimage[width=9.5cm]{shallow3}{shallow3}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Expressions and Functions}

\subsection{Expressions}

\begin{frame}
  \frametitle{Expressions}

  \begin{definition}
    \alert{expression}: a construct that will be \emph{evaluated} to yield a value
  \end{definition}

  \pause
  \medskip
  \begin{itemize}
    \item primitive expressions: elements that can not be decomposed\\
    \begin{itemize}
      \item literals, constants, variables
    \end{itemize}
    \item means of combination: building compound elements from simpler ones\\
    \begin{itemize}
      \item operators
    \end{itemize}
    \item means of abstraction: naming compound elements\\
      and manipulating them as units
    \begin{itemize}
      \item \alert{binding}: an association between an identifier and an entity
      \item \emph{environment}: a set of bindings
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{columns}[t]
    \column{.45\textwidth}
    \begin{block}{Haskell (GHCi)}
      \begin{pygments}{haskell}
let v = e
      \end{pygments}
    \end{block}

    \pause
    \column{.45\textwidth}
    \begin{block}{Haskell}
      \begin{pygments}{haskell}
let
    v1 = e1
    v2 = e2
    ...
in
    e
      \end{pygments}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Expression Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
Prelude> 6 * 7
42
Prelude> let r = 2.4
Prelude> 3.14159 * r * r
18.095558399999998
Prelude> let rate = 0.4 in 120.0 * rate
48.0
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{block}{Scala}
    \begin{pygments}{scala}
val v = e
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Scala]
    \begin{pygments}{scala}
scala> 6 * 7
res0: Int = 42

scala> val r = 2.4
r: Double = 2.4

scala> 3.14159 * r * r
res1: Double = 18.095558399999998
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{block}{Python}
    \begin{pygments}{python}
v = e
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Python]
    \begin{pygments}{python}
>>> 6 * 7
42
>>> r = 2.4
>>> 3.14159 * r * r
18.095558399999998
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Expression Evaluation}

  \begin{itemize}
    \item take the operator with the highest precedence
    \item evaluate its operands (note the recursion)
    \item apply the operator to the operands

    \pause
    \medskip
    \item a name is evaluated by replacing it with its definition
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Evaluation Example}

  \begin{example}
    \pygment{python}{(3.14159 * r) * r}

    \pause
    \medskip
    \pygment{python}{(3.14159 * 2.4) * r}

    \pause
    \medskip
    \pygment{python}{7.539815999999999 * 2.4}

    \pause
    \medskip
    \pygment{python}{18.095558399999998}
  \end{example}
\end{frame}

\subsection{Functions}

\begin{frame}
  \frametitle{Functions}

  \begin{itemize}
    \item in imperative PLs, the body of a function is a block
    \begin{itemize}
      \item special construct for sending the result back: \alert{return}
    \end{itemize}

    \pause
    \bigskip
    \item in functional PLs, the body of a function is an expression
    \begin{itemize}
      \item in Scala, the function body is a block\\
        where the last construct is an expression
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Parameters}

  \begin{itemize}
    \item \alert{formal parameter}: an identifier through which a function\\
      accesses an argument
    \begin{itemize}
      \item declared at function definition
    \end{itemize}

    \pause
    \medskip
    \item \alert{actual parameter}: an expression which yields an argument
    \begin{itemize}
      \item defined at function application
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
-- function signature
f :: t1 -> t2 -> ... -> tn -> tr

-- function body
f fp1 fp2 ... fpn = e

-- function call
f ap1 ap2 ... apn
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
square :: Integer -> Integer
square x = x * x

-- square 21 -> 441
-- square (2 + 5) -> 49

sum_of_squares :: Integer -> Integer -> Integer
sum_of_squares x y = square x + square y

-- sum_of_squares 3 4 -> 25
-- sum_of_squares (a + 1) (a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Haskell Prefix - Infix Notations}

  \begin{itemize}
    \item functions can be called in infix form within backquotes
    \item operators can be called in prefix form within parentheses
  \end{itemize}

  \begin{example}
    \begin{pygments}{haskell}
Prelude> div 7 2
3
Prelude> 7 `div` 2
3
Prelude> 7 / 2
3.5
Prelude> (/) 7 2
3.5
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Scala}
    \begin{pygments}{scala}
// function definition
def f(fp1: t1, fp2: t2, ..., fpn: tn): tr = e

def f(fp1: t1, fp2: t2, ..., fpn: tn): tr = {
    ...
    e
}

// function call
f(ap1, ap2, ..., apn)
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Examples}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def square(x: Int): Int = x * x

// square(21) -> 441
// square(2 + 5) -> 49

def sumOfSquares(x: Int, y: Int): Int =
    square(x) + square(y)

// sumOfSquares(3, 4) -> 25
// sumOfSquares(a + 1, a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Python}
    \begin{pygments}{python}
# function definition
def f(fp1, fp2, ..., fpn):
    ...
    return e

# function call
f(ap1, ap2, ..., apn)
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Examples}

  \begin{example}[Python]
    \begin{pygments}{python}
def square(x):
    return x * x

# square(21) -> 441
# square(2 + 5) -> 49

def sum_of_squares(x, y):
    return square(x) + square(y)

# sum_of_squares(3, 4) -> 25
# sum_of_squares(a + 1, a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Function Evaluation}

  \begin{itemize}
    \item evaluate all function arguments (left to right)
    \item replace the function application\\
      with the right-hand side of its definition
    \item replace the formal parameters of the function\\
      with the actual parameters

    \pause
    \bigskip
    \item \alert{substitution model}
    \begin{itemize}
      \item reduces an expression to a value
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Function Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{sum_of_squares(3, 4)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(4)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item \alert{eager evaluation}: first evaluate arguments\\
      and then apply the function to the resulting values\\
      (a.k.a. ``call by value'')

    \pause
    \medskip
    \item \alert{normal order evaluation}: do not evaluate arguments\\
      until their values are needed\\
      (a.k.a. ``call by name'')
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Normal Order Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + (2 + 2) * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Church-Rosser Property}

  \begin{itemize}
    \item eager and normal order evaluations\\
      yield the same result as long as:

    \bigskip
    \item there are no side effects
    \item all evaluations terminate
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lazy Evaluation}

  \begin{itemize}
    \item eager evaluation evaluates arguments only once
    \item but it might evaluate arguments which are not needed

    \pause
    \medskip
    \item normal order does not evaluate arguments which are not needed
    \item but it might evaluate others more than once

    \pause
    \medskip
    \item \alert{lazy evaluation}: evaluate an argument once\\
      when its value is \emph{first} needed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item most languages use eager evaluation
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
def first(x, y):
    return x

# first(1, 1 // 0) -> division by zero
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Haskell uses lazy evaluation by default
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
first :: Integer -> Integer -> Integer
first x y = x

-- first 1 (1 `div` 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Scala uses eager evaluation by default
    \item but programmer can specify normal order evaluation
  \end{itemize}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def first(x: Int, y: Int): Int = x

def first_normal(x: Int, y: => Int): Int = x

// first(1, 1 / 0) -> division by zero
// first_normal(1, 1 / 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Conditional Expressions}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{itemize}
    \item perform different operations depending on the result of a test
    \item an expression, not a statement
  \end{itemize}

  \pause
  \begin{block}{C}
    \begin{pygments}{c}
/* not: */
if (predicate)
    true_block;
else
    false_block;

/* instead: */
predicate ? true_expr : false_expr
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
if predicate then true_expr else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
absval :: Integer -> Integer
absval x = if x < 0 then -x else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Scala}
    \begin{pygments}{scala}
if (predicate) true_expr else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Scala]
    \begin{pygments}{scala}
def absval(x: Int): Int =
    if (x < 0) -x else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Python}
    \begin{pygments}{python}
true_expr if predicate else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Python]
    \begin{pygments}{python}
def absval(x):
    return -x if x < 0 else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation}

  \begin{definition}
    \alert{short-circuit evaluation}: evaluation stops
      as soon as result is determined
  \end{definition}

  \pause
  \begin{example}
    \pygment{c}{(a >= 0) && (b < 10)}\\
    -- 2nd clause not evaluated if a < 0

    \bigskip
    \pygment{c}{(a >= 0) || (b < 10)}\\
    -- 2nd clause not evaluated if a >= 0

    \pause
    \bigskip
    \pygment{c}{(a >= 0) || (b++ < 10)}\\
    -- dangerous if side effects are allowed
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Short-Circuit Evaluation}

  \begin{itemize}
    \item code might depend on short-circuit evaluation
  \end{itemize}

  \begin{example}[Java]
    \begin{pygments}{java}
// find the index of a key in a list
index = 0;
while ((index < listlen) && (list[index] != key))
    index = index + 1;
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item express short-circuited Boolean operators in terms of conditionals
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Short-Circuit Evaluation Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
and_ :: Bool -> Bool -> Bool
and_ x y = if x then y else False

or_ :: Bool -> Bool -> Bool
or_ x y = if x then True else y

not_ :: Bool -> Bool
not_ x = if x then False else True
    \end{pygments}
  \end{example}
\end{frame}

\section{Type Systems}

\subsection{Types}

\begin{frame}
  \frametitle{Types}

  \begin{definition}
    \alert{type}: set of values and the operations on these values
  \end{definition}

  \pause
  \medskip
  \begin{itemize}
    \item scalar types: integer, floating-point, boolean, character, \ldots
    \item composite types: record, tuple, array, list, map, \ldots
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Haskell, list elements have to be of the same type
    \item tuple elements can be of different types
  \end{itemize}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
-- lists
[1, 2, 3, 4]
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
[1, 2, 3, 4, "Monday"]  -- invalid

-- tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Haskell Function Parameters}

  \begin{itemize}
    \item using multiple parameters is not the same thing as using tuples
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
roots :: (Double, Double, Double) -> (Double, Double)
roots (a, b, c) =
    let
        disc = b * b - 4 * a * c
        x1 = (-b + sqrt disc) / (2 * a)
        x2 = (-b - sqrt disc) / (2 * a)
    in
        (x1, x2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Scala, list elements have to be of the same type
    \begin{itemize}
      \item might be automatically reduced if necessary
    \end{itemize}
    \item tuple elements can be of different types
  \end{itemize}

  \pause
  \begin{example}[Scala]
    \begin{pygments}{scala}
// lists
List(1, 2, 3, 4)
List("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
List(1, 2, 3, 4, "Monday")  // List[Any]

// tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Lists and Tuples}

  \begin{itemize}
    \item in Python, list and tuple elements can be of different types
  \end{itemize}

  \pause
  \begin{example}[Python]
    \begin{pygments}{python}
# lists
[1, 2, 3, 4]
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
[1, 2, 3, 4, "Monday"]

# tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sets and Dictionaries}

  \begin{itemize}
    \item in Python, sets and dictionaries are built-in data types
  \end{itemize}

  \pause
  \begin{example}[Python]
    \begin{pygments}{python}
# sets
{2, 5, 7, 5, 3}         # {2, 3, 5, 7}

# dictionaries
{"day": 19, "month": "Feb", "year": 2013}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutability}

  \begin{itemize}
    \item in Python, lists, sets and dictionaries are mutable
    \item tuples and strings are immutable
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymut]
a = [1, 2, 3]
a.append(4)
a
a[0] = 0
a
b = (1, 2, 3)
b[0] = 0
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item programmers have to be careful about references and copies
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymutref]
a = [1, 2, 3]
b = a
b[0] = 4
b
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable Reference Example}

  \begin{example}[Python]
    \begin{pyconsole}[pycopy]
import copy
a = [1, 2, [3, 4]]
b = copy.copy(a)
b[0] = 7
b[2][0] = 5
a
c = copy.deepcopy(a)
c[2][0] = 3
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b = copy.copy(a)|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow1}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b[0] = 7|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow2}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Mutable Reference Example}

  \begin{itemize}
    \item after \pyv|b[2][0] = 5|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow3}
  \end{center}
\end{frame}

\subsection{Type Checking}

\begin{frame}
  \frametitle{Type Checking}

  \begin{itemize}
    \item type checking aims to prevent operations that don't make sense
    \begin{itemize}
      \item example: does \pygment{python}{True + 15} make sense?
    \end{itemize}
    \item check type of operands before operation

    \pause
    \medskip
    \item \alert{strongly typed}:\\
      prohibit the application of any operation to any object\\
      that is not intended to support the operation
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static and Dynamic Typing}

  \begin{itemize}
    \item \alert{statically-typed}: check at compile-time
    \begin{itemize}
      \item variables and expressions have fixed types
    \end{itemize}

    \pause
    \bigskip
    \item \alert{dynamically-typed}: check at run-time
    \begin{itemize}
      \item variables and expressions do not have fixed types
      \item values have fixed types
    \end{itemize}
    \pause
    \item \emph{duck typing principle}:\\
      ``If it walks like a duck and it quacks like a duck,\\
      then it must be a duck.''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static vs Dynamic Typing}

  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{itemize}
      \item static typing:
      \begin{itemize}
        \item more efficient
        \item safer
        \item less flexible
      \end{itemize}
    \end{itemize}

    \pause
    \column{.5\textwidth}
    \begin{itemize}
      \item dynamic typing:
      \begin{itemize}
        \item uses more memory
        \item slower
        \item potentially unsafe
        \item greater flexibility
      \end{itemize}
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dynamic Typing Safety Example}

  \begin{example}[Python]
    \begin{pygments}{python}
birthYear = 1970
age = year - birthYear
if age > 40:
    birth_year = year - 40
print("I was born in %s." % birthYear)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Polymorphism}

  \begin{definition}
    \alert{polymorphism}:\\
      single body of code working with objects of multiple types
  \end{definition}

  \begin{itemize}
    \item dynamic typing supports \emph{implicit parametric polymorphism}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Java]
    \begin{pygments}{java}
List l = new LinkedList();
l.add(5);
l.add(8.7);
l.add("abc");

for (Object o : l) {
    System.out.println(o);        // this works
    System.out.println(o + o);    // this is an error
}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Python]
    \begin{pygments}{python}
l = []
l.append(5)
l.append(8.7)
l.append("abc")

for o in l:
    print(o + o)
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Type Inference}

\begin{frame}
  \frametitle{Type Inference}

  \begin{itemize}
    \item type of entity not explicitly stated
    \item inferred by the language processor

    \pause
    \medskip
    \item assign every binding a type such that type checking succeeds
    \item fail if no such assignment can be found
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
even_ n = n `mod` 2 == 0
-- even_ :: Integer -> Bool

evenMessage n = if even_ n then "even" else "odd"
-- evenMessage :: Integer -> [Char]

evenMixed n = if even_ n then "even" else False
-- type inference fails
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what are the types of the following functions?
    \end{itemize}

    \medskip
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y

yOrPi x y = if x then 3.14159 else y

foo x y = if x then y else x + 1

second x y = y

choose x y z = if x then y else z
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y
-- shrink :: Bool -> Integer -> Integer -> Integer

yOrPi x y = if x then 3.14159 else y
-- yOrPi :: Bool -> Double -> Double

foo x y = if x then y else x + 1
-- type inference fails

second x y = y
-- second :: a -> b -> b

choose x y z = if x then y else z
-- choose :: Bool -> a -> a -> a
    \end{pygments}
  \end{example}
\end{frame}
% 
% \section*{References}
% 
% \begin{frame}
%   \frametitle{References}
% 
%   \begin{block}{Required Reading: Abelson, Sussman}
%     \begin{itemize}
%       \item Chapter 1: Building Abstractions with Procedures
%       \begin{itemize}
%         \item 1.1. \alert{The Elements of Programming}
%       \end{itemize}
%     \end{itemize}
%   \end{block}
% \end{frame}

\end{document}
