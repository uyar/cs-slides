% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Expressions and Types}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[width=9.5cm]{shallow1}{shallow1}
\pgfdeclareimage[width=9.5cm]{shallow2}{shallow2}
\pgfdeclareimage[width=9.5cm]{shallow3}{shallow3}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Evaluation}

\subsection{Expressions}

\begin{frame}
  \frametitle{Expressions}

  \begin{definition}
    \alert{expression}: a construct that will be \emph{evaluated} to yield a value
  \end{definition}

  \pause
  \medskip
  \begin{itemize}
    \item primitive expressions: the simplest elements\\
    \begin{itemize}
      \item literals, constants, variables
    \end{itemize}
    \item means of combination: building compound elements from simpler ones\\
    \begin{itemize}
      \item operators
    \end{itemize}
    \item means of abstraction: naming compound elements\\
      and manipulating them as units
    \begin{itemize}
      \item \alert{binding}: an association between an identifier and an entity
      \item \emph{environment}: a set of bindings
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{block}{Haskell (GHCi)}
    \begin{pygments}{haskell}
let v = e
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
Prelude> 6 * 7
42
Prelude> let r = 2.4
Prelude> 3.14159 * r * r
18.095558399999998
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{block}{Scala}
    \begin{pygments}{scala}
val v = e
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Scala]
    \begin{pygments}{scala}
scala> 6 * 7
res0: Int = 42

scala> val r = 2.4
r: Double = 2.4

scala> 3.14159 * r * r
res1: Double = 18.095558399999998
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Bindings}

  \begin{block}{Python}
    \begin{pygments}{python}
v = e
    \end{pygments}
  \end{block}

  \pause
  \begin{example}[Python]
    \begin{pygments}{python}
>>> 6 * 7
42
>>> r = 2.4
>>> 3.14159 * r * r
18.095558399999998
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluating Expressions}

  \begin{itemize}
    \item take the operator with the highest precedence
    \item evaluate its operands (note the recursion)
    \item apply the operator to the operands

    \pause
    \medskip
    \item a name is evaluated by replacing it\\
      with the right-hand side of its definition
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluating Expressions}

  \begin{example}
    \pygment{python}{(3.14159 * r) * r}

    \pause
    \medskip
    \pygment{python}{(3.14159 * 2.4) * r}

    \pause
    \medskip
    \pygment{python}{7.539815999999999 * 2.4}

    \pause
    \medskip
    \pygment{python}{18.095558399999998}
  \end{example}
\end{frame}

\subsection{Functions}

\begin{frame}
  \frametitle{Functions}

  \begin{itemize}
    \item in imperative languages, the body of a function is a statement
    \begin{itemize}
      \item special construct for reporting back the result: \alert{return}
    \end{itemize}

    \pause
    \medskip
    \item in functional languages, the body of a function is an expression
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Parameters}

  \begin{itemize}
    \item \alert{formal parameter}: an identifier\\
      through which a function can access an argument
    \begin{itemize}
      \item declared at function definition
    \end{itemize}

    \pause
    \medskip
    \item \alert{actual parameter}: an expression which yields an argument
    \begin{itemize}
      \item defined at function application
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
-- function signature
f :: (t1, t2, ...) -> tr

-- function body
f (fp1, fp2, ...) = e

-- function call
f (ap1, ap2, ...)
    \end{pygments}
  \end{block}

  \pause
  \begin{itemize}
    \item convention in slides: if only 1 parameter, do not use parentheses
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
square :: Int -> Int
square x = x * x

-- square 21 -> 441
-- square (2 + 5) -> 49

sum_of_squares :: (Int, Int) -> Int
sum_of_squares (x, y) = square x + square y

-- sum_of_squares (3, 4) -> 25
-- sum_of_squares (a + 1, a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Scala}
    \begin{pygments}{scala}
// function definition
def f(fp1: t1, fp2: t2, ...): tr = e

// function call
f(ap1, ap2, ...)
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def square(x: Int): Int = x * x

// square(21) -> 441
// square(2 + 5) -> 49

def sumOfSquares(x: Int, y: Int): Int =
    square(x) + square(y)

// sumOfSquares(3, 4) -> 25
// sumOfSquares(a + 1, a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Function Bindings}

  \begin{block}{Python}
    \begin{pygments}{python}
# function definition
def f(fp1, fp2, ...):
    ...
    return e

# function call
f(ap1, ap2, ...)
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}

  \begin{example}[Python]
    \begin{pygments}{python}
def square(x):
    return x * x

# square(21) -> 441
# square(2 + 5) -> 49

def sum_of_squares(x, y):
    return square(x) + square(y)

# sum_of_squares(3, 4) -> 25
# sum_of_squares(a + 1, a * 2)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluating Functions}

  \begin{itemize}
    \item evaluate all function arguments (left to right)
    \item replace the function application\\
      with the right-hand side of its definition
    \item replace the formal parameters of the function\\
      with the actual parameters

    \pause
    \bigskip
    \item \alert{substitution model}
    \begin{itemize}
      \item reduces an expression to a value
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluating Functions}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{sum_of_squares(3, 4)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(4)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item \alert{applicative order evaluation}: first evaluate arguments\\
      and then apply the function to the resulting values\\
      (a.k.a. ``eager evaluation'', ``call by value'')

    \pause
    \medskip
    \item \alert{normal order evaluation}: do not evaluate arguments\\
      until their values are needed\\
      (a.k.a. ``call by name'')
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Normal Order Evaluation}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + (2 + 2) * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Church-Rosser Property}

  \begin{itemize}
    \item applicative order and normal order evaluations yield the same result\\
      as long as:

    \bigskip
    \item there are no side effects
    \item all evaluations terminate
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lazy Evaluation}

  \begin{itemize}
    \item applicative order evaluation evaluates arguments only once
    \item but it might evaluate arguments which are not needed

    \pause
    \medskip
    \item normal order does not evaluate arguments which are not needed
    \item but it might evaluate others more than once

    \pause
    \medskip
    \item \alert{lazy evaluation}: evaluate an argument once\\
      when its value is \emph{first} needed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item most languages use applicative order evaluation
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
def first(x, y):
    return x

# first(1, 1 / 0) -> division by zero
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Haskell uses lazy evaluation by default
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
first :: (Int, Int) -> Int
first (x, y) = x

-- first(1, 1 `div` 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Scala uses applicative order evaluation by default
    \item but programmer can specify normal order evaluation
  \end{itemize}

  \begin{example}[Scala]
    \begin{pygments}{scala}
def first(x: Int, y: Int) = x

def first_normal(x: Int, y: => Int) = x

// first(1, 1 / 0) -> division by zero
// first_normal(1, 1 / 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Conditional Expressions}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{itemize}
    \item perform different operations depending on the result of a test
    \item an expression, not a statement
  \end{itemize}

  \pause
  \begin{block}{C}
    \begin{pygments}{c}
/* not like: */
if (predicate)
    true_block;
else
    false_block;

/* instead: */
predicate ? true_expr : false_expr
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Haskell}
    \begin{pygments}{haskell}
if predicate then true_expr else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Haskell]
    \begin{pygments}{haskell}
absval :: Int -> Int
absval x = if x < 0 then -x else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Scala}
    \begin{pygments}{scala}
if (predicate) true_expr else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Scala]
    \begin{pygments}{scala}
def absval(x: Int): Int =
    if (x < 0) -x else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Conditional Expressions}

  \begin{block}{Python}
    \begin{pygments}{python}
true_expr if predicate else false_expr
    \end{pygments}
  \end{block}

  \pause
  \medskip
  \begin{example}[Python]
    \begin{pygments}{python}
def absval(x):
    return -x if x < 0 else x
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation}

  \begin{definition}
    \alert{short-circuit evaluation}: evaluation stops
      as soon as result is determined
  \end{definition}

  \pause
  \begin{example}
    \pygment{c}{(a >= 0) && (b < 10)}\\
    -- 2nd clause not evaluated if a < 0

    \bigskip
    \pygment{c}{(a >= 0) || (b < 10)}\\
    -- 2nd clause not evaluated if a >= 0
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Short-Circuit Evaluation}

  \begin{itemize}
    \item code might depend on short-circuit evaluation
  \end{itemize}

  \begin{example}[Java]
    \begin{pygments}{java}
// find the index of a key in a list
index = 0;
while ((index < listlen) && (list[index] != key))
    index = index + 1;
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation}

  \begin{block}{Exercise}
    \begin{itemize}
      \item express short-circuited Boolean operators in terms of conditionals
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Short-Circuit Evaluation}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
and_ :: (Bool, Bool) -> Bool
and_ (x, y) = if x then y else False

or_ :: (Bool, Bool) -> Bool
or_ (x, y) = if x then True else y

not_ :: Bool -> Bool
not_ x = if x then False else True
    \end{pygments}
  \end{example}
\end{frame}

\section{Types}

\subsection{Basic Types}

\begin{frame}
  \frametitle{Types}

  \begin{definition}
    \alert{type}:
    \begin{itemize}
      \item set of values
      \item operations on these values
    \end{itemize}
  \end{definition}

  \pause
  \medskip
  \begin{itemize}
    \item scalar types: integer, floating-point, boolean, character, \ldots
    \item composite types: record, tuple, array, list, map, \ldots
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Common Types}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
-- lists
[1, 2, 3, 4]
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
[1, 2, 3, 4, "Monday"]  -- invalid

-- tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}

  \pause
  \begin{itemize}
    \item \alert{NOTE}: for now, the functions we write in Haskell\\
      take only 1 parameter (which might be a tuple)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Common Types}

  \begin{example}[Scala]
    \begin{pygments}{scala}
// lists
List(1, 2, 3, 4)
List("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")
List(1, 2, 3, 4, "Monday")  // List[Any]

// tuples
(19, 2, 2013)
(19, "Feb", 2013)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Common Types}

  \begin{example}[Python]
    \begin{pygments}{python}
# lists
[1, 2, 3, 4]
["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
[1, 2, 3, 4, "Monday"]

# tuples
(19, 2, 2013)
(19, "Feb", 2013)

# sets
{2, 5, 7, 5, 3}         # {2, 3, 5, 7}

# dictionaries
{"day": 19, "month": "Feb", "year": 2013}
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutability}

  \begin{itemize}
    \item in Python, lists, sets and dictionaries are mutable
    \item tuples and strings are immutable
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymut]
a = [1, 2, 3]
a.append(4)
a
a[0] = 0
a
b = (1, 2, 3)
b[0] = 0
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item programmers have to be careful about identities and copies
  \end{itemize}

  \begin{example}[Python]
    \begin{pyconsole}[pymutref]
a = [1, 2, 3]
b = a
b[0] = 4
b
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{example}[Python]
    \begin{pyconsole}[pycopy]
import copy
a = [1, 2, [3, 4]]
b = copy.copy(a)
b[0] = 7
b[2][0] = 5
a
c = copy.deepcopy(a)
c[2][0] = 3
a
    \end{pyconsole}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item after \pyv|b = copy.copy(a)|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow1}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item after \pyv|b[0] = 7|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow2}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Mutable References}

  \begin{itemize}
    \item after \pyv|b[2][0] = 5|
  \end{itemize}

  \begin{center}
    \pgfuseimage{shallow3}
  \end{center}
\end{frame}

\subsection{Type Systems}

\begin{frame}
  \frametitle{Type Checking}

  \begin{itemize}
    \item prevent operations that don't make sense
    \begin{itemize}
      \item example: does \pygment{python}{True + 15} make sense?
    \end{itemize}
    \item check type of operands before operation

    \pause
    \medskip
    \item \alert{strongly typed}:\\
      prohibit the application of any operation to any object\\
      that is not intended to support the operation
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static vs Dynamic Typing}

  \begin{itemize}
    \item \alert{statically-typed}: check at compile-time
    \begin{itemize}
      \item variables and expressions have fixed types
    \end{itemize}

    \pause
    \bigskip
    \item \alert{dynamically-typed}: check at run-time
    \begin{itemize}
      \item variables and expressions do not have fixed types
      \item values have fixed types
    \end{itemize}
    \pause
    \item \emph{duck typing principle}:\\
      If it walks like a duck and it quacks like a duck,\\
      then it must be a duck.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Static vs Dynamic Typing}

  \begin{columns}[t]
    \column{.35\textwidth}
    \begin{itemize}
      \item static typing:
      \begin{itemize}
        \item more efficient
        \item more secure
        \item less flexible
      \end{itemize}
    \end{itemize}

    \pause
    \column{.65\textwidth}
    \begin{itemize}
      \item dynamic typing:
      \begin{itemize}
        \item requires tags: more memory
        \item poorer performance
        \item potentially unsafe
        \item greater flexibility
      \end{itemize}
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Dynamic Typing Problem}

  \begin{example}[Python]
    \begin{pygments}{python}
birthYear = 1970
age = year - birthYear
if age > 40:
    birth_year = year - 40
print("I was born in " + birthYear)
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Polymorphism}

  \begin{definition}
    \alert{polymorphism}:\\
      single body of code working with objects of multiple types
  \end{definition}

  \begin{itemize}
    \item dynamic typing supports \emph{implicit parametric polymorphism}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Java polymorphic list]
    \begin{pygments}{java}
List l = new LinkedList();
l.add(5);
l.add(8.7);
l.add("abc");

for (Object o : l)
  System.out.println(o + o);    // error
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Polymorphism Example}

  \begin{example}[Python polymorphic list]
    \begin{pygments}{python}
l = []
l.append(5)
l.append(8.7)
l.append("abc")

for o in l:
  print(o + o)
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Type Inference}

\begin{frame}
  \frametitle{Type Inference}

  \begin{itemize}
    \item type of entity not explicitly stated
    \item inferred by the language processor

    \pause
    \medskip
    \item give every binding/expression a type such that type checking succeeds
    \item fail if no solution exists
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
even_ n = n `mod` 2 == 0
-- even_ :: Int -> Bool

evenMessage n = if even_ n then "even" else "odd"
-- evenMessage :: Int -> [Char]

evenMixed n = if even_ n then "even" else False
-- fails type inference
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what are the types of the following functions?
    \end{itemize}

    \medskip
    \begin{pygments}{haskell}
shrink (x, y, z) = if x then y `div` z else y

yOrPi (x, y) = if x then 3.14159 else y

foo (x, y) = if x then y else x + 1

second (x, y) = y
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Type Inference}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
shrink (x, y, z) = if x then y `div` z else y
-- shrink :: (Bool, Int, Int) -> Int

yOrPi (x, y) = if x then 3.14159 else y
-- shrink :: (Bool, Double) -> Double

foo (x, y) = if x then y else x + 1
-- fails type inference

second (x, y) = y
-- second :: (a, b) -> b
    \end{pygments}
  \end{example}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Abelson, Sussman}
    \begin{itemize}
      \item Chapter 1: Building Abstractions with Procedures
      \begin{itemize}
        \item 1.1. \alert{The Elements of Programming}
      \end{itemize}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
