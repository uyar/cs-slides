% Copyright (c) 2013
%       H. Turgut Uyar <uyar@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}

\mode<presentation>
{
  \usetheme{Boadilla}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Expressions and Types}

\author{H. Turgut Uyar}
\date{2013}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[width=9.5cm]{shallow1}{shallow1}
\pgfdeclareimage[width=9.5cm]{shallow2}{shallow2}
\pgfdeclareimage[width=9.5cm]{shallow3}{shallow3}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2013 T. Uyar

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Expressions and Functions}

\subsection{Expressions}

\begin{frame}
  \frametitle{Expression Evaluation}

  \begin{itemize}
    \item take the operator with the highest precedence
    \item evaluate its operands (note the recursion)
    \item apply the operator to the operands

    \pause
    \medskip
    \item a name is evaluated by replacing it with its definition
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Evaluation Example}

  \begin{example}
    \pygment{python}{(3.14159 * r) * r}

    \pause
    \medskip
    \pygment{python}{(3.14159 * 2.4) * r}

    \pause
    \medskip
    \pygment{python}{7.539815999999999 * 2.4}

    \pause
    \medskip
    \pygment{python}{18.095558399999998}
  \end{example}
\end{frame}

\subsection{Functions}

\begin{frame}
  \frametitle{Function Evaluation}

  \begin{itemize}
    \item evaluate all function arguments (left to right)
    \item replace the function application\\
      with the right-hand side of its definition
    \item replace the formal parameters of the function\\
      with the actual parameters

    \pause
    \bigskip
    \item \alert{substitution model}
    \begin{itemize}
      \item reduces an expression to a value
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Function Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{sum_of_squares(3, 4)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(4)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + square(4)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item \alert{eager evaluation}: first evaluate arguments\\
      and then apply the function to the resulting values\\
      (a.k.a. ``call by value'')

    \pause
    \medskip
    \item \alert{normal order evaluation}: do not evaluate arguments\\
      until their values are needed\\
      (a.k.a. ``call by name'')
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Normal Order Evaluation Example}

  \begin{example}
    \pygment{python}{sum_of_squares(3, 2 + 2)}

    \pause
    \medskip
    \pygment{python}{square(3) + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{3 * 3 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + square(2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + (2 + 2) * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * (2 + 2)}

    \pause
    \medskip
    \pygment{python}{9 + 4 * 4}

    \pause
    \medskip
    \pygment{python}{9 + 16}

    \pause
    \medskip
    \pygment{python}{25}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Church-Rosser Property}

  \begin{itemize}
    \item eager and normal order evaluations yield the same result\\
      as long as:

    \bigskip
    \item there are no side effects
    \item all evaluations terminate
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Lazy Evaluation}

  \begin{itemize}
    \item eager evaluation evaluates arguments only once
    \item but it might evaluate arguments which are not needed

    \medskip
    \item normal order does not evaluate arguments which are not needed
    \item but it might evaluate others more than once

    \pause
    \medskip
    \item \alert{lazy evaluation}: evaluate an argument once\\
      when its value is \emph{first} needed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item most languages use eager evaluation
  \end{itemize}

  \begin{example}[Python]
    \begin{pygments}{python}
def first(x, y):
    return x

# first(1, 1 // 0) -> division by zero
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Evaluation Strategies}

  \begin{itemize}
    \item Haskell uses lazy evaluation by default
  \end{itemize}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
first :: Integer -> Integer -> Integer
first x y = x

-- first 1 (1 `div` 0) -> 1
    \end{pygments}
  \end{example}
\end{frame}

\subsection{Conditional Expressions}

\begin{frame}
  \frametitle{Short-Circuit Evaluation}

  \begin{definition}
    \alert{short-circuit evaluation}: evaluation stops
      as soon as result is determined
  \end{definition}

  \pause
  \begin{example}
    \pygment{c}{(a >= 0) && (b < 10)}\\
    -- 2nd clause not evaluated if a < 0

    \bigskip
    \pygment{c}{(a >= 0) || (b < 10)}\\
    -- 2nd clause not evaluated if a >= 0

    \pause
    \bigskip
    \pygment{c}{(a >= 0) || (b++ < 10)}\\
    -- dangerous if side effects are allowed
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Short-Circuit Evaluation}

  \begin{itemize}
    \item code might depend on short-circuit evaluation
  \end{itemize}

  \begin{example}[Java]
    \begin{pygments}{java}
// find the index of a key item in a list
index = 0;
while ((index < items.length) && (items[index] != key))
    index++;
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Short-Circuit Evaluation Exercise}

  \begin{block}{Exercise (Haskell)}
    \begin{itemize}
      \item express short-circuited Boolean operators in terms of conditionals
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Short-Circuit Evaluation Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
and' :: Bool -> Bool -> Bool
and' x y = if x then y else False

or' :: Bool -> Bool -> Bool
or' x y = if x then True else y

not' :: Bool -> Bool
not' x = if x then False else True
    \end{pygments}
  \end{example}
\end{frame}

\section{Type Systems}

\subsection{Type Inference}

\begin{frame}
  \frametitle{Type Inference}

  \begin{itemize}
    \item type of entity not explicitly stated
    \item inferred by the language processor

    \pause
    \medskip
    \item assign every binding a type such that type checking succeeds
    \item fail if no such assignment can be found
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
even' n = n `mod` 2 == 0
-- even' :: Integer -> Bool

evenMessage n = if even' n then "even" else "odd"
-- evenMessage :: Integer -> [Char]

evenMixed n = if even' n then "even" else False
-- type inference fails
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Inference Exercise}

  \begin{block}{Exercise}
    \begin{itemize}
      \item what are the types of the following functions?
    \end{itemize}

    \medskip
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y

piOrSecond x y = if x then 3.14159 else y

foo x y = if x then y else x + 1

second x y = y

choose x y z = if x then y else z
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Type Inference Examples}

  \begin{example}[Haskell]
    \begin{pygments}{haskell}
shrink x y z = if x then y `div` z else y
-- shrink :: Bool -> Integer -> Integer -> Integer

piOrSecond x y = if x then 3.14159 else y
-- piOrSecond :: Bool -> Double -> Double

foo x y = if x then y else x + 1
-- type inference fails

second x y = y
-- second :: a -> b -> b

choose x y z = if x then y else z
-- choose :: Bool -> a -> a -> a
    \end{pygments}
  \end{example}
\end{frame}

\end{document}
