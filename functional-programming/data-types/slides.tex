% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Data Types and Pattern Matching}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Data Types}

\subsection{Tuples}

\begin{frame}[fragile]
  \frametitle{Tuples}

  \begin{itemize}
    \item \alert{tuple}: a combination of a fixed number of values
      of fixed types
    \begin{block}{}
      \begin{pygments}{haskell}
name :: (t1, t2, ..., tn)
name = (v1,v2,...,vn)
      \end{pygments}
    \end{block}

    \medskip
    \item selector functions on pairs:\\
      \pygment{haskell}{fst}, \pygment{haskell}{snd}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Examples}

  \begin{exampleblock}{representing a term in a polynomial: $2.4x^2$}
    \begin{pygments}{haskell}
term1 :: (Float, Integer)
term1 = (2.4,2)

coeff1 = fst term1     -- 2.4
degree1 = snd term1    -- 2
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Parameters}

  \begin{itemize}
    \item tuple parameters are different from multiple parameters
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd1 :: Integer -> Integer -> Integer
gcd1 x y
  | y == 0    = x
  | otherwise = gcd1 y (x `mod` y)
-- call as: gcd1 9702 945

gcd2 :: (Integer, Integer) -> Integer
gcd2 a
  | snd a == 0 = fst a
  | otherwise  = gcd2 (snd a,(fst a) `mod` (snd a))
-- call as: gcd2 (9702,945)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Results}

  \begin{itemize}
    \item functions can return tuples
  \end{itemize}

  \begin{exampleblock}{example: greatest common divisor
                            and least common multiple}
    \begin{pygments}{haskell}
gcd_lcm :: Integer -> Integer -> (Integer, Integer)
gcd_lcm x y = (g, l)
  where
    gcd' :: Integer -> Integer -> Integer
    gcd' a b
      | b == 0    = a
      | otherwise = gcd' b (a `mod` b)

    g = gcd' x y
    l = (x * y) `div` g
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Lists}

\begin{frame}[fragile]
  \frametitle{Lists}

  \begin{itemize}
    \item \alert{list}: a combination of an arbitrary number of values,\\
      all of the same type
    \begin{block}{}
      \begin{pygments}{haskell}
name :: [t]
name = [v1,v2,...,vn]
      \end{pygments}
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{representing polynomials}
    \begin{pygments}{haskell}
-- second degree polynomial
p1 :: (Float, Float, Float)
p1 = (2.4,1.8,-4.6)

-- any degree polynomial, coefficients ordered
p2 :: [Float]
p2 = [2.4,1.8,-4.6]

-- any degree polynomial
p3 :: [(Float, Integer)]
p3 = [(1.8,1),(-4.6,0),(2.4,2)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type Synonyms}

  \begin{block}{type synonyms}
    \begin{pygments}{haskell}
type newName = oldName
    \end{pygments}
  \end{block}

  \begin{exampleblock}{example: representing polynomials}
    \begin{pygments}{haskell}
type Term = (Float, Integer)
type Polynomial = [Term]

p4 :: Polynomial
p4 = [(1.8,1),(-4.6,0),(2.4,2)]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Lists}

  \begin{itemize}
    \item a list consists of a first item (\alert{head})\\
      followed by a list of the remaining items (\alert{tail})

  \medskip
    \item basic list operations:
      \begin{itemize}
        \item check if empty: \pygment{haskell}{null}
        \item get the head: \pygment{haskell}{head}
        \item get the tail: \pygment{haskell}{tail}
        \item construct a list: \pygment{haskell}{item : sublist}
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Operation Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
-- null :: [a] -> Bool
null []        -- True
null [1,2,3,4] -- False

-- head :: [a] -> a
head [1,2,3,4] -- 1
head []        -- error

-- tail :: [a] -> [a]
tail [1,2,3,4] -- [2,3,4]
tail []        -- error
tail [1]       -- []

-- (:) :: a -> [a] -> [a]
1 : [2,3]      -- [1,2,3]
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{number of elements}
    \begin{pygments}{haskell}
length1 :: [a] -> Integer
length1 xs
  | null xs   = 0
  | otherwise = 1 + length1 (tail xs)
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: write a tail recursive version
    \item exercise: sum of elements
    \item exercise: sum of the first two elements
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{number of elements}
    \begin{pygments}{haskell}
length1' :: [a] -> Integer
length1' xs = lengthIter 0 xs
  where
    lengthIter :: Integer -> [a] -> Integer
    lengthIter acc xs'
      | null xs' = acc
      | otherwise = lengthIter (acc + 1) (tail xs')
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{sum of elements}
    \begin{pygments}{haskell}
sum' :: [Integer] -> Integer
sum' xs
  | null xs   = 0
  | otherwise = head xs + sum' (tail xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{List Example}

  \begin{exampleblock}{sum of first two elements}
    \begin{pygments}{haskell}
firstPlusSecond :: [Integer] -> Integer
firstPlusSecond xs
  | null xs        = 0
  | null (tail xs) = head xs
  | otherwise      = head xs + head (tail xs)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Algebraic Types}

\begin{frame}[fragile]
  \frametitle{Algebraic Types}

  \begin{itemize}
    \item algebraic types can be used to define:
    \begin{itemize}
      \item enumerated types
      \item product types
      \item alternatives
    \end{itemize}
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
data Name = Constructor_1 t_1_1 t_1_2 ... |
            Constructor_2 t_2_1 t_2_2 ... |
            ...
            Constructor_n t_n_1 t_n_2 ...
    \end{pygments}
  \end{block}

  \begin{itemize}
    \item value construction:\\
      \pygment{haskell}{Constructor_i v_i_1 v_i_2 ...}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Enumerated Types}

  \begin{itemize}
    \item enumerated type: no components in constructors
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Month = Jan | Feb | Mar | Apr | May | Jun |
             Jul | Aug | Sep | Oct | Nov | Dec
             deriving Show

currentMonth :: Month
currentMonth = Feb
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Product Types}

  \begin{itemize}
    \item product type: one constructor with multiple components
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Pioneer = Person String Integer
               deriving Show
-- constructor: Person
-- components: name (String), birth year (Integer)

church :: Pioneer
church = Person "Alonzo Church" 1903

type Name = String
type BirthYear = Integer
data Pioneer = Person Name BirthYear
               deriving Show
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Alternative Types}

  \begin{itemize}
    \item alternative type: multiple constructors
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Shape = Point |
             Circle Float |
             Rectangle Float Float
             deriving Show

center, hole, box :: Shape
center = Point
hole = Circle 3.0
box = Rectangle 45.9 87.6
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section{Pattern Matching}

\subsection{Function Parameters}

\begin{frame}[fragile]
  \frametitle{Pattern Matching}

  \begin{itemize}
    \item formal parameters are patterns
    \item components of the pattern will be matched\\
      with the components of the actual parameters
    \item a matched pattern generates bindings
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd1 :: Integer -> Integer -> Integer
gcd1 x y
  | y == 0    = x
  | otherwise = gcd1 y (x `mod` y)

-- if called as: gcd1 9702 945
-- bindings: x <-> 9702, y <-> 945
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multiple Patterns}

  \begin{itemize}
    \item in case of multiple patterns, the first match will be selected
    \item patterns can contain literals
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
name p1 = e1
name p2 = e2
...
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Multiple Pattern Examples}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fact :: Integer -> Integer
fact 0 = 1
fact n = n * fact (n - 1)

gcd3 :: Integer -> Integer -> Integer
gcd3 x 0 = x
gcd3 x y = gcd3 y (x `mod` y)

-- if called as: gcd3 9702 945
-- second pattern, bindings: x <-> 9702, y <-> 945

-- if called as: gcd3 63 0
-- first pattern, bindings: x <-> 63
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuple Patterns}

  \begin{itemize}
    \item tuple selector functions work only with pairs
    \item pattern matching works with any tuple
    \item it is also more readable
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd2 :: (Integer, Integer) -> Integer
gcd2 a
  | snd a == 0 = fst a
  | otherwise  = gcd2 (snd a,(fst a) `mod` (snd a))

gcd4 :: (Integer, Integer) -> Integer
gcd4 (x,0) = x
gcd4 (x,y) = gcd4 (y,x `mod` y)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Tuple Pattern Example}

  \begin{exampleblock}{efficient Fibonacci calculation}
    \begin{pygments}{haskell}
-- fibPair n = (fib n,fib (n + 1))

fibStep :: (Integer, Integer) -> (Integer, Integer)
fibStep (u,v) = (v,u+v)

fibPair :: Integer -> (Integer, Integer)
fibPair n
  | n == 1    = (1,1)
  | otherwise = fibStep (fibPair (n - 1))

fastFib n = fst (fibPair n)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Nested Patterns}

  \begin{itemize}
    \item patterns can be nested
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
shift :: ((Integer, Integer), Integer)
            -> (Integer, (Integer, Integer))
shift ((x,y),z) = (x,(y,z))
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Wildcards}

  \begin{itemize}
    \item if binding is not needed, use wildcard: \pygment{haskell}{_}
  \end{itemize}

  \begin{exampleblock}{third component of a triple}
    \begin{pygments}{haskell}
third :: (a, b, c) -> c

-- instead of the following:
third (x,y,z) = z

-- write the following:
third (_,_,z) = z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{List Patterns}

\begin{frame}[fragile]
  \frametitle{List Patterns}

  \begin{itemize}
    \item empty list:\\
      \pygment{haskell}{[]}
    \item nonempty list:\\
      \pygment{haskell}{x:xs}
    \item list with exactly one element:\\
      \pygment{haskell}{[x]}\\
      \pygment{haskell}{x:[]}
    \item list with exactly two elements:\\
      \pygment{haskell}{[x1,x2]}\\
      \pygment{haskell}{x1:x2:[]}
    \item list with at least two elements:\\
      \pygment{haskell}{x1:x2:xs}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{exampleblock}{number of elements}
    \begin{pygments}{haskell}
length2 :: [a] -> Integer
length2 [] = 0
length2 (x:xs) = 1 + length2 xs
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{List Pattern Examples}

  \begin{exampleblock}{add the first and third elements of a list}
    \begin{pygments}{haskell}
firstPlusThird :: [Integer] -> Integer
firstPlusThird [] = 0
firstPlusThird [x1] = x1
firstPlusThird [x1,_] = x1
firstPlusThird (x1:_:x3:_) = x1 + x3
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Algebraic Type Patterns}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Patterns}

  \begin{itemize}
    \item pattern matching to get values out of algebraic types
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Pioneer = Person String Integer
               deriving Show

birthYear :: Pioneer -> Integer
birthYear (Person _ y) = y

church :: Pioneer
church = Person "Alonzo Church" 1903

birthYear church    -- 1903
-- binding: y <-> 1903
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algebraic Type Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Shape = Point |
             Circle Float |
             Rectangle Float Float
             deriving Show

area :: Shape -> Float
area Point = 0.0
area (Circle r) = 3.14159 * r * r
area (Rectangle h w) = h * w

hole :: Shape
hole = Circle 3.0

area hole    -- 28.274311
-- second pattern, binding: r <-> 3.0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{itemize}
    \item algebraic types give you better type checking
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
type Rational1 = (Integer, Integer)

simplify1 :: Rational1 -> Rational1
simplify1 (n, d) = (n `div` g, d `div` g)
  where
    g = gcd n d

type DayInYear = (Integer, Integer)

mar12 :: DayInYear
mar12 = (12,3)
-- simplify1 mar12: (4,1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tuples or Algebraic Types?}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
data Rational2 = Rational Integer Integer
                 deriving Show

simplify2 :: Rational2 -> Rational2
simplify2 (Rational n d) =
  Rational (n `div` g) (d `div` g)
    where
      g = gcd n d
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Case Expressions}

\begin{frame}[fragile]
  \frametitle{Pattern Matching}

  \begin{itemize}
    \item patterns can also be handled in case expressions
    \item the result is the expression for the first matched pattern
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
case v of
  p1 -> e1
  p2 -> e2
  ...
  pn -> en
  _ -> e
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Expression Examples}

  \begin{example}[number of days in a month]
    \begin{pygments}{haskell}
daysInMonth :: Month -> Integer -> Integer
daysInMonth m y =
    case m of
      Apr -> 30
      Jun -> 30
      Sep -> 30
      Nov -> 30
      Feb -> if y `mod` 4 == 0 then 29 else 28
      _ -> 31

daysInMonth Jan 2014 -- 31
daysInMonth Feb 2014 -- 28
daysInMonth Feb 2016 -- 29
    \end{pygments}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Expression Example}

  \begin{exampleblock}{playing cards}
    \begin{pygments}{haskell}
data Suit = Club | Diamond | Heart | Spade
            deriving Show

data Rank = Jack | Queen | King | Ace | Number Integer
            deriving Show

type Card = (Suit, Rank)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Expression Example}

  \begin{exampleblock}{color of a card}
    \begin{pygments}{haskell}
data Color = Red | Black
             deriving Show

cardColor :: Card -> Color
cardColor card =
    case card of
      (Club,_) -> Black
      (Diamond,_) -> Red
      (Heart,_) -> Red
      (Spade,_) -> Black
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{itemize}
    \item exercise: write a function that will return the value of a card
  \end{itemize}
\end{frame}

\begin{frame}<beamer>[fragile]
  \frametitle{Algebraic Type Example}

  \begin{exampleblock}{value of a card}
    \begin{pygments}{haskell}
cardValue :: Card -> Integer
cardValue card =
    case card of
      (_,Ace) -> 11
      (_,King) -> 10
      (_,Queen) -> 10
      (_,Jack) -> 10
      (_,Number n) -> n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 5: \alert{Data types, tuples and lists}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
