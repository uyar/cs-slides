% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{pythontex}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Recursion}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\pgfdeclareimage[height=6cm]{fib}{fib}

\begin{document}

\setpythontexfv[]{frame=single}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Functions}

\subsection{Infix and Prefix Notations}

\begin{frame}[fragile]
  \frametitle{Infix Functions}

  \begin{itemize}
    \item function calls can be written in infix notation within backquotes
  \end{itemize}

  \begin{exampleblock}{example: the \pygment{haskell}{mod} function}
    \begin{pygments}{haskell}
even :: Integer -> Bool
even n = mod n 2 == 0

-- OR:
even :: Integer -> Bool
even n = n `mod` 2 == 0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prefix Operators}

  \begin{itemize}
    \item operator calls can be written in prefix notation within parentheses
  \end{itemize}

  \begin{exampleblock}{example: the \pygment{haskell}{*} operator}
    \begin{pygments}{haskell}
even :: Integer -> Bool
even n = (n `div` 2 ) * 2 == n

-- OR:
even :: Integer -> Bool
even n = (*) (div n 2) 2 == n

-- OR:
even :: Integer -> Bool
even n = (==) ((*) (div n 2) 2) n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Guards}

\begin{frame}[fragile]
  \frametitle{Guards}

  \begin{itemize}
    \item writing conditional expressions can become complicated
    \item \alert{guards}: Boolean expressions to check cases
      in function definitions
    \item function result is the expression for the first valid guard
  \end{itemize}

  \begin{block}{}
    \begin{pygments}{haskell}
name :: t1 -> t2 -> ... -> tk -> t
name x1 x2 ... xk
  | g1        = e1
  | g2        = e2
    ...
  | otherwise = e
    \end{pygments}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guard Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
maxThree :: Integer -> Integer -> Integer -> Integer
maxThree x y z
  | x >= y && x >= z = x
  | y >= z           = y
  | otherwise        = z
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Errors}

\begin{frame}[fragile]
  \frametitle{Errors}

  \begin{itemize}
    \item errors can be reported using \pygment{haskell}{error}
  \end{itemize}

  \begin{exampleblock}{example: reciprocal (multiplicative inverse)}
    \begin{pygments}{haskell}
reciprocal :: Float -> Float
reciprocal x
  | x == 0    = error "zero does not have a reciprocal"
  | otherwise = 1.0 / x
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section{Recursion}

\subsection{Primitive Recursion}

\begin{frame}[fragile]
  \frametitle{Recursion Examples}

  \begin{exampleblock}{greatest common divisor}
    \begin{pygments}{haskell}
gcd :: Integer -> Integer -> Integer
gcd x y = if y == 0 then x else gcd y (x `mod` y)
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{factorial}
    \begin{pygments}{haskell}
fac :: Integer -> Integer
fac n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fac (n - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd x y = if y == 0 then x else gcd y (x `mod` y)
    \end{pygments}

    \pause
    \pygment{haskell}{gcd 9702 945}\\
    $\rightsquigarrow$ \pygment{haskell}{gcd 945 252}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{gcd 252 189}\\
    \hspace{32pt}$\rightsquigarrow$ \pygment{haskell}{gcd 189 63}\\
    \hspace{48pt}$\rightsquigarrow$ \pygment{haskell}{gcd 63 0}\\
    \hspace{64pt}$\rightsquigarrow$ \pygment{haskell}{63}\\
    \hspace{48pt}$\rightsquigarrow$ \pygment{haskell}{63}\\
    \hspace{32pt}$\rightsquigarrow$ \pygment{haskell}{63}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{63}\\
    $\rightsquigarrow$ \pygment{haskell}{63}\\
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fac n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fac (n - 1)
    \end{pygments}

    \pygment{haskell}{fac 4}\\
    $\rightsquigarrow$ \pygment{haskell}{4 * fac 3}\\
    \hspace{38pt}$\rightsquigarrow$ \pygment{haskell}{3 * fac 2}\\
    \hspace{76pt}$\rightsquigarrow$ \pygment{haskell}{2 * fac 1}\\
    \hspace{114pt}$\rightsquigarrow$ \pygment{haskell}{1 * fac 0}\\
    \hspace{152pt}$\rightsquigarrow$ \pygment{haskell}{1}\\
    \hspace{114pt}$\rightsquigarrow$ \pygment{haskell}{1}\\
    \hspace{76pt}$\rightsquigarrow$ \pygment{haskell}{2}\\
    \hspace{38pt}$\rightsquigarrow$ \pygment{haskell}{6}\\
    $\rightsquigarrow$ \pygment{haskell}{24}\\
  \end{exampleblock}
\end{frame}

\subsection{Tail Recursion}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item if the result of the recursive call is also the result of the caller,\\
      then the function is said to be \alert{tail recursive}
    \item the recursive function call is the last action:\\
      nothing left for the caller to do

    \pause
    \medskip
    \item no need to keep the stack frame around\\
      $\rightarrow$ reuse the frame of the caller
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
gcd x y = if y == 0 then x else gcd y (x `mod` y)
    \end{pygments}

    \pygment{haskell}{gcd 9702 945}\\
    $\rightsquigarrow$ \pygment{haskell}{gcd 945 252}\\
    $\rightsquigarrow$ \pygment{haskell}{gcd 252 189}\\
    $\rightsquigarrow$ \pygment{haskell}{gcd 189 63}\\
    $\rightsquigarrow$ \pygment{haskell}{gcd 63 0}\\
    $\rightsquigarrow$ \pygment{haskell}{63}\\
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item to rearrange a function to be tail recursive:

    \medskip
    \item define a helper function that takes an \alert{accumulator}
    \item base case: return accumulator
    \item recursive case: make recursive call with new accumulator value
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
facIter :: Integer -> Integer -> Integer
facIter acc n
  | n < 0     = error "negative parameter"
  | n == 0    = acc
  | otherwise = facIter (acc * n) (n - 1)

fac :: Integer -> Integer
fac n = facIter 1 n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
facIter acc n
  | n < 0     = error "negative parameter"
  | n == 0    = acc
  | otherwise = facIter (acc * n) (n - 1)
    \end{pygments}

    \pygment{haskell}{fac 4}\\
    $\rightsquigarrow$ \pygment{haskell}{facIter 1 4}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{facIter 4 3}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{facIter 12 2}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{facIter 24 1}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{facIter 24 0}\\
    \hspace{16pt}$\rightsquigarrow$ \pygment{haskell}{24}\\
    $\rightsquigarrow$ \pygment{haskell}{24}\\
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{itemize}
    \item the helper function doesn't need to be visible
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fac :: Integer -> Integer
fac n
  | n < 0     = error "negative parameter"
  | otherwise = facIter 1 n
      where
        facIter :: Integer -> Integer -> Integer
        facIter acc n'
          | n' == 0   = acc
          | otherwise = factter (acc * n') (n' - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\subsection{Tree Recursion}

\begin{frame}[fragile]
  \frametitle{Tree Recursion}

  \begin{itemize}
    \item another classic example: the Fibonacci sequence
    \[
      fib_n =
        \begin{cases}
          1                     & \mbox{if } n = 1\\
          1                     & \mbox{if } n = 2\\
          fib_{n-2} + fib_{n-1} & \mbox{if } n > 2
        \end{cases}
    \]
  \end{itemize}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
fib :: Integer -> Integer
fib n
  | n == 1    = 1
  | n == 2    = 1
  | otherwise = fib (n - 2) + fib (n - 1)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{center}
    \pgfuseimage{fib}
  \end{center}
\end{frame}

\subsection{Examples}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{exponentiation}
    \begin{itemize}
      \item compute $x^y$ where $y \in \mathbb{N}$
    \end{itemize}

    \smallskip
    \begin{pygments}{haskell}
pow :: Integer -> Integer -> Integer
pow x y
  | y == 0    = 1
  | otherwise = x * pow x (y - 1)
    \end{pygments}

    \pause
    \begin{itemize}
      \item use the following definition:
    \end{itemize}
    \[
      x^y =
        \begin{cases}
          1               & \mbox{if y = 0}\\
          {(x^{y/2})}^2   & \mbox{if y is even}\\
          x \cdot x^{y-1} & \mbox{if y is odd}
        \end{cases}
    \]
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{fast exponentiation}
    \begin{pygments}{haskell}
fastPow :: Integer -> Integer -> Integer
fastPow x y
  | y == 0    = 1
  | even y    = sqr (fastPow x (y `div` 2))
  | otherwise = x * fastPow x (y - 1)
  where
    sqr :: Integer -> Integer
    sqr n = n * n
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}
  \frametitle{Recursion Example}

  \begin{exampleblock}{square roots with Newton's method}
    \begin{itemize}
      \item start with an initial guess $y$ (say $y = 1$)
      \item repeatedly improve the guess by taking the mean of $y$
        and $x / y$
      \item until the guess is good enough ($\sqrt x \cdot \sqrt x = x$)
    \end{itemize}

    \begin{center}
      \begin{tabular}{lll}
      $y$      & $x / y$             & next guess\\\hline
      1        & 2 / 1 = 2           & 1.5\\
      1.5      & 2 / 1.5 = 1.333     & 1.4167\\
      1.4167   & 2 / 1.4167 = 1.4118 & 1.4142\\
      1.4142   & ...                 & ...
      \end{tabular}
    \end{center}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{itemize}
    \item goal: $guess = \sqrt x$
    \item if guess is good enough: $|guess \cdot guess - x| < \epsilon$
  \end{itemize}

  \pause
  \begin{exampleblock}{check whether the guess is good enough}
    \begin{pygments}{haskell}
isGoodEnough :: Float -> Float -> Bool
isGoodEnough guess x = abs (guess * guess - x) < 0.001
    \end{pygments}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{improve the guess}
    \begin{pygments}{haskell}
improve :: Float -> Float -> Float
improve guess x = (guess + (x / guess)) / 2.0
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{iterative computation}
    \begin{pygments}{haskell}
newtonIter :: Float -> Float -> Float
newtonIter guess x
  | isGoodEnough guess x = guess
  | otherwise            =
        newtonIter (improve guess x) x

newton :: Float -> Float
newton x = newtonIter 1.0 x
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{}
    \begin{pygments}{haskell}
newton :: Float -> Float
newton x = newtonIter 1.0 x
  where
    isGoodEnough :: Float -> Float -> Bool
    isGoodEnough guess x' =
        abs (guess * guess - x') < 0.001

    improve :: Float -> Float -> Float
    improve guess x' = (guess + (x' / guess)) / 2.0

    newtonIter :: Float -> Float -> Float
    newtonIter guess x'
      | isGoodEnough guess x' = guess
      | otherwise             =
          newtonIter (improve guess x') x'
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{}
    \begin{itemize}
      \item doesn't work with too small and too large numbers (why?)
    \end{itemize}

    \pause
    \smallskip
    \begin{pygments}{haskell}
isGoodEnough guess x' =
    (abs (guess * guess - x')) / x' < 0.001
    \end{pygments}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{}
    \begin{itemize}
      \item no need to pass \pygment{haskell}{x} around, it's already in scope
    \end{itemize}

    \pause
    \smallskip
    \begin{pygments}{haskell}
newton x = newtonIter 1.0
  where
    isGoodEnough :: Float -> Bool
    isGoodEnough guess =
        (abs (guess * guess - x)) / x < 0.001

    improve :: Float -> Float
    improve guess = (guess + (x / guess)) / 2.0

    newtonIter :: Float -> Float
    newtonIter guess
      | isGoodEnough guess = guess
      | otherwise          = newtonIter (improve guess)
    \end{pygments}
  \end{exampleblock}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 3: \alert{Basic types and definitions}
      \item Chapter 4: \alert{Designing and writing programs}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
