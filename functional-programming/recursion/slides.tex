% Copyright (c) 2013-2014 H. Turgut Uyar <uyar@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\usepackage{listings}
\lstset{basicstyle=\ttfamily, keywordstyle=\color{blue},
        showstringspaces=false, frame=ltrb}
\lstset{language=haskell, deletekeywords={even,gcd}}

\mode<presentation>
{
  \usetheme{default}
  \useinnertheme{rounded}
  \usecolortheme{seahorse}
  \setbeamercovered{transparent}
}

\title{Functional Programming}
\subtitle{Recursion}

\author{H. Turgut Uyar}
\date{2013-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[height=1cm]{license}{../license}

\pgfdeclareimage[height=6cm]{fib}{fib}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2013-2014 H. Turgut Uyar

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Functions}

\subsection{Infix - Prefix}

\begin{frame}[fragile]
  \frametitle{Infix Functions}

  \begin{itemize}
    \item function calls can be written in infix notation within backquotes
  \end{itemize}

  \begin{exampleblock}{example: \lstinline{mod} function}
    \begin{lstlisting}
even :: Integer -> Bool
even n = mod n 2 == 0

-- OR:
even :: Integer -> Bool
even n = n `mod` 2 == 0
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prefix Operators}

  \begin{itemize}
    \item operator calls can be written in prefix notation within parentheses
  \end{itemize}

  \begin{exampleblock}{example: \lstinline{*} operator}
    \begin{lstlisting}
even :: Integer -> Bool
even n = (n `div` 2 ) * 2 == n

-- OR:
even :: Integer -> Bool
even n = (*) (div n 2) 2 == n

-- OR:
even :: Integer -> Bool
even n = (==) ((*) (div n 2) 2) n
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\subsection{Guards}

\begin{frame}[fragile]
  \frametitle{Guards}

  \begin{itemize}
    \item writing conditional expressions can become complicated
    \item \alert{guards}: Boolean expressions to check cases
      in function definitions
    \item function result is the expression for the first valid guard
  \end{itemize}

  \begin{block}{}
    \begin{lstlisting}
n :: t1 -> t2 -> ... -> tk -> t
n x1 x2 ... xk
  | g1        = e1
  | g2        = e2
    ...
  | otherwise = e
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Guard Example}

  \begin{lstlisting}
maxThree :: Integer -> Integer -> Integer -> Integer
maxThree x y z
  | x >= y && x >= z = x
  | y >= z           = y
  | otherwise        = z
  \end{lstlisting}
\end{frame}

\subsection{Errors}

\begin{frame}[fragile]
  \frametitle{Errors}

  \begin{itemize}
    \item errors can be reported using \lstinline{error}
  \end{itemize}

  \begin{exampleblock}{example: reciprocal (multiplicative inverse)}
    \begin{lstlisting}
reciprocal :: Float -> Float
reciprocal x
  | x == 0    = error "zero does not have a reciprocal"
  | otherwise = 1.0 / x
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{Recursion}

\subsection{Primitive Recursion}

\begin{frame}[fragile]
  \frametitle{Recursion Examples}

  \begin{itemize}
    \item two classic examples
  \end{itemize}

  \begin{exampleblock}{greatest common divisor}
    \begin{lstlisting}
gcd :: Integer -> Integer -> Integer
gcd x y = if y == 0 then x else gcd y (x `mod` y)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}{factorial}
    \begin{lstlisting}
fac :: Integer -> Integer
fac n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fac (n-1)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{lstlisting}
gcd x y = if y == 0 then x else gcd y (x `mod` y)
  \end{lstlisting}

  \lstinline{gcd 9702 945}\\
  $\rightsquigarrow$ \lstinline{gcd 945 252}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{gcd 252 189}\\
  \hspace{32pt}$\rightsquigarrow$ \lstinline{gcd 189 63}\\
  \hspace{48pt}$\rightsquigarrow$ \lstinline{gcd 63 0}\\
  \hspace{64pt}$\rightsquigarrow$ \lstinline{63}\\
  \hspace{48pt}$\rightsquigarrow$ \lstinline{63}\\
  \hspace{32pt}$\rightsquigarrow$ \lstinline{63}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{63}\\
  $\rightsquigarrow$ \lstinline{63}\\
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{lstlisting}
fac n
  | n < 0     = error "negative parameter"
  | n == 0    = 1
  | otherwise = n * fac (n-1)
  \end{lstlisting}

  \lstinline{fac 4}\\
  $\rightsquigarrow$ \lstinline{4 * fac 3}\\
  \hspace{38pt}$\rightsquigarrow$ \lstinline{3 * fac 2}\\
  \hspace{76pt}$\rightsquigarrow$ \lstinline{2 * fac 1}\\
  \hspace{114pt}$\rightsquigarrow$ \lstinline{1 * fac 0}\\
  \hspace{152pt}$\rightsquigarrow$ \lstinline{1}\\
  \hspace{114pt}$\rightsquigarrow$ \lstinline{1}\\
  \hspace{76pt}$\rightsquigarrow$ \lstinline{2}\\
  \hspace{38pt}$\rightsquigarrow$ \lstinline{6}\\
  $\rightsquigarrow$ \lstinline{24}\\
\end{frame}

\subsection{Tail Recursion}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item if the result of the recursive call is also the result of the caller,\\
      then the function is said to be \alert{tail recursive}
    \item the recursive function call is the last action:\\
      nothing left for the caller to do

    \pause
    \medskip
    \item no need to keep the stack frame around:\\
      reuse the frame of the caller
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{lstlisting}
gcd x y = if y == 0 then x else gcd y (x `mod` y)
  \end{lstlisting}

  \lstinline{gcd 9702 945}\\
  $\rightsquigarrow$ \lstinline{gcd 945 252}\\
  $\rightsquigarrow$ \lstinline{gcd 252 189}\\
  $\rightsquigarrow$ \lstinline{gcd 189 63}\\
  $\rightsquigarrow$ \lstinline{gcd 63 0}\\
  $\rightsquigarrow$ \lstinline{63}\\
\end{frame}

\begin{frame}
  \frametitle{Tail Recursion}

  \begin{itemize}
    \item to rearrange a function to be tail recursive:

    \medskip
    \item define a helper function that takes an \alert{accumulator}
    \item base case: return accumulator
    \item recursive case: make recursive call with new accumulator value
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{lstlisting}
facIter :: Integer -> Integer -> Integer
facIter acc n
  | n < 0     = error "negative parameter"
  | n == 0    = acc
  | otherwise = facIter (acc*n) (n-1)

fac :: Integer -> Integer
fac n = facIter 1 n
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{lstlisting}
facIter acc n
  | n < 0     = error "negative parameter"
  | n == 0    = acc
  | otherwise = facIter (acc*n) (n-1)
  \end{lstlisting}

  \lstinline{fac 4}\\
  $\rightsquigarrow$ \lstinline{facIter 1 4}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{facIter 4 3}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{facIter 12 2}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{facIter 24 1}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{facIter 24 0}\\
  \hspace{16pt}$\rightsquigarrow$ \lstinline{24}\\
  $\rightsquigarrow$ \lstinline{24}\\
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tail Recursion Example}

  \begin{itemize}
    \item helper function doesn't need to be visible
  \end{itemize}

  \begin{lstlisting}
fac :: Integer -> Integer
fac n
  | n < 0     = error "negative parameter"
  | otherwise = facIter 1 n
      where
        facIter :: Integer -> Integer -> Integer
        facIter acc n'
          | n' == 0   = acc
          | otherwise = facIter (acc*n') (n'-1)
  \end{lstlisting}
\end{frame}

\subsection{Tree Recursion}

\begin{frame}[fragile]
  \frametitle{Tree Recursion}

  \begin{itemize}
    \item another classic example: the Fibonacci sequence
    \[
      fib_n =
        \begin{cases}
          1                     & \mbox{if } n = 1\\
          1                     & \mbox{if } n = 2\\
          fib_{n-2} + fib_{n-1} & \mbox{if } n > 2
        \end{cases}
    \]
  \end{itemize}

  \begin{exampleblock}{}
    \begin{lstlisting}
fib :: Integer -> Integer
fib n
  | n == 1    = 1
  | n == 2    = 1
  | otherwise = fib (n-2) + fib (n-1)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Stack Frame Example}

  \begin{center}
    \pgfuseimage{fib}
  \end{center}
\end{frame}

\subsection{Examples}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{itemize}
    \item compute $x^y$ where $y \in \mathbb{N}$
  \end{itemize}

  \smallskip
  \begin{lstlisting}
pow :: Integer -> Integer -> Integer
pow x y
  | y == 0    = 1
  | otherwise = x * pow x (y-1)
  \end{lstlisting}

  \pause
  \begin{itemize}
    \item use the following definition:
  \end{itemize}
  \[
    x^y =
      \begin{cases}
        1               & \mbox{if y = 0}\\
        {(x^{y/2})}^2   & \mbox{if y is even}\\
        x \cdot x^{y-1} & \mbox{if y is odd}
      \end{cases}
  \]
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{lstlisting}
fastPow :: Integer -> Integer -> Integer
fastPow x y
  | y == 0    = 1
  | even y    = sqr (fastPow x (y `div` 2))
  | otherwise = x * fastPow x (y-1)
  where
    sqr :: Integer -> Integer
    sqr n = n*n
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Recursion Example}

  \begin{itemize}
    \item square roots with Newton's method

    \medskip
    \item start with an initial guess $y$ (say $y = 1$)
    \item repeatedly improve the guess by taking the mean of $y$
      and $x / y$
    \item until the guess is good enough ($\sqrt x \cdot \sqrt x = x$)
  \end{itemize}

  \medskip
  \begin{center}
    \begin{tabular}{lll}
    $y$      & $x / y$             & next guess\\\hline
    1        & 2 / 1 = 2           & 1.5\\
    1.5      & 2 / 1.5 = 1.333     & 1.4167\\
    1.4167   & 2 / 1.4167 = 1.4118 & 1.4142\\
    1.4142   & ...                 & ...
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{itemize}
    \item goal: $guess = \sqrt x$
    \item if guess is good enough: $|guess \cdot guess - x| < \epsilon$
  \end{itemize}

  \pause
  \begin{exampleblock}{check whether guess is good enough}
    \begin{lstlisting}
isGoodEnough :: Float -> Float -> Bool
isGoodEnough guess x = abs (guess*guess - x) < 0.001
    \end{lstlisting}
  \end{exampleblock}

  \pause
  \begin{exampleblock}{improve guess}
    \begin{lstlisting}
improve :: Float -> Float -> Float
improve guess x = (guess + x/guess) / 2.0
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{exampleblock}{iterative computation}
    \begin{lstlisting}
newtonIter :: Float -> Float -> Float
newtonIter guess x
  | isGoodEnough guess x = guess
  | otherwise            =
        newtonIter (improve guess x) x

newton :: Float -> Float
newton x = newtonIter 1.0 x
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{lstlisting}
newton :: Float -> Float
newton x = newtonIter 1.0 x
  where
    isGoodEnough :: Float -> Float -> Bool
    isGoodEnough guess x' =
        abs (guess*guess - x') < 0.001

    improve :: Float -> Float -> Float
    improve guess x' = (guess + x'/guess) / 2.0

    newtonIter :: Float -> Float -> Float
    newtonIter guess x'
      | isGoodEnough guess x' = guess
      | otherwise             =
          newtonIter (improve guess x') x'
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{itemize}
    \item doesn't work with too small and too large numbers (why?)
  \end{itemize}

  \pause
  \smallskip
  \begin{lstlisting}
isGoodEnough guess x' =
    (abs (guess*guess - x')) / x' < 0.001
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion Example}

  \begin{itemize}
    \item no need to pass \lstinline{x} around, it's already in scope
  \end{itemize}

  \pause
  \smallskip
  \begin{lstlisting}
newton x = newtonIter 1.0
  where
    isGoodEnough :: Float -> Bool
    isGoodEnough guess =
        (abs (guess*guess - x)) / x < 0.001

    improve :: Float -> Float
    improve guess = (guess + x/guess) / 2.0

    newtonIter :: Float -> Float
    newtonIter guess
      | isGoodEnough guess = guess
      | otherwise          = newtonIter (improve guess)
  \end{lstlisting}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Thompson}
    \begin{itemize}
      \item Chapter 3: \alert{Basic types and definitions}
      \item Chapter 4: \alert{Designing and writing programs}
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
