% Copyright (c) 2005-2015
%       H. Turgut Uyar <uyar@itu.edu.tr>
%       Şule Gündüz Öğüdücü <sgunduz@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setbeamersize{text margin left=2em, text margin right=2em}

\usepackage{listings}
\lstset{basicstyle=\ttfamily, keywordstyle=\color{ForestGreen},
        showstringspaces=false}

\mode<presentation> {
  \usetheme{Warsaw}
  \usecolortheme[named=ForestGreen]{structure}
  \setbeamercovered{transparent}
}

\title{Database Systems}
\subtitle{Non-Relational Databases}

\author{H. Turgut Uyar \and Şule Öğüdücü}
\date{2005-2015}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../license}

\pgfdeclareimage[width=6.8cm]{casino-royale}{casino-royale}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2005-2015 T. Uyar, Ş. Öğüdücü

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Non-Relational Databases}

\subsection{Introduction}

\begin{frame}
  \frametitle{Relational Model}

  \begin{itemize}
    \item relational model is not the best solution for all types of problems

    \bigskip
    \item example applications:
    \smallskip
    \item storing user preferences
    \item processing data from Wikipedia pages
    \item building a social network
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example: User Preferences}

  \begin{itemize}
    \item user, preference type, selected option

    \medskip
    \item example task:\\
      retrieve privacy preference of a given user

    \pause
    \medskip
    \item no complex queries that would require SQL
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Example: Wikipedia Pages}

  \begin{columns}
    \column{.55\textwidth}
    \pgfuseimage{casino-royale}

    \column{.45\textwidth}
    \begin{itemize}
      \item combination of structured\\
        and unstructured data

      \medskip
      \item example task:\\
        retrieve first paragraph\\
        of all James Bond movies\\
        starring Daniel Craig

      \pause
      \medskip
      \item difficult to represent\\
        as a relation
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Example: Social Network}

  \begin{itemize}
    \item users: userid, name, age, gender, \ldots
    \item friends: userid1, userid2

    \medskip
    \item example tasks:\\
      find all friends of a given user\\
      find all friends of friends of a given user\\
      find all female friends of male friends of a given user\\
      find all friends of friends of ... friends of a given user\\

    \pause
    \medskip
    \item too many complicated joins
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Problems: Representation}

  \begin{itemize}
    \item difficult to handle unstructured and semistructured data
    \item difficult to represent hierarchy and neighborhood

    \pause
    \medskip
    \item rigid schemas: all rows need to store all fields
    \item even if not applicable
    \smallskip
    \item fixed in advance
    \item to make changes: shut down, alter table, restart
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Problems: Scaling}

  \begin{itemize}
    \item when volume of data increases:

    \medskip
    \item scale up: faster processor
    \item works up to a point

    \smallskip
    \item scale out: more processors
    \item commodity hardware
  \end{itemize}
\end{frame}

\subsection{NoSQL}

\begin{frame}
  \frametitle{NoSQL Databases}

  \begin{itemize}
    \item NoSQL $\neq$ ``don't use SQL''
    \item Not Only SQL
    \item use relational for some parts and non-relational for other parts

    \pause
    \medskip
    \item key-value stores
    \item column family stores
    \item document stores
    \item graph databases
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{NoSQL Principles}

  \begin{itemize}
    \item flexible schema

    \medskip
    \item focus on performance
    \item no joins

    \medskip
    \item focus on availability
    \item updates should always be allowed

    \medskip
    \item massive scalability
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{NoSQL Disadvantages}

  \begin{itemize}
    \item focus on availability $\rightarrow$ relaxed consistency
    \item fewer transactional guarantees

    \pause
    \medskip
    \item no declarative query language
    \item programmatic handling of data
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Distributing Data}

  \begin{itemize}
    \item breaking a database into chunks: \alert{shards}
    \item spreading chunks across distributed servers

    \medskip
    \item increases efficiency
    \item more servers $\rightarrow$ more points of failure
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Replication}

  \begin{itemize}
    \item replicating data between servers
    \item increases fault tolerance

    \medskip
    \item copies might diverge
    \item \alert{eventual consistency}: temporary inconsistency is allowed
    \item when system stops, all copies will be the same
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{CAP Properties}

  \begin{itemize}
    \item \alert{C}onsistency:\\
      all clients can read a single, up-to-date version of data\\
      from replicated partitions

    \medskip
    \item \alert{A}vailability:\\
      internal communication failures between replicated data\\
      don't prevent updates

    \medskip
    \item \alert{P}artition tolerance:\\
      system keeps responding even if there is a communication failure\\
      between partitions
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{CAP Theorem}

  \begin{itemize}
    \item Eric Brewer (2000)
    \item Any distributed database can provide\\
      at most two of the three CAP properties.
  \end{itemize}
\end{frame}

\subsection{Serialization}

\begin{frame}
  \frametitle{Serialization}

  \begin{itemize}
    \item simplest method for persistance: write to file

    \medskip
    \item write: object $\rightarrow$ serial format (\alert{serialization})
    \item read: serial format $\rightarrow$ object (\alert{deserialization})
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Serialization Formats}

  \begin{itemize}
    \item common formats: XML, JSON
    \item human-readable
    \item useful for data interchange
    \item also useful for representing semistructured data
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JSON}

  \begin{itemize}
    \item JavaScript Object Notation

    \medskip
    \item base values: number, string, \ldots
    \item objects: sets of key-value pairs
    \item arrays of values

    \medskip
    \item nested structure
  \end{itemize}
\end{frame}

\lstset{language=Python}

\begin{frame}[fragile]
  \frametitle{JSON Example}

  \begin{lstlisting}
{
  "title": "Being John Malkovich",
  "year": 1999,
  "score": 8.3,
  "votes": 13809,
  "director": "Spike Jonze",
  "cast": [
    "Cameron Diaz",
    "John Cusack",
    "John Malkovich"
  ]
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JSON Example}

  \begin{lstlisting}
[
  {
    "title": "Usual Suspects",
    ...
  },
  ...
  {
    "title": "Ed Wood",
    ...
  }
]
  \end{lstlisting}
\end{frame}

\section{Data Models}

\subsection{Key-Value Stores}

\begin{frame}
  \frametitle{Key-Value Stores}

  \begin{itemize}
    \item model: (key, value) pairs
    \item very simple interface
    \item operations:\\
      insert(key, value)\\
      fetch(key)\\
      update(key, value)\\
      delete(key)
    \item products: Redis, Riak, Memcache, Amazon DynamoDB
    \item applications: image store, object cache
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Key-Value Stores}

  \begin{itemize}
    \item distribute records to computing nodes based on key
    \item advanced: structure in value
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Column Family Stores}

  \begin{itemize}
    \item key is a (row, column) pair
    \item sparse matrix
    \item products: Apache Cassandra, Apache HBase, Google BigTable
    \item applications: web crawler results
  \end{itemize}
\end{frame}

\subsection{Document Stores}

\begin{frame}
  \frametitle{Document Stores}

  \begin{itemize}
    \item model: (key, document) pairs
    \item document: JSON formatted data
    \item fetch also based on document contents
    \item products: MongoDB, CouchDB
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{MongoDB Insert Example}

  \begin{lstlisting}
itucsdb.movies.insert(
  {
    "title": "Ed Wood",
    "year": 1994,
    "score": 7.8,
    "votes": 6587,
    "director": "Tim Burton",
    "cast": [
      "Johnny Depp"
    ]
  }
)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{MongoDB Insert Example}

  \begin{lstlisting}
itucsdb.movies.insert(
  {
    "title": "Three Kings",
    "year": 1999,
    "score": 7.7,
    "votes": 10319,
    "cast": [
      "George Clooney",
      "Spike Jonze"
    ]
  }
)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{MongoDB Find Example}

  \begin{lstlisting}
itucsdb.movies.find()

itucsdb.movies.find(
  {"year": 1999}
)
  \end{lstlisting}
\end{frame}

\subsection{Graph Databases}

\begin{frame}
  \frametitle{Document Stores}

  \begin{itemize}
    \item model: nodes and edges
    \item nodes have properties
    \item edges have labels
    \item relationship intensive data
    \item products: Neo4J
    \item applications: social networks
  \end{itemize}
\end{frame}

\section{XML Databases}

\subsection{Serialization: XML}

\lstset{language=XML}

\begin{frame}
  \frametitle{XML}

  \begin{itemize}
    \item XML is not a language itself
    \item framework for defining languages

    \medskip
    \item XML-based languages:\\
      XHTML, DocBook, SVG, MathML, WML, XMI, ...

    \smallskip
    \item XML-related languages:\\
      XPath, XQuery, XSL Transforms, SOAP, XLink, ...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{XML Structure}

  \begin{itemize}
    \item an XML document forms a \emph{tree}

    \item nodes: \emph{elements}
    \item root node: \emph{document element}
    \item leaves: character data, self-closing elements

    \pause
    \medskip
    \item opening/closing tags
    \item attributes
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{XML Example: Movies}

  \begin{lstlisting}
<movies>
  <movie color="Color">
    <title>Usual Suspects</title>
    ...
  </movie>
  <movie color="Color">
    <title>Being John Malkovich</title>
    ...
  </movie>
  ...
</movies>
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{XML Example: Movies}

  \begin{lstlisting}
  <movie color="Color">
    <title>Usual Suspects</title>
    <year>1995</year>
    <score>8.7</score>
    <votes>35027</votes>
    <director>Bryan Singer</director>
    <cast>
      <actor>Gabriel Byrne</actor>
      <actor>Benicio Del Toro</actor>
    </cast>
  </movie>
  \end{lstlisting}
\end{frame}

\subsection{XPath}

\begin{frame}
  \frametitle{Querying XML}

  \begin{itemize}
    \item XPath: selecting nodes and data from XML documents
    \item path of nodes to find: chain of location steps
    \begin{itemize}
      \item starting from the root (absolute)
      \item starting from the current node (relative)
    \end{itemize}

    \medskip
    \item XQuery: XPath + update operations
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{XPath Examples}

  \begin{itemize}
    \item all movies: \lstinline|/movies/movie|
    \item actors of current movie: \lstinline|./cast/actor|
    \item \lstinline|../../year|
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Location Steps}

  \begin{itemize}
    \item location step structure:\\
      \lstinline!axis::node_selector[predicate]!

    \medskip
    \item axis: where to search
    \item selector: what to search
    \item predicate: under which conditions
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Axes}

  \begin{itemize}
    \item \lstinline!child!:
      all children, one level (default axis)
    \item \lstinline!descendant!:
      all children, recursively (shorthand: \lstinline!//!)
    \item \lstinline!parent!:
      parent node, one level
    \item \lstinline!ancestor!:
      parent nodes, up to document element
    \item \lstinline!attribute!:
      attributes (shorthand: \lstinline!@!)
    \item \lstinline!following-sibling!:
      siblings that come later
    \item \lstinline!preceding-sibling!:
      siblings that come earlier
    \item ...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Node Selectors}

  \begin{itemize}
    \item node tag
    \item node attribute
    \item node text: \lstinline!text()!
    \item all children: \lstinline!*!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{XPath Examples}

  \begin{example}
    \begin{itemize}
      \item names of all directors:\\
        \lstinline!/movies/movie/director/text()!\\
        \lstinline!//director/text()!

      \pause
      \item all actors in this movie:\\
        \lstinline!./cast/actor!\\
        \lstinline!.//actor!

      \pause
      \item colors of all movies:\\
        \lstinline!//movie/@color!

      \pause
      \item scores of movies after this one:\\
        \lstinline!./following-sibling::movie/score!
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{XPath Predicates}

  \begin{itemize}
    \item testing node position: \lstinline![position]!

    \pause
    \medskip
    \item testing existence of a child: \lstinline![child_tag]!
    \item testing value of a child: \lstinline![child_tag="value"]!

    \pause
    \medskip
    \item testing existence of an attribute: \lstinline![@attribute]!
    \item testing value of an attribute: \lstinline![@attribute="value"]!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{XPath Examples}

  \begin{example}
    \begin{itemize}
      \item the title of the first movie:\\
        \lstinline!/movies/movie[1]/title!

      \pause
      \item all movies in the year 1997:\\
        \lstinline!movie[year="1997"]!

      \pause
      \item black-and-white movies:\\
        \lstinline!movie[@color="BW"]!
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Example: Oracle Berkeley DBXML}

  \begin{itemize}
    \item an embedded XML database
    \item stores XML documents
    \item manipulates data using XQuery
    \item can be used via its own client
    \item has bindings for several languages
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{DBXML Interface}

  \begin{itemize}
    \item creating a database:\\
    \begin{itemize}
      \item create an \lstinline!XmlManager! object
      \item \lstinline!XmlManager.createContainer(name)!
        $\rightarrow$ \lstinline!XmlContainer!
      \item put a document element:\\
        \lstinline!XmlContainer.putDocument(namespace, xml_string,!\\
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\lstinline!configuration)!
    \end{itemize}

    \pause
    \item connecting to an existing database:\\
    \begin{itemize}
      \item create an \lstinline!XmlManager! object
      \item if \lstinline?XmlManager.existsContainer(name) != 0?
      \item \lstinline!XmlManager.openContainer(name)!
        $\rightarrow$ \lstinline!XmlContainer!
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{DBXML Interface}

  \begin{itemize}
    \item \lstinline!XmlManager.createQueryContext()!
      $\rightarrow$ \lstinline!XmlQueryContext!
    \item \lstinline!XmlQueryContext.setNamespace(namespace, URL)!

    \pause
    \item query string: \lstinline!collection(name)/xpath_expression!
    \item running the query:\\
      \lstinline!XmlManager.query(query, context)!
      $\rightarrow$ \lstinline!XmlResults!

    \pause
    \medskip
    \item each element of the \lstinline!XmlResults! iterator is an
      \lstinline!XmlValue!
    \item \lstinline!getFirstChild()!, \lstinline!getLastChild()!,
      \lstinline!getNextSibling()!, ...
    \item character data: \lstinline!getNodeValue()!
      $\rightarrow$ \lstinline!String!
    \item attributes:
      \lstinline!XmlValue.getAttributes()! $\rightarrow$ \lstinline!XmlResults!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DBXML Examples}

  \begin{example}[database connection]
    \begin{lstlisting}
db = new XmlManager();
XmlContainer container = null;
if (db.existsContainer("imdb.dbxml") != 0)
  container = db.openContainer("imdb.dbxml");
else {
  container = db.createContainer("imdb.dbxml");
  container.putDocument("movies",
      "<movies />",
      (XmlDocumentConfig) null);
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DBXML Examples}

  \begin{example}[converting a movie object into an XML string]
    \begin{lstlisting}
public static String toXml(Movie movie) {
  StringBuffer buffer = new StringBuffer();
  buffer.append("<movie>");
  buffer.append("<title>"
    + movie.getTitle() + "</title>");
  buffer.append("<year>"
    + movie.getYear().toString() + "</year>");
  buffer.append("</movie>");
  return buffer.toString();
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DBXML Examples}

  \begin{example}[converting an XML node into a movie object]
    \begin{lstlisting}
private static Movie fromNode(XmlValue node)
        throws XmlException {
  XmlValue tn = node.getFirstChild();
  String title =
      tn.getFirstChild().getNodeValue();
  XmlValue yn = tn.getNextSibling();
  String yearValue =
      yn.getFirstChild().getNodeValue();
  Integer year = Integer.parseInt(yearValue);
  Movie movie = new Movie(title);
  movie.setYear(year);
  return movie;
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DBXML Examples}

  \begin{example}[query: all movies]
    \begin{lstlisting}
XmlQueryContext context = ...;
context.setNamespace(...);
String query =
  "collection(\"imdb.dbxml\")/movies/movie";
XmlResults results = db.query(query, context);
if (results.hasNext()) {
  XmlValue node = results.next();
  Movie movie = fromNode(node);
  ...
}
results.delete();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{DBXML Examples}

  \begin{example}[insert]
    \begin{lstlisting}
Movie m = new Movie("Casablanca");
m.setYear(1942);

XmlQueryContext context = ...;
context.setNamespace(...);
String query = "insert nodes " + toXml(m)
  + " into collection(\"imdb.dbxml\")/movies";
XmlResults results = db.query(query, context);
results.delete();
    \end{lstlisting}
  \end{example}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Supplementary Reading}
    \begin{itemize}
      \item Making Sense of NoSQL, by Dan McCreary and Ann Kelly,\\
        Manning Publications
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
