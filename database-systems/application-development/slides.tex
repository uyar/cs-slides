% Copyright (c) 2002-2014
%       H. Turgut Uyar <uyar@itu.edu.tr>
%       Şule Gündüz Öğüdücü <sgunduz@itu.edu.tr>
%
% This work is licensed under a "Creative Commons
% Attribution-NonCommercial-ShareAlike 4.0 International License".
% For more information, please visit:
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[scaled=0.88]{beramono}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setbeamertemplate{navigation symbols}{}
\setbeamersize{text margin left=2em, text margin right=2em}

\usepackage{listings}
\lstdefinelanguage{ExtendedPHP}[]{PHP}{
  morekeywords={odbc_exec}
}
\lstdefinelanguage{FullSQL}[]{SQL}{
  morekeywords={BINARY, BOOLEAN, CYCLE, FINAL, INCREMENT, IS, LARGE, MAXVALUE,
                MINVALUE, NO_ACTION, OBJECT, REFERENCES, RENAME, SEQUENCE,
                START, TO, TYPE, VACUUM}
}
\lstdefinelanguage{ExtendedSQL}[]{FullSQL}{
  morekeywords={AFTER, BEFORE, DO, EACH, FOR, FUNCTION, INSTEAD, LANGUAGE,
                OPTION, PROCEDURE, RETURNS, ROW, RULE, SNAPSHOT, STATEMENT,
                WITH}
}
\lstdefinelanguage{EmbeddedSQL}[]{FullSQL}{
  morekeywords={BEGIN, CLOSE, CONTINUE, CURSOR, DECLARE, FETCH, FOR, DO, END,
                EXEC, FOUND, GOTO, INCLUDE, INTO, OPEN, SECTION, SQL, SQLERROR,
                SQLWARNING, STATEMENT, STOP, WHENEVER, sqlca, sqlcode}
}
\lstset{basicstyle=\ttfamily, keywordstyle=\color{ForestGreen},
        showstringspaces=false}

\mode<presentation>
{
  \usetheme{Warsaw}
  \usecolortheme[named=ForestGreen]{structure}
  \setbeamercovered{transparent}
}

\title{Database Systems}
\subtitle{Application Development}

\author{H. Turgut Uyar \and Şule Öğüdücü}
\date{2002-2014}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../license}

\pgfdeclareimage[height=5cm]{esql}{esql}
\pgfdeclareimage[width=11cm]{xkcd}{xkcd}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright~2002-2014 T. Uyar, Ş. Öğüdücü

  \vfill
  \begin{footnotesize}
    You are free to:
    \begin{itemize}
      \itemsep0em
      \item Share -- copy and redistribute the material in any medium or format
      \item Adapt -- remix, transform, and build upon the material
    \end{itemize}

    Under the following terms:
    \begin{itemize}
      \itemsep0em
      \item Attribution -- You must give appropriate credit, provide a link to
        the license, and indicate if changes were made.

      \item NonCommercial -- You may not use the material for commercial
        purposes.

      \item ShareAlike -- If you remix, transform, or build upon the material,
        you must distribute your contributions under the same license as the
        original.
    \end{itemize}
  \end{footnotesize}

  \begin{small}
    For more information:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/}

    \smallskip
    Read the full license:\\
    \url{https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode}
  \end{small}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Application Development}

\subsection{Introduction}

\lstset{language=C}

\begin{frame}
  \frametitle{Introduction}

  \begin{itemize}
    \item using the database language in conjunction\\
      with a general-purpose programming language
    \item general-purpose language: \alert{host language}

    \pause
    \bigskip
    \item mismatch between SQL and the host language:
    \begin{itemize}
      \item sets in SQL
      \item objects and iteration constructs in the host language
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Program Structure}

  \begin{itemize}
    \item connect
    \begin{itemize}
      \item server, database, username, password
    \end{itemize}

    \pause
    \medskip
    \item run statements as needed:
    \begin{itemize}
      \item query operations return result sets $\rightarrow$ iterate over rows
      \item update operations return number of affected rows
    \end{itemize}

    \pause
    \medskip
    \item disconnect
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Approaches}

  \begin{itemize}
    \item application programming interface (API)
    \item embedded SQL
    \item ODBC
    \item language standard interfaces
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Application Programming Interface}

  \begin{itemize}
    \item using the library functions of the SQL server

    \bigskip
    \item pros: fast
    \item cons: specific to SQL product
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example: PostgreSQL - C}

  \begin{lstlisting}
#include <libpq-fe.h>

int main(int argc, char *argv[])
{
    /* connect */
    /* execute query */
    /* disconnect */
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example: Connection}

  \begin{lstlisting}
/* PGconn *conn; */
conn = PQconnectdb("host=localhost dbname=imdb"
                   " user=itucs password=itucs");
if (PQstatus(conn) == CONNECTION_BAD)
{
    fprintf(stderr, "Connection failed.\n");
    exit(1);
}

/* execute query */

PQfinish(conn);
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example: Query Execution}

  \begin{lstlisting}
sprintf(query, "SELECT TITLE, SCORE"
               " FROM MOVIE WHERE (YR = %d)", year);

/* PGresult *result; */
result = PQexec(conn, query);
if (PQresultStatus(result) != PGRES_TUPLES_OK)
{
    fprintf(stderr, "Query failed.\n");
    PQclear(result);
    PQfinish(conn);
    exit(1);
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example: Result Set}

  \begin{lstlisting}
for (i = 0; i < PQntuples(result); i++)
{
    title = PQgetvalue(result, i, 0);
    score = PQgetvalue(result, i, 1);
    ...
}

PQclear(result);
  \end{lstlisting}
\end{frame}

\subsection{Embedded SQL}

\lstset{language=EmbeddedSQL}

\begin{frame}
  \frametitle{Embedded SQL}

  \begin{itemize}
    \item mark SQL statements within host language code: \lstinline!EXEC SQL!
    \item preprocessor: embedded SQL directives $\rightarrow$ API calls

    \pause
    \bigskip
    \item pros: fast, standard
    \item cons: difficult, does not support most languages
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Embedded SQL}

  \begin{center}
    \pgfuseimage{esql}
  \end{center}

  \hyperlink{odbc}{\beamergotobutton{skip Embedded SQL}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL}

  \begin{itemize}
    \item variable sharing
    \begin{lstlisting}
EXEC SQL BEGIN DECLARE SECTION;
-- shared variables
EXEC SQL END DECLARE SECTION;
    \end{lstlisting}

    \pause
    \medskip
    \item error control
    \begin{lstlisting}
EXEC SQL WHENEVER
  { SQLERROR | SQLWARNING | NOT FOUND }
  { STOP | CONTINUE | DO command | GOTO label }
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Query Results}

  \begin{itemize}
    \item cursors for iterating over query results
    \begin{lstlisting}
EXEC SQL DECLARE cursor_name CURSOR FOR
    SELECT ...;
EXEC SQL OPEN cursor_name;
EXEC SQL FETCH IN cursor_name INTO variables;
EXEC SQL CLOSE cursor_name;
    \end{lstlisting}

    \medskip
    \item query is executed when cursor is opened
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example: Connect}

  \begin{lstlisting}[language=C]
EXEC SQL BEGIN DECLARE SECTION;
int year;
char *title = NULL, *score = NULL;
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO imdb
    USER itucs IDENTIFIED BY itucs;

/* process query */

EXEC SQL DISCONNECT;
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example: Cursor}

  \begin{lstlisting}[language=C]
scanf("%d", &year);
EXEC SQL DECLARE c_query CURSOR FOR
    SELECT TITLE, SCORE FROM MOVIE
      WHERE (YR = :year);
EXEC SQL OPEN c_query;

/* execute query */

EXEC SQL CLOSE c_query;
EXEC SQL COMMIT;
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example: Query}

  \begin{lstlisting}[language=C]
EXEC SQL WHENEVER NOT FOUND DO break;
while (1)
{
    EXEC SQL FETCH c_query INTO :title, :score;
    ...
}
  \end{lstlisting}
\end{frame}

\subsection{ODBC}

\lstset{language=ExtendedPHP}

\begin{frame}[label=odbc]
  \frametitle{ODBC}

  \begin{itemize}
    \item \alert{ODBC}: Open DataBase Connectivity\\
      a service layer between the application and the server

    \bigskip
    \item pros: standard
    \item cons: slow
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ODBC Architecture}

  \begin{itemize}
    \item application

    \medskip
    \item driver manager
    \begin{itemize}
      \item registers the ODBC drivers
      \item transfers requests from application to driver
    \end{itemize}

    \medskip
    \item driver
    \begin{itemize}
      \item translates and transfers requests to data source
    \end{itemize}

    \medskip
    \item data source
    \begin{itemize}
      \item processes instructions from the driver
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Example: PHP}

  \begin{lstlisting}
$conn = odbc_connect("imdb", "itucs", "itucs");
$query = "SELECT TITLE, SCORE FROM MOVIE"
       . " WHERE (YR = " . $year . ")";
$result = odbc_exec($conn, $query);

/* process the result set */

odbc_close($conn);
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Example: PHP}

  \begin{lstlisting}
echo "<table>\n";
while (odbc_fetch_row($result)) {
    $title = odbc_result($result, "title");
    $score = odbc_result($result, "score");
    echo "<tr>\n";
    echo "  <td>$title</td>\n";
    echo "  <td>$score</td>\n";
    echo "</tr>\n";
}
echo "</table>\n";
  \end{lstlisting}
\end{frame}

\subsection{JDBC}

\lstset{language=Java}

\begin{frame}
  \frametitle{JDBC}

  \begin{itemize}
    \item \alert{JDBC}: Java DataBase Connectivity

    \medskip
    \item same architectural concepts as in ODBC
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JDBC Drivers}

  \begin{itemize}
    \item \emph{Type I}: bridges
    \begin{itemize}
      \item translate into non-native calls (for example ODBC)
    \end{itemize}

    \pause
    \medskip
    \item \emph{Type II}: direct translation via non-Java driver
    \begin{itemize}
      \item translate into API of data source (for example C++)
    \end{itemize}

    \pause
    \medskip
    \item \emph{Type III}: network bridges
    \begin{itemize}
      \item connect to middleware server\\
	for translating into API of data source
    \end{itemize}

    \pause
    \medskip
    \item \emph{Type IV}: direct translation via Java driver
    \begin{itemize}
      \item communicate with DBMS through Java sockets
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JDBC Flow}

  \begin{itemize}
    \item get a connection object:\\
    \lstinline!Connection conn = DriverManager.getConnection();!

    \pause
    \item create a statement object on the connection\\
    \lstinline!Statement stmt = conn.createStatement();!

    \pause
    \item execute the query
    \begin{itemize}
      \item select: \lstinline!ResultSet results = stmt.executeQuery(query);!
      \item insert, update, delete: \lstinline!stmt.executeUpdate(query);!
    \end{itemize}

    \pause
    \item process the results

    \pause
    \item close resources which are no longer needed\\
      (result sets, statements, connections)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Processing Results}

  \begin{itemize}
    \item \lstinline!ResultSet! is an iterator
    \begin{itemize}
      \item whether there are more rows: \lstinline!.hasNext()!
      \item proceed to the next row: \lstinline!.next()!
    \end{itemize}

    \medskip
    \item convert and transfer data in the row to variables
    \begin{itemize}
      \item by column name: \lstinline!.getXXX(name)!
      \item by column order: \lstinline!.getXXX(order)!
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Data Type Conversions}

  \begin{table}
    \begin{tabular}{|l|l|l|}\hline
SQL type                            & Java class
                                    & \lstinline!ResultSet! method\\\hline\hline
\lstinline[language=SQL]!BIT!       & \lstinline!Boolean!
                                    & \lstinline!.getBoolean()!    \\\hline
\lstinline[language=SQL]!CHAR!      & \lstinline!String!
                                    & \lstinline!.getString()!     \\\hline
\lstinline[language=SQL]!VARCHAR!   & \lstinline!String!
                                    & \lstinline!.getString()!     \\\hline
\lstinline[language=SQL]!FLOAT!     & \lstinline!Float!
                                    & \lstinline!.getDouble()!     \\\hline
\lstinline[language=SQL]!INTEGER!   & \lstinline!Integer!
                                    & \lstinline!.getInt()!        \\\hline
\lstinline[language=SQL]!DATE!      & \lstinline!java.sql.Date!
                                    & \lstinline!.getDate()!       \\\hline
\lstinline[language=SQL]!TIME!      & \lstinline!java.sql.Time!
                                    & \lstinline!.getTime()!       \\\hline
\lstinline[language=SQL]!TIMESTAMP! & \lstinline!java.sql.TimeStamp!
                                    & \lstinline!.getTimestamp()!  \\\hline
    \end{tabular}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Driver}

  \begin{lstlisting}
try {
    Class.forName("org.postgresql.Driver");
} catch (ClassNotFoundException e) {
    // PostgreSQL driver not installed
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Connect}

  \begin{lstlisting}
try {
    conn = DriverManager.getConnection(
        "jdbc:postgresql:imdb", "itucs", "itucs"
    );
} catch (SQLException e) {
    // connection error
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Insert}

  \begin{lstlisting}
query = "INSERT INTO MOVIE (TITLE, YR)"
      + " VALUES ('Casablanca', 1942)";
stmt = conn.createStatement();
stmt.executeUpdate(query);
stmt.close();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Security}

  \begin{itemize}
    \item don't trust inputs from outside sources
  \end{itemize}

  \medskip
  \begin{example}
    \begin{lstlisting}
name = ...; // get from outside source
query = "INSERT INTO Students (NAME)"
      + " VALUES ('" + name + "')";
stmt = conn.createStatement();
stmt.executeUpdate(query);
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Little Bobby Tables}

  \begin{center}
    \pgfuseimage{xkcd}
  \end{center}
  \url{http://xkcd.com/327/}
\end{frame}

\begin{frame}
  \frametitle{Prepared Statements}

  \begin{itemize}
    \item prepared statements can be reused by changing parameter values

    \medskip
    \item creating:\\
      \lstinline!PreparedStatement stmt = conn.prepareStatement(query);!

    \medskip
    \item placeholder for parameters in query: \lstinline!?!
    \item values must be set before executing:\\
      \lstinline!stmt.setXXX(order, value);!

    \medskip
    \item executing:\\
      \lstinline!ResultSet results = stmt.executeQuery();!\\
      \lstinline!stmt.executeUpdate();!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Prepared Statement}

  \begin{lstlisting}
query = "INSERT INTO MOVIE (TITLE, YR) VALUES (?, ?)";
stmt = conn.prepareStatement(query);
for (Movie movie : getMovies()) {
    stmt.setString(1, movie.getTitle());
    stmt.setInt(2, movie.getYear());
    stmt.executeUpdate();
}
stmt.close();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Result Set}

  \begin{lstlisting}
query = String.format(
    "SELECT TITLE FROM MOVIE WHERE (YR = %d)", year
);
stmt = conn.createStatement();
results = stmt.executeQuery(query);
while (results.next()) {
    title = results.getString("TITLE");
    System.out.println("Title: " + title),
}
results.close();
stmt.close();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Delete}

  \begin{lstlisting}
query = "DELETE FROM MOVIE WHERE (ID = ?)";
stmt = conn.prepareStatement(query);
stmt.setInt(1, movie.getId());
stmt.executeUpdate();
stmt.close();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Update}

  \begin{lstlisting}
query = "UPDATE MOVIE SET YR = ? WHERE (ID = ?)";
stmt = conn.prepareStatement(query);
stmt.setInt(1, movie.getYear());
stmt.setInt(2, movie.getId());
stmt.executeUpdate();
stmt.close();
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example: Close Resources}

  \begin{lstlisting}
Statement stmt = ...;
ResultSet results = ...;
try {
    results = stmt.executeQuery(query);
    ...
} catch (SQLException e) {
    ...
} finally {
    results.close();
    stmt.close();
}
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Auto-Generated Identity Values}

  \begin{lstlisting}
query = "INSERT INTO ... ";
stmt = conn.prepareStatement(query,
           Statement.RETURN_GENERATED_KEYS);
stmt.executeUpdate();

ResultSet ids = stmt.getGeneratedKeys();
// assuming there is one and only one result
ids.next();
int id = ids.getInt(1);
  \end{lstlisting}
\end{frame}
%
% \begin{frame}
%   \frametitle{Batch Mode}
%
%   \begin{itemize}
%     \item accumulating statements to run them in batches\\
%       might be faster
%
%     \pause
%     \medskip
%     \item get the connection out of "auto commit" mode
%     \item accumulate: \lstinline!Statement.addBatch(query)!
%     \item execute accumulated statements: \lstinline!Statement.executeBatch()!
%     \item finalizing changes: \lstinline!Connection.commit()!
%   \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Batch Mode Example}
%
%   \begin{block}{}
%     \begin{lstlisting}
% stmt = conn.createStatement( ... );
% conn.setAutoCommit(false);
% int queryCount = 0;
% int batchSize = 100;
% for ( ... ) {
%     stmt.addBatch(query);
%     queryCount++;
%     if (queryCount % batchSize == 0) {
%         stmt.executeBatch();
%         conn.commit();
%     }
% }
%     \end{lstlisting}
%   \end{block}
% \end{frame}
%
% \begin{frame}
%   \frametitle{Fetch Size}
%
%   \begin{itemize}
%     \item the JDBC drivers prefetch rows from the query
%     \item increases performance, but also increases memory usage
%
%     \pause
%     \medskip
%     \item setting a smaller fetch size decreases memory usage:\\
%       \lstinline!Statement.setFetchSize(count)!
%   \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Fetch Size Example}
%
%   \begin{block}{}
%     \begin{lstlisting}
% stmt.setFetchSize(1);
%
% // MySQL
% stmt.setFetchSize(Integer.MIN_VALUE)
%     \end{lstlisting}
%   \end{block}
% \end{frame}

\section{SQL}

\lstset{language=ExtendedSQL}

\subsection{Stored Procedures}

\begin{frame}
  \frametitle{Stored Procedures}

  \begin{itemize}
    \item implementing functionality in the database server
    \item languages: SQL, PL/SQL, C, ...

    \pause
    \bigskip
    \item not portable
    \pause
    \item not scalable
    \pause
    \item database servers are not optimized for business logic
    \pause
    \item \alert{not recommended}\\
      $\rightarrow$ implement business logic on the application server
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functions}

  \begin{itemize}
    \item creating a function
    \begin{lstlisting}
CREATE FUNCTION
  function_name(parameter_type [, ...])
  RETURNS return_type
  AS function_body
  LANGUAGE language_name
    \end{lstlisting}

    \medskip
    \item first parameter \$1, second parameter \$2, ...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SQL Function Example}

  \begin{itemize}
    \item calculating new score:\\
      \$1: old score, \$2: old votes, \$3: new vote

    \medskip
    \begin{lstlisting}
CREATE FUNCTION NEW_SCORE(float, int, int)
  RETURNS float
  AS 'SELECT ($1 * $2 + $3) / ($2 + 1);'
  LANGUAGE 'sql'
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Triggers}

  \begin{itemize}
    \item \alert{trigger}: a function that will be automatically invoked
      on an event
    \item can be useful for maintaining integrity

    \pause
    \medskip
    \item creating a trigger:
    \smallskip
    \begin{lstlisting}
CREATE TRIGGER trigger_name
  { BEFORE | AFTER } { event [ OR ... ] }
  ON table_name
  [ FOR [ EACH ] { ROW | STATEMENT } ]
  EXECUTE PROCEDURE function_name(...)
    \end{lstlisting}

    \item PL/pgSQL:
    \begin{itemize}
      \item \lstinline!old!: tuple before the operation
      \item \lstinline!new!: tuple after the operation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trigger Example}

  \begin{itemize}
    \item let \lstinline!SCORE * VOTES! be kept in the \lstinline!POINTS! column

    \medskip
    \begin{lstlisting}
CREATE FUNCTION UPDATE_MOVIE_POINTS()
  RETURNS opaque
  AS 'BEGIN
      new.POINTS = new.SCORE * new.VOTES;
      RETURN new;
      END;'
  LANGUAGE 'plpgsql'
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trigger Example}

  \begin{itemize}
    \item calculate \lstinline!POINTS! automatically on updates

    \medskip
    \begin{lstlisting}
CREATE TRIGGER UPDATE_MOVIE
  BEFORE INSERT OR UPDATE ON MOVIE
  FOR EACH ROW
  EXECUTE PROCEDURE UPDATE_MOVIE_POINTS()
    \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Views}

\begin{frame}[fragile]
  \frametitle{Views}

  \begin{itemize}
    \item presenting a derived table like a base table: \alert{view}
    \item isolating users and application programs\\
      from changes in database structure

    \pause
    \bigskip
    \item creating a view:
    \begin{lstlisting}
CREATE VIEW view_name AS
  SELECT ...
    \end{lstlisting}

    \medskip
    \item \lstinline!SELECT! will be executed every time the view is used
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{View Example}

  \begin{itemize}
    \item identifiers, titles and years of new movies

    \medskip
    \begin{lstlisting}
CREATE VIEW NEW_MOVIE AS
  SELECT ID, TITLE, YR FROM MOVIE
    WHERE (YR > 1995)

SELECT * FROM NEW_MOVIE
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Updating Views}

  \begin{itemize}
    \item any change will have to performed on the base tables
    \item rules need to be defined

    \pause
    \bigskip
    \item creating a rule:
    \begin{lstlisting}
CREATE RULE rule_name AS
  ON event TO view_name
  [ WHERE condition ]
  DO [ INSTEAD ] sql_statement
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{View Rule Example}

  \begin{itemize}
    \item modify the title of a new movie
    \begin{lstlisting}
UPDATE NEW_MOVIE SET TITLE = ...
  WHERE (ID = ...)
    \end{lstlisting}

    \pause
    \medskip
    \item rule for updating the base table
    \begin{lstlisting}
CREATE RULE UPDATE_TITLE AS
  ON UPDATE TO NEW_MOVIE
  DO INSTEAD
    UPDATE MOVIE SET TITLE = new.TITLE
      WHERE (ID = old.ID)
    \end{lstlisting}
  \end{itemize}
\end{frame}
%
% \subsection{Permissions}
%
% \begin{frame}[fragile]
%   \frametitle{Permissions}
%
%   \begin{block}{Granting Permissions}
%     \begin{lstlisting}
% GRANT permission_name [, ...]
%   ON object_name TO subject_name
%   [ WITH GRANT OPTION ]
%     \end{lstlisting}
%   \end{block}
%
%   \pause
%   \begin{block}{Revoking Permissions}
%     \begin{lstlisting}
% REVOKE permission_name
%   ON object_name FROM subject_name
%     \end{lstlisting}
%   \end{block}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Permission Examples}
%
%   \begin{example}[granting permissions on a table]
%     \begin{lstlisting}
% GRANT SELECT, INSERT, UPDATE ON MOVIE
%   TO 'itucs'
%     \end{lstlisting}
%   \end{example}
%
%   \pause
%   \begin{example}[revoking permissions on a table]
%     \begin{lstlisting}
% REVOKE INSERT ON MOVIE
%   FROM 'itucs'
%     \end{lstlisting}
%   \end{example}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Bulk Data Transfer}
%
%   \begin{itemize}
%     \item use vendor-specific bulk data transfer commands\\
%       instead of inserting or deleting one-by-one
%
%     \item export to / import from tab separated value files
%   \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Bulk Data Transfer}
%
%   \begin{block}{PostgreSQL}
%     \begin{lstlisting}
% COPY table_name (column_name [, ...])
%   TO 'output_file_path'
%
% COPY table_name (column_name [, ...])
%   FROM 'input_file_path'
%     \end{lstlisting}
%   \end{block}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Bulk Data Transfer}
%
%   \begin{block}{MySQL}
%     \begin{lstlisting}
% SELECT column_name [, ...] FROM table_name
%   INTO OUTFILE 'output_file_path'
%
% LOAD DATA INFILE 'input_file_path'
%   INTO TABLE table_name (column_name [, ...])
%     \end{lstlisting}
%   \end{block}
% \end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required Reading: Date}
    \begin{itemize}
      \item Chapter 4: An Introduction to SQL
      \begin{itemize}
        \item 4.6. Embedded SQL
      \end{itemize}

      \item Chapter 9: Integrity
      \begin{itemize}
        \item 9.11. \alert{Triggers (a Digression)}
      \end{itemize}

      \item Chapter 10: \alert{Views}
    \end{itemize}
  \end{block}

  \begin{block}{Supplementary Reference: Ramakrishnan, Gehrke}
    \begin{itemize}
      \item Chapter 6: Database Application Development
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
