% Copyright (c) 2002-2011
%       H. Turgut Uyar <uyar@itu.edu.tr>
%       Şule Gündüz Öğüdücü <sgunduz@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setbeamertemplate{navigation symbols}{}

\usepackage{listings}
\lstdefinelanguage{ExtendedPHP}[]{PHP}{
  morekeywords={odbc_exec}
}
\lstdefinelanguage{FullSQL}[]{SQL}{
  morekeywords={BINARY,BOOLEAN,CYCLE,FINAL,INCREMENT,IS,LARGE,MAXVALUE,MINVALUE,
                NO_ACTION,OBJECT,REFERENCES,RENAME,SEQUENCE,START,TO,TYPE,VACUUM},
  deletekeywords={YEAR}
}
\lstdefinelanguage{ExtendedSQL}[]{FullSQL}{
  morekeywords={AFTER,BEFORE,DO,EACH,FOR,FUNCTION,INSTEAD,LANGUAGE,OPTION,
                PROCEDURE,RETURNS,ROW,RULE,SNAPSHOT,STATEMENT,WITH}
}
\lstdefinelanguage{EmbeddedSQL}[]{FullSQL}{
  morekeywords={BEGIN,CLOSE,CONTINUE,CURSOR,DECLARE,FETCH,FOR,DO,END,EXEC,FOUND,
                GOTO,INCLUDE,INTO,OPEN,SECTION,SQL,SQLERROR,SQLWARNING,
                STATEMENT,STOP,WHENEVER,sqlca,sqlcode}
}

\mode<presentation>
{
  \usetheme{Warsaw}
  \usecolortheme[named=ForestGreen]{structure}
  \setbeamercovered{transparent}
}

\title{Database Systems}
\subtitle{Application Development}

\author{H. Turgut Uyar \and Şule Öğüdücü}
\date{2002-2011}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Topics}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[height=6cm]{esql}{esql}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2002-2011 T. Uyar, Ş. Öğüdücü

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share — to copy, distribute and transmit the work
      \item to Remix — to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution — You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial — You may not use this work for commercial purposes.

      \item Share Alike — If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}
\end{frame}

\begin{frame}
  \frametitle{Topics}
  \tableofcontents
\end{frame}

\section{Application Development}

\subsection{Introduction}

\begin{frame}
  \frametitle{Introduction}

  \begin{itemize}
    \item using the database language in conjunction\\
      with a general-purpose programming language
    \item general-purpose language: \alert{host language}

    \pause
    \bigskip
    \item mismatch between SQL and the host language:
    \begin{itemize}
      \item SQL operations on sets
      \item iteration constructs in programming languages
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Program Structure}

  \begin{itemize}
    \item connect
    \begin{itemize}
      \item server, database, username, password
    \end{itemize}

    \pause
    \medskip
    \item run statements as necessary:
    \begin{itemize}
      \item update operations return number of affected rows
      \item query operations return result sets\\
        $\rightarrow$ iterate over rows
    \end{itemize}

    \pause
    \medskip
    \item disconnect
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Approaches}

  \begin{itemize}
    \item application programming interface (API)
    \item embedded SQL
    \item ODBC
    \item language standard interfaces
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Application Programming Interface}

  \begin{itemize}
    \item using the library functions of the SQL server

    \pause
    \bigskip
    \item pros: fast
    \item cons: specific to the SQL product
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example}

  \begin{example}[PostgreSQL - C]
    \begin{lstlisting}[language=C]
#include <libpq-fe.h>

int main(void)
{
    /* connect */
    /* execute query */
    /* disconnect */
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example}

  \begin{example}[connecting]
    \begin{lstlisting}[language=C]
/* PGconn *conn; */

conn = PQconnectdb("host=localhost dbname=imdb"
                " user=itucs password=itucs");
if (PQstatus(conn) == CONNECTION_BAD) {
    fprintf(stderr, "Connection failed.\n");
    exit(1);
}
/* execute query */
PQfinish(conn);
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example}

  \begin{example}[executing a query]
    \begin{lstlisting}[language=C]
/* PGresult *result; */

sprintf(query, "SELECT TITLE,SCORE"
        " FROM MOVIE WHERE (YEAR = %d)", year);
result = PQexec(conn, query);
if (PQresultStatus(result) != PGRES_TUPLES_OK) {
    fprintf(stderr, "Query failed.\n");
    PQclear(result);
    PQfinish(conn);
    exit(1);
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{API Example}

  \begin{example}[processing the result set]
    \begin{lstlisting}[language=C]
for (i = 0; i < PQntuples(result); i++) {
    title = PQgetvalue(result, i, 0);
    score = PQgetvalue(result, i, 1);
    ...
}

PQclear(result);
    \end{lstlisting}
  \end{example}
\end{frame}

\subsection{Embedded SQL}

\begin{frame}
  \frametitle{Embedded SQL}

  \begin{itemize}
    \item stages:
    \begin{enumerate}
      \item mark SQL statements within host language code:\\
        \lstinline!EXEC SQL!
      \item embedded SQL preprocessor:\\
        embedded SQL directives $\rightarrow$ API calls
      \item host language compiler
    \end{enumerate}

    \pause
    \bigskip
    \item pros: fast, standard
    \item cons: difficult, does not support most languages

    \bigskip
    \hyperlink{odbc}{\beamergotobutton{skip Embedded SQL}}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Embedded SQL}

  \begin{center}
    \pgfuseimage{esql}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Embedded SQL Standard}

  \begin{itemize}
    \item sharing variables with the host language
    \item error control
    \item adapting query results
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Variable Sharing}

  \begin{block}{Syntax}
    \begin{lstlisting}[language=EmbeddedSQL]
EXEC SQL BEGIN DECLARE SECTION;
shared variables
EXEC SQL END DECLARE SECTION;
    \end{lstlisting}
  \end{block}

  \begin{itemize}
    \item '\lstinline!:!' in front of host language variables in SQL statements
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Error Control}

  \begin{block}{Error Processing}
    \begin{lstlisting}[language=EmbeddedSQL]
EXEC SQL WHENEVER
  { SQLERROR | SQLWARNING | NOT FOUND }
  { STOP | CONTINUE | DO command | GOTO label }
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Adapting Query Results}

  \begin{block}{Cursors}
    \begin{lstlisting}[language=EmbeddedSQL]
EXEC SQL DECLARE cursor_name CURSOR FOR
    SELECT ...;
EXEC SQL OPEN cursor_name;
EXEC SQL FETCH IN cursor_name INTO variables;
EXEC SQL CLOSE cursor_name;
    \end{lstlisting}
  \end{block}

  \pause
  \begin{itemize}
    \item query is not executed when cursor is defined
    \item it is executed when cursor is opened
    \begin{itemize}
      \item cursor points to first element in the result set
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example}

  \begin{example}[connecting]
    \begin{lstlisting}[language=C]
EXEC SQL BEGIN DECLARE SECTION;
int year;
char *title = NULL, *score = NULL;
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO imdb
    USER itucs IDENTIFIED BY itucs;

/* process query */

EXEC SQL DISCONNECT;
    \end{lstlisting}
 \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example}

  \begin{example}[processing query]
    \begin{lstlisting}[language=C]
scanf("%d", &year);
EXEC SQL DECLARE c_query CURSOR FOR
    SELECT TITLE, SCORE FROM MOVIE
      WHERE (YEAR = :year);
EXEC SQL OPEN c_query;

/* execute query */

EXEC SQL CLOSE c_query;
EXEC SQL COMMIT;
    \end{lstlisting}
 \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Embedded SQL Example}

  \begin{example}[executing query]
    \begin{lstlisting}[language=C]
EXEC SQL WHENEVER NOT FOUND DO break;
while (1) {
    EXEC SQL FETCH c_query INTO :title, :score;
    ...
}
    \end{lstlisting}
 \end{example}
\end{frame}

\subsection{ODBC}

\begin{frame}[label=odbc]
  \frametitle{ODBC}

  \begin{itemize}
    \item \alert{ODBC}: Open DataBase Connectivity\\
      a service layer between the application and the server

    \pause
    \bigskip
    \item pros: standard
    \item cons: slow
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ODBC Architecture}

  \begin{itemize}
    \item application

    \pause
    \item driver manager
    \begin{itemize}
      \item registers the ODBC drivers
      \item transfers requests from application to driver
    \end{itemize}

    \pause
    \item driver
    \begin{itemize}
      \item translates and transfers requests to data source
    \end{itemize}

    \pause
    \item data source
    \begin{itemize}
      \item processes instructions from the driver
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Example}

  \begin{example}[PHP]
    \begin{lstlisting}[language=ExtendedPHP]
$conn = odbc_connect("imdb", "itucs", "itucs");
$query = "SELECT TITLE, SCORE FROM MOVIE"
       . " WHERE (YEAR = " . $year . ")";
$result = odbc_exec($conn, $query);

/* process the result set */

odbc_close($conn);
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Example}

  \begin{example}[processing the result set]
    \begin{lstlisting}[language=ExtendedPHP]
echo "<table>\n";
while (odbc_fetch_row($result)) {
  $title = odbc_result($result, "title");
  $score = odbc_result($result, "score");
  echo "<tr>\n";
  echo "  <td>$title</td>\n";
  echo "  <td>$score</td>\n";
  echo "</tr>\n";
}
echo "</table>\n";
    \end{lstlisting}
  \end{example}
\end{frame}

\section{JDBC}

\subsection{Architecture}

\begin{frame}
  \frametitle{JDBC}

  \begin{itemize}
    \item \alert{JDBC}: Java DataBase Connectivity

    \pause
    \item same architectural concepts as in ODBC
    \begin{itemize}
      \item different types of drivers
    \end{itemize}

    \pause
    \item JDBC URL for connection
    \begin{itemize}
      \item \lstinline!jdbc:<subprotocol>:<parameters>!
    \end{itemize}

    \pause
    \item matching Java and SQL data types
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JDBC Drivers}

  \begin{itemize}
    \item \emph{Type I}: bridges
    \begin{itemize}
      \item translate into non-native calls (for example ODBC)
    \end{itemize}

    \pause
    \item \emph{Type II}: direct translation via non-Java driver
    \begin{itemize}
      \item translate into API of data source (for example C++)
    \end{itemize}

    \pause
    \item \emph{Type III}: network bridges
    \begin{itemize}
      \item connect to middleware server\\
	for translating into API of data source
    \end{itemize}

    \pause
    \item \emph{Type IV}: direct translation via Java driver
    \begin{itemize}
      \item communicate with DBMS through Java sockets
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{API}

\begin{frame}
  \frametitle{JDBC Flow}

  \begin{itemize}
    \item get a connection object
    \begin{itemize}
      \item static: \lstinline!DriverManager.getConnection()!
	$\rightarrow$ \lstinline!Connection!
    \end{itemize}

    \pause
    \medskip
    \item create a statement object on the connection
    \begin{itemize}
      \item \lstinline!Connection.createStatement()!
	 $\rightarrow$ \lstinline!Statement!
    \end{itemize}

    \pause
    \medskip
    \item execute the query
    \begin{itemize}
      \item read: \lstinline!Statement.executeQuery(query)!
	$\rightarrow$ \lstinline!ResultSet!
      \item insert, update, delete: \lstinline!Statement.executeUpdate(query)!
    \end{itemize}

    \pause
    \medskip
    \item process the results

    \pause
    \medskip
    \item close resources (result set, statement, connection)\\
      which are no longer needed
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Processing Results}

  \begin{itemize}
    \item \lstinline!ResultSet! is an iterator
    \begin{itemize}
      \item whether there are more rows: \lstinline!ResultSet.hasNext()!
      \item proceed to the next row: \lstinline!ResultSet.next()!
    \end{itemize}

    \pause
    \medskip
    \item convert and transfer data in the row to variables
    \begin{itemize}
      \item by column name: \lstinline!ResultSet.getXXX(column_name)!
      \item by column order: \lstinline!ResultSet.getXXX(column_order)!
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Data Type Conversions}

  \begin{table}
    \begin{tabular}{|l|l|l|}\hline
SQL type  & Java class         & ResultSet method\\\hline\hline
BIT       & Boolean            & getBoolean()    \\\hline
CHAR      & String             & getString()     \\\hline
VARCHAR   & String             & getString()     \\\hline
DOUBLE    & Double             & getDouble()     \\\hline
FLOAT     & Float              & getDouble()     \\\hline
INTEGER   & Integer            & getInt()        \\\hline
REAL      & Double             & getFloat()      \\\hline
DATE      & java.sql.Date      & getDate()       \\\hline
TIME      & java.sql.Time      & getTime()       \\\hline
TIMESTAMP & java.sql.TimeStamp & getTimestamp()  \\\hline
    \end{tabular}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example}

  \begin{example}[loading the database driver]
    \begin{lstlisting}[language=Java]
try {
  Class.forName("org.postgresql.Driver");
} catch (ClassNotFoundException e) {
  // PostgreSQL driver not installed
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example}

  \begin{example}[connecting]
    \begin{lstlisting}[language=Java]
try {
  Connection conn = DriverManager.getConnection(
      "jdbc:postgresql:imdb", "itucs", "itucs"
  );
} catch (SQLException e) {
  // connection error
}
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example}

  \begin{example}[inserting]
    \begin{lstlisting}[language=Java]
String query = "INSERT INTO MOVIE (TITLE, YEAR)"
    + " VALUES ('Casablanca', 1942)";
Statement stmt = conn.createStatement();
stmt.executeUpdate(query);
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Prepared Statements}

  \begin{itemize}
    \item prepared statements can be reused\\
      by changing parameter values

    \pause
    \medskip
    \item creating:\\
      \lstinline!Connection.prepareStatement(query)!
      $\rightarrow$ \lstinline!PreparedStatement!
    \item placeholder for parameters in query: '\lstinline!?!'
    \begin{itemize}
      \item values must be set before executing:\\
	\lstinline!PreparedStatement.setXXX(parameter_order, parameter_value)!
    \end{itemize}

    \pause
    \medskip
    \item executing: \lstinline!PreparedStatement.executeQuery()!\\
      or \lstinline!PreparedStatement.executeUpdate()!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Prepared Statement Example}

  \begin{example}[inserting - using prepared statement]
    \begin{lstlisting}[language=Java]
String query = "INSERT INTO MOVIE (TITLE, YEAR)"
    + " VALUES (?, ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
for (Movie movie : getMovies()) {
  stmt.setString(1, movie.getTitle());
  stmt.setInt(2, movie.getYear());
  stmt.executeUpdate(query);
}
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Result Set Example}

  \begin{example}[listing movie titles in a year]
    \begin{lstlisting}[language=Java]
String query = String.format(
  "SELECT TITLE FROM MOVIE WHERE (YEAR = %d)",
  year);
Statement stmt = conn.createStatement();
ResultSet results = stmt.executeQuery(query);
while (results.next()) {
  String title = results.getString("TITLE");
  System.out.println("Title: " + title),
}
results.close();
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example}

  \begin{example}[deleting]
    \begin{lstlisting}[language=Java]
String query = "DELETE FROM MOVIE" +
    " WHERE (ID = ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
stmt.setInt(1, movie.getId());
stmt.executeUpdate();
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Example}

  \begin{example}[updating]
    \begin{lstlisting}[language=Java]
String query = "UPDATE MOVIE SET YEAR = ?" +
    " WHERE (ID = ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
stmt.setInt(1, movie.getYear());
stmt.setInt(2, movie.getId());
stmt.executeUpdate();
stmt.close();
    \end{lstlisting}
  \end{example}
\end{frame}

\subsection{Tips}

\begin{frame}
  \frametitle{Closing Resources}

  \begin{itemize}
    \item it is recommended to close resources\\
      like results sets and statements\\
      in the \lstinline!finally! part
      of \lstinline!try - catch - finally! blocks
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Resource Closing Example}

  \begin{block}{}
    \begin{lstlisting}[language=Java]
Statement stmt = conn.createStatement();
ResultSet results = null;
try {
    results = stmt.executeQuery(query);
    ...
} catch (SQLException e) {
    ...
} finally {
    results.close();
    stmt.close();
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Getting Auto-Generated Identity Values}

  \begin{itemize}
    \item use the \lstinline!RETURN_GENERATED_KEYS! flag\\
      when creating the statement
    \item \lstinline!Statement.getGeneratedKeys()! $\rightarrow$
      \lstinline!ResultSet!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Getting Auto-Generated Keys Example}

  \begin{block}{}
    \begin{lstlisting}[language=Java]
String query = "INSERT INTO ... ";
PreparedStatement stmt =
    connection.prepareStatement(query,
        Statement.RETURN_GENERATED_KEYS);

stmt.executeUpdate();

ResultSet ids = statement.getGeneratedKeys();
// assuming there is one and only one result
ids.next();
int id = ids.getInt(1);
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Batch Mode}

  \begin{itemize}
    \item accumulating statements to run them in batches\\
      might be faster

    \pause
    \medskip
    \item get the connection out of "auto commit" mode
    \item accumulate: \lstinline!Statement.addBatch(query)!
    \item execute accumulated statements: \lstinline!Statement.executeBatch()!
    \item finalizing changes: \lstinline!Connection.commit()!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Batch Mode}

  \begin{block}{}
    \begin{lstlisting}[language=Java]
stmt = conn.createStatement( ... );
conn.setAutoCommit(false);
int queryCount = 0;
int batchSize = 100;
for ( ... ) {
    stmt.addBatch(query);
    queryCount++;
    if (queryCount % batchSize == 0) {
        stmt.executeBatch();
        conn.commit();
    }
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Fetch Size}

  \begin{itemize}
    \item the JDBC drivers prefetch rows from the query
    \item increases performance, but also increases memory usage

    \pause
    \medskip
    \item setting a smaller fetch size decreases memory usage:\\
      \lstinline!Statement.setFetchSize(count)!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fetch Size Example}

  \begin{block}{}
    \begin{lstlisting}[language=Java]
stmt.setFetchSize(1);

// MySQL
stmt.setFetchSize(Integer.MIN_VALUE)
    \end{lstlisting}
  \end{block}
\end{frame}

\section{SQL Facilities}

\subsection{Stored Procedures}

\begin{frame}
  \frametitle{Stored Procedures}

  \begin{itemize}
    \item implementing functionality in the database server
    \begin{itemize}
      \item languages: SQL, PL/SQL, C, ...
    \end{itemize}

    \pause
    \bigskip
    \item \alert{not recommended}
    \begin{itemize}
      \item not portable
      \item database servers are not optimized for business logic
    \end{itemize}
    $\rightarrow$ implement business logic on the application server
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creating Functions}

  \begin{block}{Statement}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE FUNCTION
  function_name([parameter_type [, ...]])
  RETURNS return_type
  AS function_body
  LANGUAGE language_name
    \end{lstlisting}
  \end{block}

  \pause
  \begin{itemize}
    \item first parameter \$1, second parameter \$2, ...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SQL Function Example}

  \begin{example}[calculating new score]
    \$1: old score, \$2: old votes, \$3: new vote
    \begin{lstlisting}[language=ExtendedSQL]
CREATE FUNCTION NEW_SCORE(float, int, int)
  RETURNS float
  AS 'SELECT ($1*$2+$3) / ($2+1);'
  LANGUAGE 'sql'
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{Triggers}

  \begin{definition}
    \alert{trigger}: a function that will be automatically activated on an event
  \end{definition}

  \begin{itemize}
    \item can be useful for maintaining integrity
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creating Triggers}

  \begin{block}{Statement}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE TRIGGER trigger_name
  { BEFORE | AFTER } { event [ OR ... ] }
  ON table_name
  [ FOR [ EACH ] { ROW | STATEMENT } ]
  EXECUTE PROCEDURE function_name(...)
    \end{lstlisting}
  \end{block}

  \pause
  \begin{itemize}
    \item PL/pgSQL:
    \begin{itemize}
      \item \lstinline!old!: tuple before the operation
      \item \lstinline!new!: tuple after the operation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trigger Example}

  \begin{example}[let SCORE * VOTES be kept in the POINTS column]
    \begin{lstlisting}[language=ExtendedSQL]
CREATE FUNCTION UPDATE_MOVIE_POINTS()
  RETURNS opaque
  AS 'BEGIN
      new.POINTS = new.SCORE * new.VOTES;
      RETURN new;
      END;'
  LANGUAGE 'plpgsql'
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Trigger Example}

  \begin{example}[calculate POINTS automatically on updates]
    \begin{lstlisting}[language=ExtendedSQL]
CREATE TRIGGER UPDATE_MOVIE
  BEFORE INSERT OR UPDATE ON MOVIE
  FOR EACH ROW
  EXECUTE PROCEDURE UPDATE_MOVIE_POINTS()
    \end{lstlisting}
  \end{example}
\end{frame}

\subsection{Views}

\begin{frame}
  \frametitle{Views}

  \begin{itemize}
    \item presenting a derived table like a base table

    \pause
    \item isolating users and application programs\\
      from changes in database structure
%     \begin{itemize}
%       \item denormalizing after database refactoring
%     \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creating Views}

  \begin{block}{Statement}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE VIEW view_name AS
  SELECT ...
    \end{lstlisting}
  \end{block}

  \pause
  \begin{itemize}
    \item the \lstinline!SELECT! query will be executed every time the view is
      used
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{View Example}

  \begin{example}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE VIEW NEW_MOVIE AS
  SELECT ID, TITLE, YEAR FROM MOVIE
    WHERE (YEAR > 1995)
    \end{lstlisting}

    \pause
    \begin{lstlisting}[language=ExtendedSQL]
SELECT * FROM NEW_MOVIE
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Updating Views}

  \begin{itemize}
    \item changes have to performed on the base tables
    \begin{itemize}
      \item rules need to be defined
    \end{itemize}
  \end{itemize}

  \pause
  \begin{block}{Creating Rules}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE RULE rule_name AS
  ON event TO view_name
  [ WHERE condition ]
  DO [ INSTEAD ] sql_statement
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{View Rule Example}

  \begin{example}
    \begin{lstlisting}[language=ExtendedSQL]
UPDATE NEW_MOVIE SET TITLE='..'
  WHERE (ID = 1)
    \end{lstlisting}

    \pause
    \begin{lstlisting}[language=ExtendedSQL]
CREATE RULE UPDATE_TITLE AS
  ON UPDATE TO NEW_MOVIE
  DO INSTEAD
    UPDATE MOVIE SET TITLE = new.TITLE
      WHERE (ID = old.ID)
    \end{lstlisting}
  \end{example}
\end{frame}

% \begin{frame}
%   \frametitle{Snapshots}
%
%   \begin{itemize}
%     \item similar to view but creates a new base table
%     \begin{itemize}
%       \item the query is executed only once when snapshot is created
%     \end{itemize}
%
%     \pause
%     \medskip
%     \item changes to base tables do not effect the snapshot
%     \item no updates on the snapshot
%   \end{itemize}
% \end{frame}
%
% \begin{frame}[fragile]
%   \frametitle{Creating Snapshots}
%
%   \begin{block}{SQL Statement}
%     \begin{lstlisting}[language=ExtendedSQL]
% CREATE SNAPSHOT snapshot_name AS
%   SELECT ...
%     \end{lstlisting}
%   \end{block}
% \end{frame}

\subsection{Permissions}

\begin{frame}
  \frametitle{Permissions}

  \begin{itemize}
    \item \alert{subject}: active entities (user, group)
    \item \alert{object}: passive entities (table, column, view, ...)

    \pause
    \item owner of object determines permissions of other subjects:\\
      \emph{discretionary access control}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SQL Permissions}

  \begin{block}{Granting Permissions}
    \begin{lstlisting}[language=ExtendedSQL]
GRANT permission_name [, ...]
  ON object_name TO subject_name
  [ WITH GRANT OPTION ]
    \end{lstlisting}
  \end{block}

  \pause
  \begin{block}{Revoking Permissions}
    \begin{lstlisting}[language=ExtendedSQL]
REVOKE permission_name
  ON object_name FROM subject_name
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Permission Examples}

  \begin{example}[granting permissions on a table]
    \begin{lstlisting}[language=ExtendedSQL]
GRANT SELECT, INSERT, UPDATE ON MOVIE TO 'itucs'
    \end{lstlisting}
  \end{example}

  \pause
  \begin{example}[granting permissions on a view]
    \begin{lstlisting}[language=ExtendedSQL]
GRANT SELECT ON NEW_MOVIES TO 'itucs'
    \end{lstlisting}
  \end{example}

  \pause
  \begin{example}[revoking permissions on a table]
    \begin{lstlisting}[language=ExtendedSQL]
REVOKE INSERT ON MOVIE FROM 'itucs'
    \end{lstlisting}
  \end{example}
\end{frame}

\subsection{Tips}

\begin{frame}[fragile]
  \frametitle{Indexes}

  \begin{itemize}
    \item some operations require sorting:\\
      \lstinline!ORDER BY, DISTINCT, GROUP BY, UNION, ...!

    \pause
    \item creating indexes speeds up queries
    \begin{itemize}
      \item speeds down insert and update operations
    \end{itemize}
  \end{itemize}

  \pause
  \begin{block}{SQL Statement}
    \begin{lstlisting}[language=ExtendedSQL]
CREATE [ UNIQUE ] INDEX index_name
  ON table_name(column_name [, ...])
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Bulk Data Transfer}

  \begin{itemize}
    \item use vendor-specific bulk data transfer commands\\
      instead of inserting or deleting one-by-one

    \item export to / import from tab separated value files
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Bulk Data Transfer}

  \begin{block}{PostgreSQL}
    \begin{lstlisting}
COPY table_name (column_name [, ...])
  TO 'output_file_path'

COPY table_name (column_name [, ...])
  FROM 'input_file_path'
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Bulk Data Transfer}

  \begin{block}{MySQL}
    \begin{lstlisting}
SELECT column_name [, ...] FROM table_name
  INTO OUTFILE 'output_file_path'

LOAD DATA INFILE 'input_file_path'
  INTO TABLE table_name (column_name [, ...])
    \end{lstlisting}
  \end{block}
\end{frame}

\section*{References}

\begin{frame}
  \frametitle{References}

  \begin{block}{Required text: Date}
    \begin{itemize}
      \item Chapter 4: An Introduction to SQL
      \begin{itemize}
        \item 4.6. Embedded SQL
      \end{itemize}

      \item Chapter 9: Integrity
      \begin{itemize}
        \item 9.11. \alert{Triggers (a Digression)}
      \end{itemize}

      \item Chapter 10: \alert{Views}
    \end{itemize}
  \end{block}

  \begin{block}{Supplementary text: Ramakrishnan, Gehrke}
    \begin{itemize}
      \item Chapter 6: Database Application Development
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
