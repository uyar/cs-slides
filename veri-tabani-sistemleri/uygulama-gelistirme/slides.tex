% Copyright (c) 2002-2012
%       H. Turgut Uyar <uyar@itu.edu.tr>
%       Şule Gündüz Öğüdücü <sgunduz@itu.edu.tr>
%
% These notes are licensed using the
% "Creative Commons Attribution-NonCommercial-ShareAlike License".
% You are free to copy, distribute and transmit the work, and to adapt the work
% as long as you attribute the authors, do not use it for commercial purposes,
% and any derivative work is under the same or a similar license.
%
% Read the full legal code at:
% http://creativecommons.org/licenses/by-nc-sa/3.0/

\documentclass[dvipsnames]{beamer}

\usepackage{ae}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[turkish]{babel}
\setbeamertemplate{navigation symbols}{}
\usepackage[labelformat=empty, aboveskip=1pt, belowskip=1pt]{caption}

\usepackage{listings}
\lstdefinelanguage{ExtendedPHP}[]{PHP}{
  morekeywords={odbc_exec}
}
\lstdefinelanguage{FullSQL}[]{SQL}{
  morekeywords={BINARY, BOOLEAN, CYCLE, FINAL, INCREMENT, IS, LARGE, MAXVALUE,
                MINVALUE, NO_ACTION, OBJECT, REFERENCES, RENAME, SEQUENCE,
                START, TO, TYPE, VACUUM}
}
\lstdefinelanguage{ExtendedSQL}[]{FullSQL}{
  morekeywords={AFTER, BEFORE, DO, EACH, FOR, FUNCTION, INSTEAD, LANGUAGE,
                OPTION, PROCEDURE, RETURNS, ROW, RULE, SNAPSHOT, STATEMENT,
                WITH}
}
\lstdefinelanguage{EmbeddedSQL}[]{FullSQL}{
  morekeywords={BEGIN, CLOSE, CONTINUE, CURSOR, DECLARE, FETCH, FOR, DO, END,
                EXEC, FOUND, GOTO, INCLUDE, INTO, OPEN, SECTION, SQL, SQLERROR,
                SQLWARNING, STATEMENT, STOP, WHENEVER, sqlca, sqlcode}
}
\lstset{basicstyle=\ttfamily, keywordstyle=\color{blue}}

\mode<presentation>
{
  \usetheme{Warsaw}
  \usecolortheme[named=ForestGreen]{structure}
  \setbeamercovered{transparent}
}

\title{Veri Tabanı Sistemleri}
\subtitle{Uygulama Geliştirme}

\author{H. Turgut Uyar \and Şule Öğüdücü}
\date{2002-2012}

\AtBeginSubsection[]{
  \begin{frame}<beamer>
    \frametitle{Konular}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\theoremstyle{definition}
\newtheorem{tanim}[theorem]{Tanım}

\theoremstyle{example}
\newtheorem{ornek}[theorem]{Örnek}

\theoremstyle{plain}

\pgfdeclareimage[width=2cm]{license}{../../license}

\pgfdeclareimage[height=6cm]{esql}{esql}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{License}

  \pgfuseimage{license}\hfill
  \copyright 2002-2012 T. Uyar, Ş. Öğüdücü

  \vfill
  \begin{tiny}
    You are free:
    \begin{itemize}
      \item to Share -- to copy, distribute and transmit the work
      \item to Remix -- to adapt the work
    \end{itemize}

    Under the following conditions:
    \begin{itemize}
      \item Attribution -- You must attribute the work in the manner specified by
        the author or licensor (but not in any way that suggests that they
        endorse you or your use of the work).

      \item Noncommercial -- You may not use this work for commercial purposes.

      \item Share Alike -- If you alter, transform, or build upon this work, you
        may distribute the resulting work only under the same or similar license
        to this one.
    \end{itemize}
  \end{tiny}

  \vfill
  Legal code (the full license):\\
  \url{http://creativecommons.org/licenses/by-nc-sa/3.0/}
\end{frame}

\begin{frame}
  \frametitle{Konular}
  \tableofcontents
\end{frame}

\section{Uygulama Geliştirme}

\lstset{language=C}

\subsection{Giriş}

\begin{frame}
  \frametitle{Giriş}

  \begin{itemize}
    \item veri tabanı dili ile genel amaçlı bir programlama dilinin\\
      birlikte kullanımı
    \item uygulamanın yazıldığı genel amaçlı dil: \alert{taban dil}

    \pause
    \bigskip
    \item SQL ile taban dil arasında uyumsuzluk:
    \begin{itemize}
      \item SQL işlemleri kümeler üzerinde
      \item genel amaçlı dillerde yineleme yapıları
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Program Yapısı}

  \begin{itemize}
    \item bağlantı kur
    \begin{itemize}
      \item sunucu, veri tabanı, kullanıcı adı, parola
    \end{itemize}

    \pause
    \medskip
    \item gerektikçe komut çalıştır:
    \begin{itemize}
      \item güncelleme işlemleri işlemden etkilenen satır sayısını döndürür
      \item sorgulama işlemleri sonuç kümeleri döndürür\\
        $\rightarrow$ döngüyle satır satır gez
    \end{itemize}

    \pause
    \medskip
    \item bağlantıyı kopar
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Uygulama Geliştirme Yöntemleri}

  \begin{itemize}
    \item uygulama programı arayüzü (API)
    \item gömülü SQL
    \item ODBC
    \item dil standart arayüzleri
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Uygulama Programı Arayüzü}

  \begin{itemize}
    \item SQL sunucusunun kitaplık fonksiyonlarını çağırarak

    \pause
    \bigskip
    \item avantajı: hızlı
    \item dezavantajı: sunucudan sunucuya değişiyor
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uygulama Programı Arayüzü Örneği}

  \begin{ornek}[PostgreSQL - C]
    \begin{lstlisting}
#include <libpq-fe.h>

int main(int argc, char *argv[])
{
    /* connect */
    /* execute query */
    /* disconnect */
}
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uygulama Programı Arayüzü Örneği}

  \begin{ornek}[veri tabanı bağlantısı]
    \begin{lstlisting}
/* PGconn *conn; */

conn = PQconnectdb("host=localhost dbname=imdb"
                " user=itucs password=itucs");
if (PQstatus(conn) == CONNECTION_BAD) {
    fprintf(stderr, "Connection failed.\n");
    exit(1);
}
/* execute query */
PQfinish(conn);
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uygulama Programı Arayüzü Örneği}

  \begin{ornek}[sorgunun işlenişi]
    \begin{lstlisting}
/* PGresult *result; */

sprintf(query, "SELECT TITLE, SCORE"
        " FROM MOVIE WHERE (YR = %d)", year);
result = PQexec(conn, query);
if (PQresultStatus(result) != PGRES_TUPLES_OK) {
    fprintf(stderr, "Query failed.\n");
    PQclear(result);
    PQfinish(conn);
    exit(1);
}
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Uygulama Programı Arayüzü Örneği}

  \begin{ornek}[sonuç kümesinin işlenişi]
    \begin{lstlisting}
for (i = 0; i < PQntuples(result); i++) {
    title = PQgetvalue(result, i, 0);
    score = PQgetvalue(result, i, 1);
    ...
}

PQclear(result);
    \end{lstlisting}
  \end{ornek}
\end{frame}

\lstset{language=EmbeddedSQL}

\subsection{Gömülü SQL}

\begin{frame}
  \frametitle{Gömülü SQL}

  \begin{itemize}
    \item aşamalar:
    \begin{enumerate}
      \item taban dil içinde SQL komutları işaretlenir: \lstinline!EXEC SQL!
      \item gömülü SQL önişleyicisi:\\
        gömülü SQL komutları $\rightarrow$ uygulama programı arayüzü çağrıları
      \item taban dil derleyicisi
    \end{enumerate}

    \pause
    \bigskip
    \item avantajları: hızlı, standart
    \item dezavantajları: kullanışsız, farklı diller için desteği yok

    \bigskip
    \hyperlink{odbc}{\beamergotobutton{Gömülü SQL bölümünü atla}}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Gömülü SQL}

  \begin{center}
    \pgfuseimage{esql}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Gömülü SQL Standardı}

  \begin{itemize}
    \item taban dil ile değişken paylaşımı
    \item hata denetimi
    \item sorgu sonuçlarının uyarlanması
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Değişken Paylaşımı}

  \begin{block}{Yazım}
    \begin{lstlisting}
EXEC SQL BEGIN DECLARE SECTION;
shared variables
EXEC SQL END DECLARE SECTION;
    \end{lstlisting}
  \end{block}

  \begin{itemize}
    \item SQL komutlarında taban dil değişkenlerinin önüne '\lstinline!:!'
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hata Denetimi}

  \begin{block}{Hata İşleme}
    \begin{lstlisting}
EXEC SQL WHENEVER
  { SQLERROR | SQLWARNING | NOT FOUND }
  { STOP | CONTINUE | DO command | GOTO label }
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sorgu Sonuçlarının Uyarlanması}

  \begin{block}{İmleçler}
    \begin{lstlisting}
EXEC SQL DECLARE cursor_name CURSOR FOR
    SELECT ...;
EXEC SQL OPEN cursor_name;
EXEC SQL FETCH IN cursor_name INTO variables;
EXEC SQL CLOSE cursor_name;
    \end{lstlisting}
  \end{block}

  \pause
  \begin{itemize}
    \item tanımlama işleminde sorgu çalıştırılmaz
    \item açma işlemiyle sorgu çalıştırılır
    \begin{itemize}
      \item imleç sonuç kümesinin ilk satırına konumlandırılır
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Gömülü SQL Örneği}

  \begin{ornek}[veri tabanına bağlanma]
    \begin{lstlisting}[language=C]
EXEC SQL BEGIN DECLARE SECTION;
int year;
char *title = NULL, *score = NULL;
EXEC SQL END DECLARE SECTION;

EXEC SQL CONNECT TO imdb
    USER itucs IDENTIFIED BY itucs;

/* process query */

EXEC SQL DISCONNECT;
    \end{lstlisting}
 \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Gömülü SQL Örneği}

  \begin{ornek}[sorgunun işlenmesi]
    \begin{lstlisting}[language=C]
scanf("%d", &year);
EXEC SQL DECLARE c_query CURSOR FOR
    SELECT TITLE, SCORE FROM MOVIE
      WHERE (YR = :year);
EXEC SQL OPEN c_query;

/* execute query */

EXEC SQL CLOSE c_query;
EXEC SQL COMMIT;
    \end{lstlisting}
 \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Gömülü SQL Örneği}

  \begin{ornek}[sorgunun çalıştırılması]
    \begin{lstlisting}[language=C]
EXEC SQL WHENEVER NOT FOUND DO break;
while (1) {
    EXEC SQL FETCH c_query INTO :title, :score;
    ...
}
    \end{lstlisting}
 \end{ornek}
\end{frame}

\lstset{language=ExtendedPHP}

\subsection{ODBC}

\begin{frame}[label=odbc]
  \frametitle{ODBC}

  \begin{itemize}
    \item \alert{ODBC}: Open DataBase Connectivity\\
      uygulama ile sunucu arasında bir servis katmanı

    \pause
    \bigskip
    \item avantajları: standart
    \item dezavantajları: yavaş
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{ODBC Mimarisi}

  \begin{itemize}
    \item uygulama

    \pause
    \item sürücü yöneticisi
    \begin{itemize}
      \item ODBC sürücülerini kaydeder
      \item uygulamadan gelen ODBC isteklerini ilgili sürücüye aktarır
    \end{itemize}

    \pause
    \item sürücü
    \begin{itemize}
      \item istekleri veri kaynağına uygun şekilde iletir
    \end{itemize}

    \pause
    \item veri kaynağı
    \begin{itemize}
      \item sürücüden gelen komutları işler
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Örneği}

  \begin{ornek}[PHP]
    \begin{lstlisting}
$conn = odbc_connect("imdb", "itucs", "itucs");
$query = "SELECT TITLE, SCORE FROM MOVIE"
       . " WHERE (YR = " . $year . ")";
$result = odbc_exec($conn, $query);

/* process the result set */

odbc_close($conn);
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ODBC Örneği}

  \begin{ornek}[sonuç kümesinin işlenmesi]
    \begin{lstlisting}
echo "<table>\n";
while (odbc_fetch_row($result)) {
    $title = odbc_result($result, "title");
    $score = odbc_result($result, "score");
    echo "<tr>\n";
    echo "  <td>$title</td>\n";
    echo "  <td>$score</td>\n";
    echo "</tr>\n";
}
echo "</table>\n";
    \end{lstlisting}
  \end{ornek}
\end{frame}

\lstset{language=Java}

\subsection{JDBC}

\begin{frame}
  \frametitle{JDBC}

  \begin{itemize}
    \item \alert{JDBC}: Java DataBase Connectivity

    \pause
    \item ODBC ile aynı mimari kavramları
    \begin{itemize}
      \item değişik sürücü tipleri
    \end{itemize}

    \pause
    \item bağlantı için JDBC URL adresi
    \begin{itemize}
      \item \lstinline!jdbc:<altprotokol>:<parametreler>!
    \end{itemize}

    \pause
    \item Java ile SQL veri tiplerinin eşleştirilmesi
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{JDBC Sürücüleri}

  \begin{enumerate}
    \item \emph{Tip I}: köprüler
    \begin{itemize}
      \item başka sistemlerin çağrılarına dönüştür (örneğin ODBC)
    \end{itemize}

    \pause
    \item \emph{Tip II}: Java olmayan bir sürücüyle doğrudan çeviri
    \begin{itemize}
      \item veri kaynağının uygulama arayüzüne çevir (örneğin C++)
    \end{itemize}

    \pause
    \item \emph{Tip III}: ağ köprüleri
    \begin{itemize}
      \item veri kaynağının uygulama arayüzüne çevirmesi için\\
	orta katman yazılımına bağlan
    \end{itemize}

    \pause
    \item \emph{Tip IV}: Java sürücüsüyle doğrudan çeviri
    \begin{itemize}
      \item VTYS ile Java soketleri üzerinden iletişim kur
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{JDBC Akışı}

  \begin{itemize}
    \item bir bağlantı nesnesi al
    \begin{itemize}
      \item statik: \lstinline!DriverManager.getConnection()!
	$\rightarrow$ \lstinline!Connection!
    \end{itemize}

    \pause
    \item bağlantı üzerinde bir komut nesnesi yarat
    \begin{itemize}
      \item \lstinline!Connection.createStatement()!
	 $\rightarrow$ \lstinline!Statement!
    \end{itemize}

    \pause
    \item sorguyu çalıştır
    \begin{itemize}
      \item okuma: \lstinline!Statement.executeQuery(query)!
	$\rightarrow$ \lstinline!ResultSet!
      \item ekleme, güncelleme, silme: \lstinline!Statement.executeUpdate(query)!
    \end{itemize}

    \pause
    \item sonuçları işle

    \pause
    \item işi biten kaynakları kapat\\
      (sonuç kümesi, komut, bağlantı)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Sonuçların İşlenmesi}

  \begin{itemize}
    \item \lstinline!ResultSet! bir yineleyici
    \begin{itemize}
      \item başta satır olup olmadığı: \lstinline!ResultSet.hasNext()!
      \item sıradaki satıra geç: \lstinline!ResultSet.next()!
    \end{itemize}

    \pause
    \medskip
    \item satırdaki veriyi uygun tiplere dönüştürerek değişkenlere aktar
    \begin{itemize}
      \item sütunun adıyla: \lstinline!ResultSet.getXXX(name)!
      \item sütunun sıra numarasıyla: \lstinline!ResultSet.getXXX(order)!
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Veri Tipi Dönüşümleri}

  \begin{table}
    \begin{tabular}{|l|l|l|}\hline
SQL tipi  & Java sınıfı        & ResultSet metodu\\\hline\hline
BIT       & Boolean            & getBoolean()    \\\hline
CHAR      & String             & getString()     \\\hline
VARCHAR   & String             & getString()     \\\hline
DOUBLE    & Double             & getDouble()     \\\hline
FLOAT     & Float              & getDouble()     \\\hline
INTEGER   & Integer            & getInt()        \\\hline
REAL      & Double             & getFloat()      \\\hline
DATE      & java.sql.Date      & getDate()       \\\hline
TIME      & java.sql.Time      & getTime()       \\\hline
TIMESTAMP & java.sql.TimeStamp & getTimestamp()  \\\hline
    \end{tabular}
  \end{table}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Örneği}

  \begin{ornek}[veri tabanı sürücüsünün yüklenmesi]
    \begin{lstlisting}
try {
  Class.forName("org.postgresql.Driver");
} catch (ClassNotFoundException e) {
  // PostgreSQL driver not installed
}
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Örneği}

  \begin{ornek}[veri tabanına bağlantı]
    \begin{lstlisting}
try {
  Connection conn = DriverManager.getConnection(
    "jdbc:postgresql:imdb", "itucs", "itucs"
  );
} catch (SQLException e) {
  // connection error
}
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Örneği}

  \begin{ornek}[ekleme]
    \begin{lstlisting}
String query = "INSERT INTO MOVIE (TITLE, YR)"
    + " VALUES ('Casablanca', 1942)";
Statement stmt = conn.createStatement();
stmt.executeUpdate(query);
stmt.close();
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}
  \frametitle{Hazır Komutlar}

  \begin{itemize}
    \item hazır komutlar parametre değerleri değiştirilerek\\
      yeniden kullanılabilir

    \pause
    \medskip
    \item yaratma:\\
      \lstinline!Connection.prepareStatement(query)!
      $\rightarrow$ \lstinline!PreparedStatement!
    \item sorguda parametreler için yer tutucu: '\lstinline!?!'
    \begin{itemize}
      \item çalıştırmadan önce değerleri ayarlanmalı:\\
        \lstinline!PreparedStatement.setXXX(order, value)!
    \end{itemize}

    \pause
    \medskip
    \item çalıştırma: \lstinline!PreparedStatement.executeQuery()!\\
      ya da \lstinline!PreparedStatement.executeUpdate()!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Hazır Komut Örneği}

  \begin{ornek}[ekleme - hazır komutla]
    \begin{lstlisting}
String query = "INSERT INTO MOVIE (TITLE, YR)"
    + " VALUES (?, ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
for (Movie movie : getMovies()) {
    stmt.setString(1, movie.getTitle());
    stmt.setInt(2, movie.getYear());
    stmt.executeUpdate();
}
stmt.close();
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sonuç Kümesi Örneği}

  \begin{ornek}[bir yıldaki film başlıklarını listeleme]
    \begin{lstlisting}
String query = String.format(
  "SELECT TITLE FROM MOVIE WHERE (YR = %d)",
  year);
Statement stmt = conn.createStatement();
ResultSet results = stmt.executeQuery(query);
while (results.next()) {
    String title = results.getString("TITLE");
    System.out.println("Title: " + title),
}
results.close();
stmt.close();
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Örneği}

  \begin{ornek}[silme]
    \begin{lstlisting}
String query = "DELETE FROM MOVIE" +
    " WHERE (ID = ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
stmt.setInt(1, movie.getId());
stmt.executeUpdate();
stmt.close();
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{JDBC Örneği}

  \begin{ornek}[güncelleme]
    \begin{lstlisting}
String query = "UPDATE MOVIE SET YR = ?" +
    " WHERE (ID = ?)";
PreparedStatement stmt =
    conn.prepareStatement(query);
stmt.setInt(1, movie.getYear());
stmt.setInt(2, movie.getId());
stmt.executeUpdate();
stmt.close();
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}
  \frametitle{Kaynakları Kapama}

  \begin{itemize}
    \item sonuç kümesi, komut gibi kaynakların\\
      \lstinline!try - catch - finally! bloklarının\\
      \lstinline!finally! kısmında kapatılması önerilir
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Kaynakları Kapatma Örneği}

  \begin{block}{}
    \begin{lstlisting}
Statement stmt = conn.createStatement();
ResultSet results = null;
try {
    results = stmt.executeQuery(query);
    ...
} catch (SQLException e) {
    ...
} finally {
    results.close();
    stmt.close();
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Otomatik Kimlik Değerleri}

  \begin{itemize}
    \item otomatik üretilen kimlik değerleri sorulmak isteniyorsa,\\
      komutu yaratırken\\
      \lstinline!RETURN_GENERATED_KEYS! bayrağı kullanılır
    \item komutu çalıştırdıktan sonra:\\
      \lstinline!Statement.getGeneratedKeys()! $\rightarrow$
      \lstinline!ResultSet!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Otomatik Kimlik Değerleri Örneği}

  \begin{block}{}
    \begin{lstlisting}
String query = "INSERT INTO ... ";
PreparedStatement stmt =
    connection.prepareStatement(query,
        Statement.RETURN_GENERATED_KEYS);
stmt.executeUpdate();

ResultSet ids = stmt.getGeneratedKeys();
// assuming there is one and only one result
ids.next();
int id = ids.getInt(1);
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Toplu Komut Çalıştırma}

  \begin{itemize}
    \item komutları biriktirerek topluca çalıştırmak hız kazandırabilir

    \pause
    \medskip
    \item bağlantı "auto commit" kipinden çıkarılır
    \item biriktirme: \lstinline!Statement.addBatch(query)!
    \item birikenleri çalıştırma: \lstinline!Statement.executeBatch()!
    \item yazmayı sonlandırma: \lstinline!Connection.commit()!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Toplu Komut Çalıştırma Örneği}

  \begin{block}{}
    \begin{lstlisting}
stmt = conn.createStatement( ... );
conn.setAutoCommit(false);
int queryCount = 0;
int batchSize = 100;
for ( ... ) {
    stmt.addBatch(query);
    queryCount++;
    if (queryCount % batchSize == 0) {
        stmt.executeBatch();
        conn.commit();
    }
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Önceden Okuma Miktarı}

  \begin{itemize}
    \item JDBC sürücüleri sorgudaki satırları önceden okur
    \item başarımı artırır ama bellek harcamasını da artırır

    \pause
    \medskip
    \item küçük bir önceden okuma miktarı bellek harcamasını azaltır:\\
      \lstinline!Statement.setFetchSize(count)!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Önceden Okuma Miktarı Örneği}

  \begin{block}{}
    \begin{lstlisting}
stmt.setFetchSize(1);

// MySQL
stmt.setFetchSize(Integer.MIN_VALUE)
    \end{lstlisting}
  \end{block}
\end{frame}

\lstset{language=ExtendedSQL}

\section{SQL}

\subsection{Kayıtlı Yordamlar}

\begin{frame}
  \frametitle{Kayıtlı Yordamlar}

  \begin{itemize}
    \item uygulamanın bazı işlevleri\\
      veri tabanı sunucusunda gerçeklenebilir
    \begin{itemize}
      \item diller: SQL, PL/SQL, C, ...
    \end{itemize}

    \pause
    \bigskip
    \item \alert{tavsiye edilmez}
    \begin{itemize}
      \item taşınabilir değil
      \item ölçeklenebilir değil
      \item veri tabanı sunucuları iş mantığına göre optimize edilmiyor
    \end{itemize}
    $\rightarrow$ iş mantığı uygulama sunucusunda gerçeklenmeli
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Fonksiyon Yaratma}

  \begin{block}{Komut}
    \begin{lstlisting}
CREATE FUNCTION
  function_name([parameter_type [, ...]])
  RETURNS return_type
  AS function_body
  LANGUAGE language_name
    \end{lstlisting}
  \end{block}

  \begin{itemize}
    \item birinci parametre \$1, ikinci parametre \$2, ...
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SQL Fonksiyonu Örneği}

  \begin{ornek}[yeni puan hesaplanması]
    \$1: eski puan, \$2: eski oy sayısı, \$3: yeni oy
    \begin{lstlisting}
CREATE FUNCTION NEW_SCORE(float, int, int)
  RETURNS float
  AS 'SELECT ($1*$2+$3) / ($2+1);'
  LANGUAGE 'sql'
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}
  \frametitle{Tetikler}

  \begin{tanim}
    \alert{tetik}: belirli olaylarda kendiliğinden etkinleştirilen fonksiyon
  \end{tanim}

  \begin{itemize}
    \item bütünlüğü sağlamaya yardımcı olabilir
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tetik Yaratma}

  \begin{block}{Komut}
    \begin{lstlisting}
CREATE TRIGGER trigger_name
  { BEFORE | AFTER } { event [ OR ... ] }
  ON table_name
  [ FOR [ EACH ] { ROW | STATEMENT } ]
  EXECUTE PROCEDURE function_name(...)
    \end{lstlisting}
  \end{block}

  \begin{itemize}
    \item PL/pgSQL:
    \begin{itemize}
      \item \lstinline!old!: çoklunun işlemden önceki değeri
      \item \lstinline!new!: çoklunun işlemden sonraki değeri
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tetik Örneği}

  \begin{ornek}[SCORE * VOTES değeri POINTS sütununda tutulsun]
    \begin{lstlisting}
CREATE FUNCTION UPDATE_MOVIE_POINTS()
  RETURNS opaque
  AS 'BEGIN
      new.POINTS = new.SCORE * new.VOTES;
      RETURN new;
      END;'
  LANGUAGE 'plpgsql'
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Tetik Örneği}

  \begin{ornek}[POINTS sütunu güncellemelerde kendiliğinden hesaplansın]
    \begin{lstlisting}
CREATE TRIGGER UPDATE_MOVIE
  BEFORE INSERT OR UPDATE ON MOVIE
  FOR EACH ROW
  EXECUTE PROCEDURE UPDATE_MOVIE_POINTS()
    \end{lstlisting}
  \end{ornek}
\end{frame}

\subsection{Görüntüler}

\begin{frame}
  \frametitle{Görüntüler}

  \begin{itemize}
    \item türetilmiş tabloyu taban tablo gibi göstermek

    \pause
    \item veri tabanı yapısındaki değişikliklerden\\
      kullanıcıların ve uygulama programlarının etkilenmemesi
%       \begin{itemize}
%         \item normalizasyon ile bölünen tablonun var olan uygulamalara eskisi
%           gibi gösterilmesi
%       \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Görüntü Yaratma}

  \begin{block}{Komut}
    \begin{lstlisting}
CREATE VIEW view_name AS
  SELECT ...
    \end{lstlisting}
  \end{block}

  \begin{itemize}
    \item görüntü üzerindeki her işlemde\\
      \lstinline!SELECT! komutu yeniden çalıştırılır
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Görüntü Örneği}

  \begin{ornek}
    \begin{lstlisting}
CREATE VIEW NEW_MOVIE AS
  SELECT ID, TITLE, YR FROM MOVIE
    WHERE (YR > 1995)

SELECT * FROM NEW_MOVIE
    \end{lstlisting}
  \end{ornek}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Görüntüde Güncelleme}

  \begin{itemize}
    \item güncellemeler taban tablolarda yapılmalı
    \begin{itemize}
      \item kural belirtilmeli
    \end{itemize}
  \end{itemize}

  \pause
  \begin{block}{Kural Yaratma}
    \begin{lstlisting}
CREATE RULE rule_name AS
  ON event TO view_name
  [ WHERE condition ]
  DO [ INSTEAD ] sql_statement
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Görüntü Kuralı Örneği}

  \begin{ornek}
    \begin{lstlisting}
UPDATE NEW_MOVIE SET TITLE = '..'
  WHERE (ID = 1)
    \end{lstlisting}

    \pause
    \begin{lstlisting}
CREATE RULE UPDATE_TITLE AS
  ON UPDATE TO NEW_MOVIES
  DO INSTEAD
    UPDATE MOVIE SET TITLE = new.TITLE
      WHERE (ID = old.ID)
    \end{lstlisting}
  \end{ornek}
\end{frame}

\subsection{İzinler}

\begin{frame}
  \frametitle{İzinler}

  \begin{itemize}
    \item \alert{özne}: kullanıcı, kullanıcı grubu
    \item \alert{nesne}: tablo, sütun, görüntü, veri tabanı, ...

    \pause
    \item nesnenin sahibi olan özne\\
      diğer öznelerin erişim yetkilerini belirler
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{SQL İzinleri}

  \begin{block}{İzin Verme}
    \begin{lstlisting}
GRANT permission_name [, ...]
  ON object_name TO subject_name
  [ WITH GRANT OPTION ]
    \end{lstlisting}
  \end{block}

  \pause
  \begin{block}{İzin Kaldırma}
    \begin{lstlisting}
REVOKE permission_name
  ON object_name FROM subject_name
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{İzin Örnekleri}

  \begin{ornek}[tablo için izin verme]
    \begin{lstlisting}
GRANT SELECT, INSERT, UPDATE ON MOVIE
  TO 'itucs'
    \end{lstlisting}
  \end{ornek}

  \pause
  \begin{ornek}[tablo için izin kaldırma]
    \begin{lstlisting}
REVOKE INSERT ON MOVIE
  FROM 'itucs'
    \end{lstlisting}
  \end{ornek}
\end{frame}

\subsection{İpuçları}

\begin{frame}[fragile]
  \frametitle{Dizinler}

  \begin{itemize}
    \item bazı işlemler sıralama gerektirir:\\
      \lstinline!ORDER BY, DISTINCT, GROUP BY, UNION, ...!

    \pause
    \item dizinler aramaları hızlandırır
    \begin{itemize}
      \item ekleme ve güncellemeleri yavaşlatır
    \end{itemize}
  \end{itemize}

  \pause
  \begin{block}{Komut}
    \begin{lstlisting}
CREATE [ UNIQUE ] INDEX index_name
  ON table_name(column_name [, ...])
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Toplu Veri Aktarımı}

  \begin{itemize}
    \item satırları tek tek eklemek ya da silmek yerine\\
      ürüne özel toplu veri aktarımı komutları kullanılmalı

    \item tab ile ayrılmış değer dosyaları ile okuma-yazma
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Toplu Veri Aktarımı}

  \begin{block}{PostgreSQL}
    \begin{lstlisting}
COPY table_name (column_name [, ...])
  TO 'output_file_path'

COPY table_name (column_name [, ...])
  FROM 'input_file_path'
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Toplu Veri Aktarımı}

  \begin{block}{MySQL}
    \begin{lstlisting}
SELECT column_name [, ...] FROM table_name
  INTO OUTFILE 'output_file_path'

LOAD DATA INFILE 'input_file_path'
  INTO TABLE table_name (column_name [, ...])
    \end{lstlisting}
  \end{block}
\end{frame}

\section*{Kaynaklar}

\begin{frame}
  \frametitle{Kaynaklar}

  \begin{block}{Okunacak: Date}
    \begin{itemize}
      \item Chapter 4: An Introduction to SQL
      \begin{itemize}
        \item 4.6. Embedded SQL
      \end{itemize}

      \item Chapter 9: Integrity
      \begin{itemize}
        \item 9.11. \alert{Triggers (a Digression)}
      \end{itemize}

      \item Chapter 10: \alert{Views}
    \end{itemize}
  \end{block}

  \begin{block}{Yardımcı Kaynak: Ramakrishnan, Gehrke}
    \begin{itemize}
      \item Chapter 6: Database Application Development
    \end{itemize}
  \end{block}
\end{frame}

\end{document}
